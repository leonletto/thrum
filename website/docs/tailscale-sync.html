<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>tailscale-sync — Thrum</title>
  <meta name="description" content="">
  <!-- Open Graph -->
  <meta property="og:type" content="article">
  <meta property="og:title" content="tailscale-sync — Thrum">
  <meta property="og:description" content="">
  <meta property="og:url" content="https://leonletto.github.io/thrum/docs/tailscale-sync.html">
  <meta property="og:site_name" content="Thrum">
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="tailscale-sync — Thrum">
  <meta name="twitter:description" content="">
  <!-- Canonical: SPA is the primary URL -->
  <link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#tailscale-sync.html">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x26A1;</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/theme.css">
  <link rel="stylesheet" href="../css/docs.css">
  <script>
    (function(){var t=localStorage.getItem('thrum-theme');if(t){document.documentElement.setAttribute('data-theme',t)}else if(window.matchMedia&&window.matchMedia('(prefers-color-scheme:light)').matches){document.documentElement.setAttribute('data-theme','light')}else{document.documentElement.setAttribute('data-theme','dark')}})();
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <nav class="header-nav">
        <a href="../index.html" class="logo">
          <span class="logo-glyph">&gt;_</span>
          <span class="logo-text">thrum</span>
        </a>
        <div class="nav-links">
          <a href="../index.html" class="nav-link">Home</a>
          <a href="../docs.html" class="nav-link nav-link-active">Docs</a>
          <a href="../about.html" class="nav-link">About</a>
          <a href="https://github.com/leonletto/thrum" class="nav-link nav-link-external" target="_blank" rel="noopener">GitHub</a>
        </div>
      </nav>
    </div>
  </header>
  <main class="docs-content" style="max-width:48rem;margin:2rem auto;padding:0 1.5rem">
    <div class="docs-content-inner">
<h1>Tailscale Sync</h1>
<blockquote>
<p>See also: <a href="tailscale-security.html">Tailscale Security</a> for the security<br>model, <a href="multi-agent.html">Multi-Agent Support</a> for team coordination patterns,<br><a href="sync.html">Sync Protocol</a> for Git-based synchronization.</p>
</blockquote>
<h2>Overview</h2>
<p>Thrum&#39;s Tailscale sync enables real-time event synchronization between daemon<br>instances running on different machines connected via a<br><a href="https://tailscale.com">Tailscale</a> network. Agents on separate laptops, VMs, or<br>CI runners can coordinate as if they were on the same machine -- messages,<br>agent events, and session updates propagate automatically.</p>
<p><strong>Key capabilities:</strong></p>
<ul>
<li><strong>Cross-machine sync</strong> -- Events flow between daemons over Tailscale&#39;s<br>encrypted WireGuard tunnels</li>
<li><strong>Push + pull</strong> -- Immediate push notifications on new events, with periodic<br>pull as a fallback</li>
<li><strong>Human-mediated pairing</strong> -- Simple 4-digit code to pair two machines (no<br>auto-discovery, no complex key management)</li>
<li><strong>Token authentication</strong> -- Each peer pair shares a unique 32-byte token for<br>ongoing auth</li>
<li><strong>Zero config networking</strong> -- No port forwarding, no firewall rules. Tailscale<br>handles connectivity</li>
</ul>
<h2>Prerequisites</h2>
<ol>
<li><strong>Tailscale installed</strong> on all machines running Thrum daemons</li>
<li><strong>Thrum v0.3.2+</strong> installed on all machines</li>
</ol>
<h2>Getting Started</h2>
<h3>1. Enable Tailscale Sync</h3>
<p>Set the environment variable to enable Tailscale integration:</p>
<pre><code class="language-bash hljs"><span class="hljs-built_in">export</span> THRUM_TS_ENABLED=<span class="hljs-literal">true</span></code></pre>
<h3>2. Start the Daemon</h3>
<pre><code class="language-bash hljs">thrum daemon start</code></pre>
<p>When Tailscale sync is enabled, the daemon:</p>
<ul>
<li>Starts a tsnet listener on port 9100 (configurable)</li>
<li>Registers sync RPC handlers (<code>sync.pull</code>, <code>sync.notify</code>, <code>sync.peer_info</code>,<br><code>pair.request</code>)</li>
<li>Waits for peer pairing via CLI</li>
</ul>
<h3>3. Pair Two Machines</h3>
<p>Pairing requires action on both machines simultaneously:</p>
<p><strong>On Machine A</strong> (the one you want to share with):</p>
<pre><code class="language-bash hljs">thrum peer add
<span class="hljs-comment"># Output: Waiting for connection... Pairing code: 7392</span></code></pre>
<p><strong>On Machine B</strong> (the one joining):</p>
<pre><code class="language-bash hljs">thrum peer <span class="hljs-built_in">join</span> my-laptop:9100
<span class="hljs-comment"># Prompts: Enter pairing code:</span>
<span class="hljs-comment"># You type: 7392</span>
<span class="hljs-comment"># Output: Paired with &quot;my-laptop&quot;. Syncing started.</span></code></pre>
<p>Machine A will also show success:</p>
<pre><code>Paired with &quot;office-server&quot; (100.64.2.10:9100). Syncing started.</code></pre>
<p>Both machines now sync events automatically.</p>
<h3>4. Verify Sync</h3>
<pre><code class="language-bash hljs"><span class="hljs-comment"># List paired peers</span>
thrum peer list

<span class="hljs-comment"># Detailed sync status</span>
thrum peer status

<span class="hljs-comment"># Check health endpoint</span>
thrum status</code></pre>
<h2>Architecture</h2>
<pre><code>Machine A                           Machine B
┌─────────────────────┐             ┌─────────────────────┐
│  Thrum Daemon       │             │  Thrum Daemon       │
│  ├─ Event Log       │             │  ├─ Event Log       │
│  ├─ tsnet Listener  │◄──────────►│  ├─ tsnet Listener  │
│  ├─ Sync Manager    │  Tailscale  │  ├─ Sync Manager    │
│  └─ Peer Registry   │  (WireGuard)│  └─ Peer Registry   │
└─────────────────────┘             └─────────────────────┘
         │                                    │
    ┌────┴────┐                          ┌────┴────┐
    │ Agents  │                          │ Agents  │
    │ CLI/MCP │                          │ CLI/MCP │
    └─────────┘                          └─────────┘</code></pre>
<h3>Component Overview</h3>
<table>
<thead>
<tr>
<th>Component</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Event Log</strong></td>
<td>Sequenced event store with origin tracking and dedup</td>
</tr>
<tr>
<td><strong>tsnet Listener</strong></td>
<td>Tailscale-native TCP listener (no port forwarding needed)</td>
</tr>
<tr>
<td><strong>Sync Manager</strong></td>
<td>Orchestrates pull sync, push notifications, and the scheduler</td>
</tr>
<tr>
<td><strong>Sync Client</strong></td>
<td>Pulls events from peers in batches with checkpointing</td>
</tr>
<tr>
<td><strong>Sync Server</strong></td>
<td>Exposes <code>sync.*</code> and <code>pair.*</code> RPC methods to peers (token-authenticated)</td>
</tr>
<tr>
<td><strong>Peer Registry</strong></td>
<td>Thread-safe registry of paired peers with JSON persistence</td>
</tr>
<tr>
<td><strong>Pairing Manager</strong></td>
<td>Handles the 4-digit code pairing flow</td>
</tr>
<tr>
<td><strong>Sync Scheduler</strong></td>
<td>Periodic fallback sync (5-minute interval, skips recently synced peers)</td>
</tr>
</tbody></table>
<h2>Sync Protocol</h2>
<h3>Event Log Foundation</h3>
<p>Every event written to the daemon includes:</p>
<ul>
<li><strong><code>origin_daemon</code></strong> -- Unique daemon ID identifying the source machine</li>
<li><strong><code>sequence</code></strong> -- Monotonically increasing per-daemon sequence number</li>
</ul>
<p>Events are stored in a SQLite <code>events</code> table with sequence-based pagination,<br>enabling efficient delta sync.</p>
<h3>Pull Sync</h3>
<p>The primary sync mechanism. Daemon A asks Daemon B: &quot;Give me all events after<br>sequence N.&quot;</p>
<pre><code>Daemon A                              Daemon B
   │                                      │
   │ sync.pull(after_seq=42, token=...)   │
   ├─────────────────────────────────────►│
   │                                      │
   │  {events: [...], next_seq: 1042,     │
   │   more_available: true}              │
   │◄─────────────────────────────────────┤
   │                                      │
   │ sync.pull(after_seq=1042, token=...) │
   ├─────────────────────────────────────►│
   │                                      │
   │  {events: [...], next_seq: 1500,     │
   │   more_available: false}             │
   │◄─────────────────────────────────────┤</code></pre>
<p>Batched pull with the <code>limit+1</code> trick to determine <code>more_available</code>. Checkpoints<br>are persisted per-peer so sync resumes from where it left off. All requests<br>include the peer&#39;s auth token.</p>
<h3>Push Notifications</h3>
<p>When a daemon writes a new event, it broadcasts a <code>sync.notify</code> to all known<br>peers:</p>
<pre><code>Daemon A writes event
   │
   ├──► sync.notify(daemon_id, latest_seq, token) ──► Daemon B
   ├──► sync.notify(daemon_id, latest_seq, token) ──► Daemon C
   │
   Daemons B and C pull new events from A</code></pre>
<p>Push notifications are fire-and-forget -- failures are logged but do not block<br>the writer.</p>
<h3>Periodic Sync Scheduler</h3>
<p>A fallback mechanism that runs every 5 minutes. It pulls from all known peers<br>that were not synced recently (within the last 2 minutes). This ensures<br>convergence even if push notifications are lost.</p>
<h3>Deduplication</h3>
<p>Events are deduplicated by <code>event_id</code> (ULID-based, globally unique). The<br><code>HasEvent()</code> function provides O(1) dedup via the SQLite primary key index.<br>Duplicate events from overlapping syncs are silently skipped.</p>
<h2>Pairing Flow</h2>
<p>Pairing establishes mutual trust between two machines with a human in the loop.</p>
<pre><code>Machine A (thrum peer add)           Machine B (thrum peer join)
   │                                      │
   │  1. Generate 4-digit code + token    │
   │  2. Display code to user             │
   │                                      │
   │        (human shares code)           │
   │                                      │
   │  pair.request(code, id, name, addr)  │
   │◄─────────────────────────────────────┤ 3. User enters code
   │                                      │
   │  4. Verify code                      │
   │  5. Store peer B + token             │
   │                                      │
   │  {status: paired, token, id, name}   │
   ├─────────────────────────────────────►│ 6. Store peer A + token
   │                                      │
   │  Both peers now authenticate with    │
   │  the shared token on every request   │</code></pre>
<ul>
<li>The pairing code is a random 4-digit number (3 attempts allowed)</li>
<li>The token is a random 32-byte hex string</li>
<li>Pairing sessions expire after 5 minutes</li>
<li>Both peers store each other&#39;s info in <code>peers.json</code></li>
</ul>
<h2>Configuration</h2>
<h3>Environment Variables</h3>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>THRUM_TS_ENABLED</code></td>
<td><code>false</code></td>
<td>Enable Tailscale sync</td>
</tr>
<tr>
<td><code>THRUM_TS_HOSTNAME</code></td>
<td>(auto)</td>
<td>Hostname for the tsnet listener</td>
</tr>
<tr>
<td><code>THRUM_TS_PORT</code></td>
<td><code>9100</code></td>
<td>Port for the sync RPC listener</td>
</tr>
<tr>
<td><code>THRUM_TS_AUTH_KEY</code></td>
<td>(none)</td>
<td>Tailscale auth key for headless setup</td>
</tr>
<tr>
<td><code>THRUM_TS_CONTROL_URL</code></td>
<td>(default)</td>
<td>Custom control server URL</td>
</tr>
<tr>
<td><code>THRUM_TS_STATE_DIR</code></td>
<td><code>.thrum/var/tsnet</code></td>
<td>tsnet state directory</td>
</tr>
</tbody></table>
<h2>CLI Commands</h2>
<h3><code>thrum peer</code></h3>
<p>Manage sync peers:</p>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Start pairing on this machine (displays 4-digit code)</span>
thrum peer add

<span class="hljs-comment"># Join a remote peer (prompts for pairing code)</span>
thrum peer <span class="hljs-built_in">join</span> &lt;address:port&gt;

<span class="hljs-comment"># List all paired peers</span>
thrum peer list

<span class="hljs-comment"># Remove a peer</span>
thrum peer remove &lt;name&gt;

<span class="hljs-comment"># Detailed sync status for all peers</span>
thrum peer status</code></pre>
<h3><code>thrum status</code></h3>
<p>When Tailscale sync is enabled, <code>thrum status</code> includes sync information:</p>
<pre><code>Tailscale Sync: enabled
  Peers: 2 connected
  Last sync: 30s ago
  Hostname: my-laptop</code></pre>
<h2>Security Model</h2>
<p>Tailscale sync uses a simple three-layer security model:</p>
<h3>1. Tailscale Encryption (Network Layer)</h3>
<p>All traffic between daemons flows over Tailscale&#39;s WireGuard tunnels. This<br>provides end-to-end encryption and identity verification at the network level.<br>No data travels over the public internet unencrypted.</p>
<h3>2. Pairing Code (Trust Establishment)</h3>
<p>A human-mediated 4-digit code establishes initial trust between two machines.<br>The pairing code must be shared out-of-band (verbally, chat, etc.), ensuring<br>both sides consent to the peering relationship.</p>
<ul>
<li>4-digit random code (10,000 possibilities)</li>
<li>3 attempts allowed before the session is locked</li>
<li>5-minute timeout on pairing sessions</li>
</ul>
<h3>3. Token Authentication (Ongoing Auth)</h3>
<p>After pairing, each request includes a 32-byte hex token. The receiving daemon<br>validates the token against its peer registry before processing any sync<br>request. The <code>pair.request</code> method is the only RPC exempt from token<br>authentication (it&#39;s how new peers establish their tokens).</p>
<ul>
<li>Token validation is centralized in the sync server</li>
<li>Invalid or missing tokens are rejected immediately</li>
<li>Peer&#39;s <code>last_sync</code> is updated on each successful authenticated request</li>
</ul>
<h2>Peer Management</h2>
<h3>Peer Registry</h3>
<p>The peer registry is stored as JSON at <code>.thrum/var/peers.json</code> and persists<br>across daemon restarts. It tracks:</p>
<ul>
<li>Daemon ID and name</li>
<li>Network address (Tailscale IP + port)</li>
<li>Auth token</li>
<li>Paired-at timestamp and last sync time</li>
</ul>
<h2>Monitoring</h2>
<h3>Health Endpoint</h3>
<p>The daemon&#39;s <code>health</code> RPC method includes Tailscale sync status when enabled:</p>
<pre><code class="language-json hljs"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;tailscale_sync&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;hostname&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-laptop&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;peer_count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;peers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">&quot;daemon_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;d_abc123&quot;</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;office-server&quot;</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;last_sync&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;30s ago&quot;</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<h3>Logs</h3>
<p>Tailscale sync logs are prefixed for easy filtering:</p>
<pre><code>[pairing] Session started, code=7392, timeout=5m0s
[pairing] Paired with office-server (d_abc123) at 100.64.2.10:9100
sync.notify: synced from d_abc123 — applied=5 skipped=0
periodic_sync: starting with interval=5m0s, recent_threshold=2m0s</code></pre>
<h2>Troubleshooting</h2>
<h3>Cannot reach peer</h3>
<ol>
<li>Verify both machines are on the same Tailscale network</li>
<li>Check that both daemons are running (<code>thrum daemon start</code>)</li>
<li>Verify the address format is <code>hostname:port</code> (default port: 9100)</li>
<li>Test connectivity: <code>tailscale ping &lt;hostname&gt;</code></li>
</ol>
<h3>Pairing code rejected</h3>
<ul>
<li>Ensure you&#39;re entering the code displayed on the other machine</li>
<li>Codes expire after 5 minutes -- run <code>thrum peer add</code> again if expired</li>
<li>After 3 failed attempts, the session locks -- restart with <code>thrum peer add</code></li>
</ul>
<h3>Sync not working after pairing</h3>
<ol>
<li>Check <code>thrum peer status</code> for connection details</li>
<li>Verify both daemons have Tailscale enabled (<code>THRUM_TS_ENABLED=true</code>)</li>
<li>Check daemon logs for sync errors</li>
</ol>
<h2>Best Practices</h2>
<h3>Network Setup</h3>
<ul>
<li><strong>Use auth keys</strong> (<code>THRUM_TS_AUTH_KEY</code>) for headless CI/CD runners</li>
<li><strong>Keep the default port</strong> (9100) unless you have a conflict</li>
<li><strong>Use Tailscale ACLs</strong> to restrict which machines can communicate</li>
</ul>
<h3>Performance</h3>
<ul>
<li><strong>Push notifications</strong> handle most sync latency -- events typically propagate<br>within seconds</li>
<li><strong>Periodic sync</strong> (5 min) acts as a safety net, not the primary mechanism</li>
<li><strong>Batch size</strong> of 1000 events per pull keeps memory bounded during large syncs</li>
<li><strong>Checkpointing</strong> ensures no redundant transfers after restarts</li>
</ul>
<h2>See Also</h2>
<ul>
<li><a href="tailscale-security.html">Tailscale Security</a> -- Security model documentation</li>
<li><a href="multi-agent.html">Multi-Agent Support</a> -- Groups, runtime presets, and team<br>coordination</li>
<li><a href="agent-coordination.html">Agent Coordination</a> -- Workflow patterns and Beads<br>integration</li>
<li><a href="sync.html">Sync Protocol</a> -- Git-based synchronization details</li>
<li><a href="cli.html">CLI Reference</a> -- Complete command documentation</li>
</ul>

    </div>
    <p style="margin-top:2rem"><a href="../docs.html#tailscale-sync.html">&larr; View in documentation</a></p>
  </main>
  <script>
    // Redirect browsers to the SPA for full navigation experience.
    // Crawlers (which don't execute JS) will index the static content above.
    if (window.location.search.indexOf('nospa') === -1) {
      window.location.replace('../docs.html#tailscale-sync.html');
    }
  </script>
</body>
</html>