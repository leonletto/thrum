<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Tailscale Sync — Thrum</title>
<meta name="description" content="Direct machine-to-machine sync via Tailscale — setup, architecture, pairing, and CLI commands">
<link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#tailscale-sync.html">
<style>
body{font-family:system-ui,sans-serif;max-width:48rem;margin:2rem auto;padding:0 1.5rem;line-height:1.6;color:#222}
pre{background:#f5f5f5;padding:1rem;overflow-x:auto;border-radius:4px}
code{font-family:ui-monospace,monospace;font-size:0.9em}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #ddd;padding:0.4rem 0.6rem;text-align:left}
th{background:#f5f5f5}
nav{margin-bottom:1.5rem;padding-bottom:1rem;border-bottom:1px solid #ddd;line-height:1.8}
h2{margin-top:2rem}
a{color:#0366d6}
</style>
</head>
<body>
<nav>
<strong><a href="../docs.html">Thrum Docs</a></strong> &rsaquo; Guides &rsaquo; Tailscale Sync
<hr>
<strong>Overview</strong>: <a href="philosophy.html">Philosophy</a><br>
<strong>Getting Started</strong>: <a href="quickstart.html">Quickstart Guide</a><br>
  <strong>Recommended Tools</strong>: <a href="guides/recommended-tools.html">Recommended Tools</a> | <a href="guides/beads-setup.html">Beads Setup Guide</a> | <a href="guides/beads-ui-setup.html">Beads UI Setup Guide</a> | <a href="guides/playwright-cli-setup.html">Playwright CLI Setup Guide</a><br>
<strong>Web UI</strong>: <a href="web-ui.html">Web UI</a><br>
<strong>Messaging</strong>: <a href="subscriptions.html">Subscriptions & Notifications</a><br>
<strong>Identity</strong>: <a href="identity.html">Agent Identity & Registration</a><br>
<strong>Guides</strong>: <a href="agent-coordination.html">Agent Coordination</a> | <a href="agent-configs.html">Agent Configurations</a> | <a href="multi-agent.html">Multi-Agent Support</a> | <a href="claude-code-plugin.html">Claude Code Plugin</a> | <a href="configuration.html">Configuration</a> | <a href="workflow-templates.html">Workflow Templates</a> | <a href="beads-and-thrum.html">Beads and Thrum</a> | <a href="codex-plugin.html">Codex Plugin</a> | <a href="claude-agent-integration.html">Claude Code Agent Integration</a> | <a href="messaging.html">Messaging</a> | <strong>Tailscale Sync</strong> | <a href="tailscale-security.html">Tailscale Sync Security</a> | <a href="overview.html">Technical Overview</a><br>
<strong>API Reference</strong>: <a href="event-streaming.html">Event Streaming</a> | <a href="inbox-query-methods.html">Inbox Query Methods</a> | <a href="api/authentication.html">Authentication</a> | <a href="api/events.html">Event Reference</a> | <a href="rpc-api.html">RPC API</a> | <a href="api/websocket.html">WebSocket API</a><br>
<strong>Daemon</strong>: <a href="daemon.html">Daemon Architecture</a><br>
<strong>Sync</strong>: <a href="sync.html">Sync Protocol</a><br>
<strong>Development</strong>: <a href="development.html">Development Guide</a> | <a href="security-cicd.html">Security & CI/CD</a><br>
<strong>Architecture</strong>: <a href="architecture.html">Architecture</a><br>
<strong>Context</strong>: <a href="context.html">Agent Context Management</a><br>
<strong>Reference</strong>: <a href="cli.html">CLI Reference</a> | <a href="mcp-server.html">MCP Server</a><br>
<strong>uncategorized</strong>: <a href="role-templates.html">Role-Based Preamble Templates</a><br>
</nav>
<main>
<h2>Tailscale Sync</h2>
<blockquote>
<p>See also: <a href="tailscale-security.html">Tailscale Security</a> for the security model,
<a href="multi-agent.html">Multi-Agent Support</a> for team coordination patterns,
<a href="sync.html">Sync Protocol</a> for Git-based synchronization.</p>
</blockquote>
<h2>Overview</h2>
<p>Thrum&#39;s Tailscale sync enables real-time event synchronization between daemon
instances running on different machines connected via a
<a href="https://tailscale.com">Tailscale</a> network. Agents on separate laptops, VMs, or
CI runners can coordinate as if they were on the same machine -- messages, agent
events, and session updates propagate automatically.</p>
<p><strong>Key capabilities:</strong></p>
<ul>
<li><strong>Cross-machine sync</strong> -- Events flow between daemons over Tailscale&#39;s
encrypted WireGuard tunnels</li>
<li><strong>Push + pull</strong> -- Immediate push notifications on new events, with periodic
pull as a fallback</li>
<li><strong>Human-mediated pairing</strong> -- Simple 4-digit code to pair two machines (no
auto-discovery, no complex key management)</li>
<li><strong>Token authentication</strong> -- Each peer pair shares a unique 32-byte token for
ongoing auth</li>
<li><strong>Zero config networking</strong> -- No port forwarding, no firewall rules. Tailscale
handles connectivity</li>
</ul>
<h2>Prerequisites</h2>
<ol>
<li><strong>Tailscale installed</strong> on all machines running Thrum daemons</li>
<li><strong>Thrum v0.4.0+</strong> installed on all machines (Tailscale support added in
v0.4.0)</li>
</ol>
<h2>Getting Started</h2>
<h3>1. Enable Tailscale Sync</h3>
<p>Set the environment variable to enable Tailscale integration:</p>
<pre><code>export THRUM_TS_ENABLED=true</code></pre>
<h3>2. Start the Daemon</h3>
<pre><code>thrum daemon start</code></pre>
<p>When Tailscale sync is enabled, the daemon:</p>
<ul>
<li>Starts a tsnet listener on port 9100 (configurable)</li>
<li>Registers sync RPC handlers (<code>sync.pull</code>, <code>sync.notify</code>, <code>sync.peer_info</code>,
<code>pair.request</code>)</li>
<li>Waits for peer pairing via CLI</li>
</ul>
<h3>3. Pair Two Machines</h3>
<p>Pairing requires action on both machines simultaneously:</p>
<p><strong>On Machine A</strong> (the one you want to share with):</p>
<pre><code>thrum peer add
# Output: Waiting for connection... Pairing code: 7392</code></pre>
<p><strong>On Machine B</strong> (the one joining):</p>
<pre><code>thrum peer join my-laptop:9100
# Prompts: Enter pairing code:
# You type: 7392
# Output: Paired with &quot;my-laptop&quot;. Syncing started.</code></pre>
<p>Machine A will also show success:</p>
<pre><code>Paired with &quot;office-server&quot; (100.64.2.10:9100). Syncing started.</code></pre>
<p>Both machines now sync events automatically.</p>
<h3>4. Verify Sync</h3>
<pre><code># List paired peers
thrum peer list

# Detailed sync status
thrum peer status

# Check health endpoint
thrum status</code></pre>
<h2>Architecture</h2>
<pre><code>Machine A                           Machine B
┌─────────────────────┐             ┌─────────────────────┐
│  Thrum Daemon       │             │  Thrum Daemon       │
│  ├─ Event Log       │             │  ├─ Event Log       │
│  ├─ tsnet Listener  │◄──────────►│  ├─ tsnet Listener  │
│  ├─ Sync Manager    │  Tailscale  │  ├─ Sync Manager    │
│  └─ Peer Registry   │  (WireGuard)│  └─ Peer Registry   │
└─────────────────────┘             └─────────────────────┘
         │                                    │
    ┌────┴────┐                          ┌────┴────┐
    │ Agents  │                          │ Agents  │
    │ CLI/MCP │                          │ CLI/MCP │
    └─────────┘                          └─────────┘</code></pre>
<h3>Component Overview</h3>
<table>
<thead>
<tr>
<th>Component</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Event Log</strong></td>
<td>Sequenced event store with origin tracking and dedup</td>
</tr>
<tr>
<td><strong>tsnet Listener</strong></td>
<td>Tailscale-native TCP listener (no port forwarding needed)</td>
</tr>
<tr>
<td><strong>Sync Manager</strong></td>
<td>Orchestrates pull sync, push notifications, and the scheduler</td>
</tr>
<tr>
<td><strong>Sync Client</strong></td>
<td>Pulls events from peers in batches with checkpointing</td>
</tr>
<tr>
<td><strong>Sync Server</strong></td>
<td>Exposes <code>sync.*</code> and <code>pair.*</code> RPC methods to peers (token-authenticated)</td>
</tr>
<tr>
<td><strong>Peer Registry</strong></td>
<td>Thread-safe registry of paired peers with JSON persistence</td>
</tr>
<tr>
<td><strong>Pairing Manager</strong></td>
<td>Handles the 4-digit code pairing flow</td>
</tr>
<tr>
<td><strong>Sync Scheduler</strong></td>
<td>Periodic fallback sync (5-minute interval, skips recently synced peers)</td>
</tr>
</tbody></table>
<h2>Sync Protocol</h2>
<h3>Event Log Foundation</h3>
<p>Every event written to the daemon includes:</p>
<ul>
<li><strong><code>origin_daemon</code></strong> -- Unique daemon ID identifying the source machine</li>
<li><strong><code>sequence</code></strong> -- Monotonically increasing per-daemon sequence number</li>
</ul>
<p>Events are stored in a SQLite <code>events</code> table with sequence-based pagination,
enabling efficient delta sync.</p>
<h3>Pull Sync</h3>
<p>The primary sync mechanism. Daemon A asks Daemon B: &quot;Give me all events after
sequence N.&quot;</p>
<pre><code>Daemon A                              Daemon B
   │                                      │
   │ sync.pull(after_seq=42, token=...)   │
   ├─────────────────────────────────────►│
   │                                      │
   │  {events: [...], next_seq: 1042,     │
   │   more_available: true}              │
   │◄─────────────────────────────────────┤
   │                                      │
   │ sync.pull(after_seq=1042, token=...) │
   ├─────────────────────────────────────►│
   │                                      │
   │  {events: [...], next_seq: 1500,     │
   │   more_available: false}             │
   │◄─────────────────────────────────────┤</code></pre>
<p>Batched pull with the <code>limit+1</code> trick to determine <code>more_available</code>. Checkpoints
are persisted per-peer so sync resumes from where it left off. All requests
include the peer&#39;s auth token.</p>
<h3>Push Notifications</h3>
<p>When a daemon writes a new event, it broadcasts a <code>sync.notify</code> to all known
peers:</p>
<pre><code>Daemon A writes event
   │
   ├──► sync.notify(daemon_id, latest_seq, token) ──► Daemon B
   ├──► sync.notify(daemon_id, latest_seq, token) ──► Daemon C
   │
   Daemons B and C pull new events from A</code></pre>
<p>Push notifications are fire-and-forget -- failures are logged but do not block
the writer.</p>
<h3>Periodic Sync Scheduler</h3>
<p>A fallback mechanism that runs every 5 minutes. It pulls from all known peers
that were not synced recently (within the last 2 minutes). This ensures
convergence even if push notifications are lost.</p>
<h3>Deduplication</h3>
<p>Events are deduplicated by <code>event_id</code> (ULID-based, globally unique). The
<code>HasEvent()</code> function provides O(1) dedup via the SQLite primary key index.
Duplicate events from overlapping syncs are silently skipped.</p>
<h2>Pairing Flow</h2>
<p>Pairing establishes mutual trust between two machines with a human in the loop.</p>
<pre><code>Machine A (thrum peer add)           Machine B (thrum peer join)
   │                                      │
   │  1. Generate 4-digit code + token    │
   │  2. Display code to user             │
   │                                      │
   │        (human shares code)           │
   │                                      │
   │  pair.request(code, id, name, addr)  │
   │◄─────────────────────────────────────┤ 3. User enters code
   │                                      │
   │  4. Verify code                      │
   │  5. Store peer B + token             │
   │                                      │
   │  {status: paired, token, id, name}   │
   ├─────────────────────────────────────►│ 6. Store peer A + token
   │                                      │
   │  Both peers now authenticate with    │
   │  the shared token on every request   │</code></pre>
<ul>
<li>The pairing code is a random 4-digit number (3 attempts allowed)</li>
<li>The token is a random 32-byte hex string</li>
<li>Pairing sessions expire after 5 minutes</li>
<li>Both peers store each other&#39;s info in <code>peers.json</code></li>
</ul>
<h2>Configuration</h2>
<h3>Environment Variables</h3>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>THRUM_TS_ENABLED</code></td>
<td><code>false</code></td>
<td>Enable Tailscale sync</td>
</tr>
<tr>
<td><code>THRUM_TS_HOSTNAME</code></td>
<td>(auto)</td>
<td>Hostname for the tsnet listener</td>
</tr>
<tr>
<td><code>THRUM_TS_PORT</code></td>
<td><code>9100</code></td>
<td>Port for the sync RPC listener</td>
</tr>
<tr>
<td><code>THRUM_TS_AUTH_KEY</code></td>
<td>(none)</td>
<td>Tailscale auth key for headless setup</td>
</tr>
<tr>
<td><code>THRUM_TS_CONTROL_URL</code></td>
<td>(default)</td>
<td>Custom control server URL</td>
</tr>
<tr>
<td><code>THRUM_TS_STATE_DIR</code></td>
<td><code>.thrum/var/tsnet</code></td>
<td>tsnet state directory</td>
</tr>
</tbody></table>
<h2>CLI Commands</h2>
<h3><code>thrum peer</code></h3>
<p>Manage sync peers:</p>
<pre><code># Start pairing on this machine (displays 4-digit code)
thrum peer add

# Join a remote peer (prompts for pairing code)
thrum peer join &lt;address:port&gt;

# List all paired peers
thrum peer list

# Remove a peer
thrum peer remove &lt;name&gt;

# Detailed sync status for all peers
thrum peer status</code></pre>
<h3><code>thrum status</code></h3>
<p>When Tailscale sync is enabled, <code>thrum status</code> includes sync information:</p>
<pre><code>Tailscale Sync: enabled
  Peers: 2 connected
  Last sync: 30s ago
  Hostname: my-laptop</code></pre>
<h2>Security Model</h2>
<p>Tailscale sync uses a simple three-layer security model:</p>
<h3>1. Tailscale Encryption (Network Layer)</h3>
<p>All traffic between daemons flows over Tailscale&#39;s WireGuard tunnels. This
provides end-to-end encryption and identity verification at the network level.
No data travels over the public internet unencrypted.</p>
<h3>2. Pairing Code (Trust Establishment)</h3>
<p>A human-mediated 4-digit code establishes initial trust between two machines.
The pairing code must be shared out-of-band (verbally, chat, etc.), ensuring
both sides consent to the peering relationship.</p>
<ul>
<li>4-digit random code (10,000 possibilities)</li>
<li>3 attempts allowed before the session is locked</li>
<li>5-minute timeout on pairing sessions</li>
</ul>
<h3>3. Token Authentication (Ongoing Auth)</h3>
<p>After pairing, each request includes a 32-byte hex token. The receiving daemon
validates the token against its peer registry before processing any sync
request. The <code>pair.request</code> method is the only RPC exempt from token
authentication (it&#39;s how new peers establish their tokens).</p>
<ul>
<li>Token validation is centralized in the sync server</li>
<li>Invalid or missing tokens are rejected immediately</li>
<li>Peer&#39;s <code>last_sync</code> is updated on each successful authenticated request</li>
</ul>
<h2>Peer Management</h2>
<h3>Peer Registry</h3>
<p>The peer registry is stored as JSON at <code>.thrum/var/peers.json</code> and persists
across daemon restarts. It tracks:</p>
<ul>
<li>Daemon ID and name</li>
<li>Network address (Tailscale IP + port)</li>
<li>Auth token</li>
<li>Paired-at timestamp and last sync time</li>
</ul>
<h2>Monitoring</h2>
<h3>Health Endpoint</h3>
<p>The daemon&#39;s <code>health</code> RPC method includes Tailscale sync status when enabled:</p>
<pre><code>{
  &quot;tailscale_sync&quot;: {
    &quot;enabled&quot;: true,
    &quot;hostname&quot;: &quot;my-laptop&quot;,
    &quot;peer_count&quot;: 2,
    &quot;peers&quot;: [
      {
        &quot;daemon_id&quot;: &quot;d_abc123&quot;,
        &quot;name&quot;: &quot;office-server&quot;,
        &quot;last_sync&quot;: &quot;30s ago&quot;
      }
    ]
  }
}</code></pre>
<h3>Logs</h3>
<p>Tailscale sync logs are prefixed for easy filtering:</p>
<pre><code>[pairing] Session started, code=7392, timeout=5m0s
[pairing] Paired with office-server (d_abc123) at 100.64.2.10:9100
sync.notify: synced from d_abc123 — applied=5 skipped=0
periodic_sync: starting with interval=5m0s, recent_threshold=2m0s</code></pre>
<h2>Troubleshooting</h2>
<h3>Cannot reach peer</h3>
<ol>
<li>Verify both machines are on the same Tailscale network</li>
<li>Check that both daemons are running (<code>thrum daemon start</code>)</li>
<li>Verify the address format is <code>hostname:port</code> (default port: 9100)</li>
<li>Test connectivity: <code>tailscale ping &lt;hostname&gt;</code></li>
</ol>
<h3>Pairing code rejected</h3>
<ul>
<li>Ensure you&#39;re entering the code displayed on the other machine</li>
<li>Codes expire after 5 minutes -- run <code>thrum peer add</code> again if expired</li>
<li>After 3 failed attempts, the session locks -- restart with <code>thrum peer add</code></li>
</ul>
<h3>Sync not working after pairing</h3>
<ol>
<li>Check <code>thrum peer status</code> for connection details</li>
<li>Verify both daemons have Tailscale enabled (<code>THRUM_TS_ENABLED=true</code>)</li>
<li>Check daemon logs for sync errors</li>
</ol>
<h2>Best Practices</h2>
<h3>Network Setup</h3>
<ul>
<li><strong>Use auth keys</strong> (<code>THRUM_TS_AUTH_KEY</code>) for headless CI/CD runners</li>
<li><strong>Keep the default port</strong> (9100) unless you have a conflict</li>
<li><strong>Use Tailscale ACLs</strong> to restrict which machines can communicate</li>
</ul>
<h3>Performance</h3>
<ul>
<li><strong>Push notifications</strong> handle most sync latency -- events typically propagate
within seconds</li>
<li><strong>Periodic sync</strong> (5 min) acts as a safety net, not the primary mechanism</li>
<li><strong>Batch size</strong> of 1000 events per pull keeps memory bounded during large syncs</li>
<li><strong>Checkpointing</strong> ensures no redundant transfers after restarts</li>
</ul>
<h2>See Also</h2>
<ul>
<li><a href="tailscale-security.html">Tailscale Security</a> -- Security model documentation</li>
<li><a href="multi-agent.html">Multi-Agent Support</a> -- Groups, runtime presets, and team
coordination</li>
<li><a href="agent-coordination.html">Agent Coordination</a> -- Workflow patterns and Beads
integration</li>
<li><a href="sync.html">Sync Protocol</a> -- Git-based synchronization details</li>
<li><a href="cli.html">CLI Reference</a> -- Complete command documentation</li>
</ul>
<pre><code></code></pre>

</main>
<script>if(location.search.indexOf('nospa')===-1){location.replace('../docs.html#tailscale-sync.html')}</script>
</body>
</html>