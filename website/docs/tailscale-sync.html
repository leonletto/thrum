<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tailscale Sync — Thrum</title>
  <meta name="description" content="Direct machine-to-machine sync via Tailscale — setup, architecture, pairing, and CLI commands">
  <!-- Open Graph -->
  <meta property="og:type" content="article">
  <meta property="og:title" content="Tailscale Sync — Thrum">
  <meta property="og:description" content="Direct machine-to-machine sync via Tailscale — setup, architecture, pairing, and CLI commands">
  <meta property="og:url" content="https://leonletto.github.io/thrum/docs/tailscale-sync.html">
  <meta property="og:site_name" content="Thrum">
  <meta property="og:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Tailscale Sync — Thrum">
  <meta name="twitter:description" content="Direct machine-to-machine sync via Tailscale — setup, architecture, pairing, and CLI commands">
  <meta name="twitter:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <!-- Canonical: SPA is the primary URL -->
  <link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#tailscale-sync.html">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x26A1;</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/theme.css">
  <link rel="stylesheet" href="../css/docs.css">
  <script>
    (function(){var t=localStorage.getItem('thrum-theme');if(t){document.documentElement.setAttribute('data-theme',t)}else if(window.matchMedia&&window.matchMedia('(prefers-color-scheme:light)').matches){document.documentElement.setAttribute('data-theme','light')}else{document.documentElement.setAttribute('data-theme','dark')}})();
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <nav class="header-nav">
        <a href="../index.html" class="logo">
          <span class="logo-glyph">&gt;_</span>
          <span class="logo-text">thrum</span>
        </a>
        <div class="nav-links">
          <a href="../index.html" class="nav-link">Home</a>
          <a href="../docs.html" class="nav-link nav-link-active">Docs</a>
          <a href="../about.html" class="nav-link">About</a>
          <a href="https://github.com/leonletto/thrum" class="nav-link nav-link-external" target="_blank" rel="noopener">GitHub</a>
        </div>
      </nav>
    </div>
  </header>
  <main class="docs-content" style="max-width:48rem;margin:2rem auto;padding:0 1.5rem">
    <div class="docs-content-inner">
<h2>Tailscale Sync</h2>
<blockquote>
<p>See also: <a href="tailscale-security.html">Tailscale Security</a> for the security model,<br><a href="multi-agent.html">Multi-Agent Support</a> for team coordination patterns,<br><a href="sync.html">Sync Protocol</a> for Git-based synchronization.</p>
</blockquote>
<h2>Overview</h2>
<p>Thrum&#39;s Tailscale sync enables real-time event synchronization between daemon<br>instances running on different machines connected via a<br><a href="https://tailscale.com">Tailscale</a> network. Agents on separate laptops, VMs, or<br>CI runners can coordinate as if they were on the same machine -- messages, agent<br>events, and session updates propagate automatically.</p>
<p><strong>Key capabilities:</strong></p>
<ul>
<li><strong>Cross-machine sync</strong> -- Events flow between daemons over Tailscale&#39;s<br>encrypted WireGuard tunnels</li>
<li><strong>Push + pull</strong> -- Immediate push notifications on new events, with periodic<br>pull as a fallback</li>
<li><strong>Human-mediated pairing</strong> -- Simple 4-digit code to pair two machines (no<br>auto-discovery, no complex key management)</li>
<li><strong>Token authentication</strong> -- Each peer pair shares a unique 32-byte token for<br>ongoing auth</li>
<li><strong>Zero config networking</strong> -- No port forwarding, no firewall rules. Tailscale<br>handles connectivity</li>
</ul>
<h2>Prerequisites</h2>
<ol>
<li><strong>Tailscale installed</strong> on all machines running Thrum daemons</li>
<li><strong>Thrum v0.4.0+</strong> installed on all machines (Tailscale support added in<br>v0.4.0)</li>
</ol>
<h2>Getting Started</h2>
<h3>1. Enable Tailscale Sync</h3>
<p>Set the environment variable to enable Tailscale integration:</p>
<pre><code class="language-bash hljs"><span class="hljs-built_in">export</span> THRUM_TS_ENABLED=<span class="hljs-literal">true</span>
```text

<span class="hljs-comment">### 2. Start the Daemon</span>

```bash
thrum daemon start
```text

When Tailscale <span class="hljs-built_in">sync</span> is enabled, the daemon:

- Starts a tsnet listener on port 9100 (configurable)
- Registers <span class="hljs-built_in">sync</span> RPC handlers (`sync.pull`, `sync.notify`, `sync.peer_info`,
  `pair.request`)
- Waits <span class="hljs-keyword">for</span> peer pairing via CLI

<span class="hljs-comment">### 3. Pair Two Machines</span>

Pairing requires action on both machines simultaneously:

**On Machine A** (the one you want to share with):

```bash
thrum peer add
<span class="hljs-comment"># Output: Waiting for connection... Pairing code: 7392</span>
```text

**On Machine B** (the one joining):

```bash
thrum peer <span class="hljs-built_in">join</span> my-laptop:9100
<span class="hljs-comment"># Prompts: Enter pairing code:</span>
<span class="hljs-comment"># You type: 7392</span>
<span class="hljs-comment"># Output: Paired with &quot;my-laptop&quot;. Syncing started.</span>
```text

Machine A will also show success:

```text
Paired with <span class="hljs-string">&quot;office-server&quot;</span> (100.64.2.10:9100). Syncing started.
```text

Both machines now <span class="hljs-built_in">sync</span> events automatically.

<span class="hljs-comment">### 4. Verify Sync</span>

```bash
<span class="hljs-comment"># List paired peers</span>
thrum peer list

<span class="hljs-comment"># Detailed sync status</span>
thrum peer status

<span class="hljs-comment"># Check health endpoint</span>
thrum status
```text

<span class="hljs-comment">## Architecture</span>

```text
Machine A                           Machine B
┌─────────────────────┐             ┌─────────────────────┐
│  Thrum Daemon       │             │  Thrum Daemon       │
│  ├─ Event Log       │             │  ├─ Event Log       │
│  ├─ tsnet Listener  │◄──────────►│  ├─ tsnet Listener  │
│  ├─ Sync Manager    │  Tailscale  │  ├─ Sync Manager    │
│  └─ Peer Registry   │  (WireGuard)│  └─ Peer Registry   │
└─────────────────────┘             └─────────────────────┘
         │                                    │
    ┌────┴────┐                          ┌────┴────┐
    │ Agents  │                          │ Agents  │
    │ CLI/MCP │                          │ CLI/MCP │
    └─────────┘                          └─────────┘
```text

<span class="hljs-comment">### Component Overview</span>

| Component           | Purpose                                                                  |
| ------------------- | ------------------------------------------------------------------------ |
| **Event Log**       | Sequenced event store with origin tracking and dedup                     |
| **tsnet Listener**  | Tailscale-native TCP listener (no port forwarding needed)                |
| **Sync Manager**    | Orchestrates pull <span class="hljs-built_in">sync</span>, push notifications, and the scheduler            |
| **Sync Client**     | Pulls events from peers <span class="hljs-keyword">in</span> batches with checkpointing                    |
| **Sync Server**     | Exposes `<span class="hljs-built_in">sync</span>.*` and `pair.*` RPC methods to peers (token-authenticated) |
| **Peer Registry**   | Thread-safe registry of paired peers with JSON persistence               |
| **Pairing Manager** | Handles the 4-digit code pairing flow                                    |
| **Sync Scheduler**  | Periodic fallback <span class="hljs-built_in">sync</span> (5-minute interval, skips recently synced peers)  |

<span class="hljs-comment">## Sync Protocol</span>

<span class="hljs-comment">### Event Log Foundation</span>

Every event written to the daemon includes:

- **`origin_daemon`** -- Unique daemon ID identifying the <span class="hljs-built_in">source</span> machine
- **`sequence`** -- Monotonically increasing per-daemon sequence number

Events are stored <span class="hljs-keyword">in</span> a SQLite `events` table with sequence-based pagination,
enabling efficient delta <span class="hljs-built_in">sync</span>.

<span class="hljs-comment">### Pull Sync</span>

The primary <span class="hljs-built_in">sync</span> mechanism. Daemon A asks Daemon B: <span class="hljs-string">&quot;Give me all events after
sequence N.&quot;</span>

```text
Daemon A                              Daemon B
   │                                      │
   │ sync.pull(after_seq=42, token=...)   │
   ├─────────────────────────────────────►│
   │                                      │
   │  {events: [...], next_seq: 1042,     │
   │   more_available: <span class="hljs-literal">true</span>}              │
   │◄─────────────────────────────────────┤
   │                                      │
   │ sync.pull(after_seq=1042, token=...) │
   ├─────────────────────────────────────►│
   │                                      │
   │  {events: [...], next_seq: 1500,     │
   │   more_available: <span class="hljs-literal">false</span>}             │
   │◄─────────────────────────────────────┤
```text

Batched pull with the `<span class="hljs-built_in">limit</span>+1` trick to determine `more_available`. Checkpoints
are persisted per-peer so <span class="hljs-built_in">sync</span> resumes from <span class="hljs-built_in">where</span> it left off. All requests
include the peer<span class="hljs-string">&#x27;s auth token.

### Push Notifications

When a daemon writes a new event, it broadcasts a `sync.notify` to all known
peers:

```text
Daemon A writes event
   │
   ├──► sync.notify(daemon_id, latest_seq, token) ──► Daemon B
   ├──► sync.notify(daemon_id, latest_seq, token) ──► Daemon C
   │
   Daemons B and C pull new events from A
```text

Push notifications are fire-and-forget -- failures are logged but do not block
the writer.

### Periodic Sync Scheduler

A fallback mechanism that runs every 5 minutes. It pulls from all known peers
that were not synced recently (within the last 2 minutes). This ensures
convergence even if push notifications are lost.

### Deduplication

Events are deduplicated by `event_id` (ULID-based, globally unique). The
`HasEvent()` function provides O(1) dedup via the SQLite primary key index.
Duplicate events from overlapping syncs are silently skipped.

## Pairing Flow

Pairing establishes mutual trust between two machines with a human in the loop.

```text
Machine A (thrum peer add)           Machine B (thrum peer join)
   │                                      │
   │  1. Generate 4-digit code + token    │
   │  2. Display code to user             │
   │                                      │
   │        (human shares code)           │
   │                                      │
   │  pair.request(code, id, name, addr)  │
   │◄─────────────────────────────────────┤ 3. User enters code
   │                                      │
   │  4. Verify code                      │
   │  5. Store peer B + token             │
   │                                      │
   │  {status: paired, token, id, name}   │
   ├─────────────────────────────────────►│ 6. Store peer A + token
   │                                      │
   │  Both peers now authenticate with    │
   │  the shared token on every request   │
```text

- The pairing code is a random 4-digit number (3 attempts allowed)
- The token is a random 32-byte hex string
- Pairing sessions expire after 5 minutes
- Both peers store each other&#x27;</span>s info <span class="hljs-keyword">in</span> `peers.json`

<span class="hljs-comment">## Configuration</span>

<span class="hljs-comment">### Environment Variables</span>

| Variable               | Default            | Description                           |
| ---------------------- | ------------------ | ------------------------------------- |
| `THRUM_TS_ENABLED`     | `<span class="hljs-literal">false</span>`            | Enable Tailscale <span class="hljs-built_in">sync</span>                 |
| `THRUM_TS_HOSTNAME`    | (auto)             | Hostname <span class="hljs-keyword">for</span> the tsnet listener       |
| `THRUM_TS_PORT`        | `9100`             | Port <span class="hljs-keyword">for</span> the <span class="hljs-built_in">sync</span> RPC listener        |
| `THRUM_TS_AUTH_KEY`    | (none)             | Tailscale auth key <span class="hljs-keyword">for</span> headless setup |
| `THRUM_TS_CONTROL_URL` | (default)          | Custom control server URL             |
| `THRUM_TS_STATE_DIR`   | `.thrum/var/tsnet` | tsnet state directory                 |

<span class="hljs-comment">## CLI Commands</span>

<span class="hljs-comment">### `thrum peer`</span>

Manage <span class="hljs-built_in">sync</span> peers:

```bash
<span class="hljs-comment"># Start pairing on this machine (displays 4-digit code)</span>
thrum peer add

<span class="hljs-comment"># Join a remote peer (prompts for pairing code)</span>
thrum peer <span class="hljs-built_in">join</span> &lt;address:port&gt;

<span class="hljs-comment"># List all paired peers</span>
thrum peer list

<span class="hljs-comment"># Remove a peer</span>
thrum peer remove &lt;name&gt;

<span class="hljs-comment"># Detailed sync status for all peers</span>
thrum peer status
```text

<span class="hljs-comment">### `thrum status`</span>

When Tailscale <span class="hljs-built_in">sync</span> is enabled, `thrum status` includes <span class="hljs-built_in">sync</span> information:

```text
Tailscale Sync: enabled
  Peers: 2 connected
  Last <span class="hljs-built_in">sync</span>: 30s ago
  Hostname: my-laptop
```go

<span class="hljs-comment">## Security Model</span>

Tailscale <span class="hljs-built_in">sync</span> uses a simple three-layer security model:

<span class="hljs-comment">### 1. Tailscale Encryption (Network Layer)</span>

All traffic between daemons flows over Tailscale<span class="hljs-string">&#x27;s WireGuard tunnels. This
provides end-to-end encryption and identity verification at the network level.
No data travels over the public internet unencrypted.

### 2. Pairing Code (Trust Establishment)

A human-mediated 4-digit code establishes initial trust between two machines.
The pairing code must be shared out-of-band (verbally, chat, etc.), ensuring
both sides consent to the peering relationship.

- 4-digit random code (10,000 possibilities)
- 3 attempts allowed before the session is locked
- 5-minute timeout on pairing sessions

### 3. Token Authentication (Ongoing Auth)

After pairing, each request includes a 32-byte hex token. The receiving daemon
validates the token against its peer registry before processing any sync
request. The `pair.request` method is the only RPC exempt from token
authentication (it&#x27;</span>s how new peers establish their tokens).

- Token validation is centralized <span class="hljs-keyword">in</span> the <span class="hljs-built_in">sync</span> server
- Invalid or missing tokens are rejected immediately
- Peer<span class="hljs-string">&#x27;s `last_sync` is updated on each successful authenticated request

## Peer Management

### Peer Registry

The peer registry is stored as JSON at `.thrum/var/peers.json` and persists
across daemon restarts. It tracks:

- Daemon ID and name
- Network address (Tailscale IP + port)
- Auth token
- Paired-at timestamp and last sync time

## Monitoring

### Health Endpoint

The daemon&#x27;</span>s `health` RPC method includes Tailscale <span class="hljs-built_in">sync</span> status when enabled:

```json
{
  <span class="hljs-string">&quot;tailscale_sync&quot;</span>: {
    <span class="hljs-string">&quot;enabled&quot;</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">&quot;hostname&quot;</span>: <span class="hljs-string">&quot;my-laptop&quot;</span>,
    <span class="hljs-string">&quot;peer_count&quot;</span>: 2,
    <span class="hljs-string">&quot;peers&quot;</span>: [
      {
        <span class="hljs-string">&quot;daemon_id&quot;</span>: <span class="hljs-string">&quot;d_abc123&quot;</span>,
        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;office-server&quot;</span>,
        <span class="hljs-string">&quot;last_sync&quot;</span>: <span class="hljs-string">&quot;30s ago&quot;</span>
      }
    ]
  }
}
```text

<span class="hljs-comment">### Logs</span>

Tailscale <span class="hljs-built_in">sync</span> logs are prefixed <span class="hljs-keyword">for</span> easy filtering:

```text
[pairing] Session started, code=7392, <span class="hljs-built_in">timeout</span>=5m0s
[pairing] Paired with office-server (d_abc123) at 100.64.2.10:9100
sync.notify: synced from d_abc123 — applied=5 skipped=0
periodic_sync: starting with interval=5m0s, recent_threshold=2m0s
```text

<span class="hljs-comment">## Troubleshooting</span>

<span class="hljs-comment">### Cannot reach peer</span>

1. Verify both machines are on the same Tailscale network
2. Check that both daemons are running (`thrum daemon start`)
3. Verify the address format is `hostname:port` (default port: 9100)
4. Test connectivity: `tailscale ping &lt;hostname&gt;`

<span class="hljs-comment">### Pairing code rejected</span>

- Ensure you<span class="hljs-string">&#x27;re entering the code displayed on the other machine
- Codes expire after 5 minutes -- run `thrum peer add` again if expired
- After 3 failed attempts, the session locks -- restart with `thrum peer add`

### Sync not working after pairing

1. Check `thrum peer status` for connection details
2. Verify both daemons have Tailscale enabled (`THRUM_TS_ENABLED=true`)
3. Check daemon logs for sync errors

## Best Practices

### Network Setup

- **Use auth keys** (`THRUM_TS_AUTH_KEY`) for headless CI/CD runners
- **Keep the default port** (9100) unless you have a conflict
- **Use Tailscale ACLs** to restrict which machines can communicate

### Performance

- **Push notifications** handle most sync latency -- events typically propagate
  within seconds
- **Periodic sync** (5 min) acts as a safety net, not the primary mechanism
- **Batch size** of 1000 events per pull keeps memory bounded during large syncs
- **Checkpointing** ensures no redundant transfers after restarts

## See Also

- [Tailscale Security](tailscale-security.md) -- Security model documentation
- [Multi-Agent Support](multi-agent.md) -- Groups, runtime presets, and team
  coordination
- [Agent Coordination](agent-coordination.md) -- Workflow patterns and Beads
  integration
- [Sync Protocol](sync.md) -- Git-based synchronization details
- [CLI Reference](cli.md) -- Complete command documentation</span></code></pre>

    </div>
    <p style="margin-top:2rem"><a href="../docs.html#tailscale-sync.html">&larr; View in documentation</a></p>
  </main>
  <script>
    // Redirect browsers to the SPA for full navigation experience.
    // Crawlers (which don't execute JS) will index the static content above.
    if (window.location.search.indexOf('nospa') === -1) {
      window.location.replace('../docs.html#tailscale-sync.html');
    }
  </script>
</body>
</html>