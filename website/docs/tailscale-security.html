<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Tailscale Sync Security — Thrum</title>
<meta name="description" content="Security model for Thrum's Tailscale peer sync — pairing, encryption, access control, and threat mitigations">
<link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#tailscale-security.html">
<style>
body{font-family:system-ui,sans-serif;max-width:48rem;margin:2rem auto;padding:0 1.5rem;line-height:1.6;color:#222}
pre{background:#f5f5f5;padding:1rem;overflow-x:auto;border-radius:4px}
code{font-family:ui-monospace,monospace;font-size:0.9em}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #ddd;padding:0.4rem 0.6rem;text-align:left}
th{background:#f5f5f5}
nav{margin-bottom:1.5rem;padding-bottom:1rem;border-bottom:1px solid #ddd;line-height:1.8}
h2{margin-top:2rem}
a{color:#0366d6}
</style>
</head>
<body>
<nav>
<strong><a href="../docs.html">Thrum Docs</a></strong> &rsaquo; Guides &rsaquo; Tailscale Sync Security
<hr>
<strong>Overview</strong>: <a href="philosophy.html">Philosophy</a><br>
<strong>Getting Started</strong>: <a href="quickstart.html">Quickstart Guide</a><br>
  <strong>Recommended Tools</strong>: <a href="guides/recommended-tools.html">Recommended Tools</a> | <a href="guides/beads-setup.html">Beads Setup Guide</a> | <a href="guides/beads-ui-setup.html">Beads UI Setup Guide</a> | <a href="guides/playwright-cli-setup.html">Playwright CLI Setup Guide</a><br>
<strong>Web UI</strong>: <a href="web-ui.html">Web UI</a><br>
<strong>Messaging</strong>: <a href="subscriptions.html">Subscriptions & Notifications</a><br>
<strong>Identity</strong>: <a href="identity.html">Agent Identity & Registration</a><br>
<strong>Guides</strong>: <a href="agent-coordination.html">Agent Coordination</a> | <a href="agent-configs.html">Agent Configurations</a> | <a href="multi-agent.html">Multi-Agent Support</a> | <a href="claude-code-plugin.html">Claude Code Plugin</a> | <a href="configuration.html">Configuration</a> | <a href="workflow-templates.html">Workflow Templates</a> | <a href="beads-and-thrum.html">Beads and Thrum</a> | <a href="codex-plugin.html">Codex Plugin</a> | <a href="claude-agent-integration.html">Claude Code Agent Integration</a> | <a href="messaging.html">Messaging</a> | <a href="tailscale-sync.html">Tailscale Sync</a> | <strong>Tailscale Sync Security</strong> | <a href="overview.html">Technical Overview</a><br>
<strong>API Reference</strong>: <a href="event-streaming.html">Event Streaming</a> | <a href="inbox-query-methods.html">Inbox Query Methods</a> | <a href="api/authentication.html">Authentication</a> | <a href="api/events.html">Event Reference</a> | <a href="rpc-api.html">RPC API</a> | <a href="api/websocket.html">WebSocket API</a><br>
<strong>Daemon</strong>: <a href="daemon.html">Daemon Architecture</a><br>
<strong>Sync</strong>: <a href="sync.html">Sync Protocol</a><br>
<strong>Development</strong>: <a href="development.html">Development Guide</a> | <a href="security-cicd.html">Security & CI/CD</a><br>
<strong>Architecture</strong>: <a href="architecture.html">Architecture</a><br>
<strong>Context</strong>: <a href="context.html">Agent Context Management</a><br>
<strong>Reference</strong>: <a href="cli.html">CLI Reference</a> | <a href="mcp-server.html">MCP Server</a><br>
<strong>uncategorized</strong>: <a href="role-templates.html">Role-Based Preamble Templates</a><br>
</nav>
<main>
<h2>Tailscale Sync Security</h2>
<blockquote>
<p>See also: <a href="tailscale-sync.html">Tailscale Sync</a> for setup, architecture, and CLI
commands.</p>
</blockquote>
<p>Security model for the Tailscale-based sync protocol.</p>
<h2>Overview</h2>
<p>The sync protocol uses three layers of defense:</p>
<ol>
<li><strong>Tailscale Encryption</strong> -- WireGuard tunnels encrypt all traffic</li>
<li><strong>Pairing Code</strong> -- Human-mediated 4-digit code establishes trust</li>
<li><strong>Token Authentication</strong> -- 32-byte token authenticates every request</li>
</ol>
<p>This replaces the previous overengineered security stack (Ed25519 signing,
validation pipeline, WhoIs authorization, rate limiting, quarantine system) with
a simpler model that provides equivalent practical security.</p>
<h2>Layer 1: Tailscale Encryption</h2>
<p>All sync traffic flows over Tailscale&#39;s WireGuard mesh network. This provides:</p>
<ul>
<li><strong>End-to-end encryption</strong> between peers</li>
<li><strong>Identity verification</strong> via Tailscale&#39;s control plane</li>
<li><strong>NAT traversal</strong> with no port forwarding or firewall configuration</li>
<li><strong>Network-level access control</strong> via Tailscale ACLs</li>
</ul>
<p>Tailscale handles the hard parts of secure networking. Thrum doesn&#39;t need to
implement its own transport encryption.</p>
<h3>Recommended ACL Configuration</h3>
<h4>Tailscale ACLs</h4>
<pre><code>{
  &quot;tagOwners&quot;: {
    &quot;tag:thrum-daemon&quot;: [&quot;group:devops&quot;]
  },
  &quot;acls&quot;: [
    {
      &quot;action&quot;: &quot;accept&quot;,
      &quot;src&quot;: [&quot;tag:thrum-daemon&quot;],
      &quot;dst&quot;: [&quot;tag:thrum-daemon:9100&quot;]
    }
  ]
}</code></pre>
<h4>Headscale ACLs</h4>
<pre><code>groups:
  - name: thrum-daemons
    members: [&quot;user1&quot;, &quot;user2&quot;]

acls:
  - action: accept
    src: [&quot;group:thrum-daemons&quot;]
    dst: [&quot;group:thrum-daemons:9100&quot;]</code></pre>
<h2>Layer 2: Pairing Code</h2>
<p>Trust between two machines is established through a human-mediated pairing flow.</p>
<h3>How It Works</h3>
<ol>
<li>Machine A generates a random 4-digit code and displays it to the user</li>
<li>The user communicates the code to Machine B&#39;s operator (verbally, chat, etc.)</li>
<li>Machine B sends the code to Machine A over Tailscale</li>
<li>Machine A verifies the code and establishes the peer relationship</li>
</ol>
<h3>Security Properties</h3>
<ul>
<li><strong>Human-in-the-loop</strong>: A person must deliberately share the code, preventing
automated or accidental pairing</li>
<li><strong>Time-limited</strong>: Pairing sessions expire after 5 minutes</li>
<li><strong>Attempt-limited</strong>: Only 3 attempts per session before lockout</li>
<li><strong>One-time use</strong>: Each code can only be used once</li>
</ul>
<h3>Threat Model</h3>
<p>The pairing code provides protection against:</p>
<ul>
<li><strong>Unauthorized peers</strong> -- Only someone with the code can pair</li>
<li><strong>Replay attacks</strong> -- Codes expire and are single-use</li>
<li><strong>Brute force</strong> -- 3-attempt limit makes guessing impractical within the
5-minute window</li>
</ul>
<p>The code does NOT protect against an attacker who can both observe the code
being shared AND intercept the Tailscale connection. In practice, Tailscale&#39;s
network security makes this extremely unlikely.</p>
<h2>Layer 3: Token Authentication</h2>
<p>After pairing, a 32-byte hex token (256 bits of entropy) is shared between the
two peers. Every sync request includes this token.</p>
<h3>Token Lifecycle</h3>
<ol>
<li><strong>Generation</strong>: A random 32-byte token is generated during pairing</li>
<li><strong>Distribution</strong>: The token is sent to the joining peer in the pairing
response</li>
<li><strong>Storage</strong>: Both peers store the token in their <code>peers.json</code> file</li>
<li><strong>Validation</strong>: Every sync request is validated against the token before
processing</li>
</ol>
<h3>Validation Flow</h3>
<pre><code>Incoming sync request
   │
   ├─ Is method &quot;pair.request&quot;?  ──► Yes: Skip auth (pairing flow)
   │
   ├─ Extract token from params
   │
   ├─ Look up token in peer registry
   │   ├─ Not found  ──► Reject (unauthorized)
   │   └─ Found      ──► Allow + update last_sync
   │
   └─ Dispatch to handler</code></pre>
<h3>Security Properties</h3>
<ul>
<li><strong>256 bits of entropy</strong> -- Computationally infeasible to guess</li>
<li><strong>Per-peer tokens</strong> -- Each peer relationship has its own token</li>
<li><strong>Central validation</strong> -- All RPCs are authenticated in the sync server before
handler dispatch</li>
<li><strong>Exempt only pair.request</strong> -- The pairing RPC is the only unauthenticated
method (protected by the pairing code instead)</li>
</ul>
<h2>Configuration</h2>
<p>No security-specific configuration is needed. The security model is built into
the pairing and sync flow.</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Configuration</th>
</tr>
</thead>
<tbody><tr>
<td>Encryption</td>
<td>Automatic (Tailscale)</td>
</tr>
<tr>
<td>Pairing timeout</td>
<td>5 minutes (hardcoded)</td>
</tr>
<tr>
<td>Pairing attempts</td>
<td>3 per session (hardcoded)</td>
</tr>
<tr>
<td>Token length</td>
<td>32 bytes / 256 bits (hardcoded)</td>
</tr>
<tr>
<td>Network ACLs</td>
<td>Configure in Tailscale admin console</td>
</tr>
</tbody></table>
<h2>Comparison with Previous Model</h2>
<table>
<thead>
<tr>
<th>Previous (Removed)</th>
<th>Current (Simplified)</th>
</tr>
</thead>
<tbody><tr>
<td>Ed25519 event signing</td>
<td>Not needed -- Tailscale provides transport integrity</td>
</tr>
<tr>
<td>3-stage validation pipeline</td>
<td>Not needed -- token auth is sufficient</td>
</tr>
<tr>
<td>WhoIs authorization</td>
<td>Not needed -- pairing code + Tailscale ACLs</td>
</tr>
<tr>
<td>Per-peer rate limiting</td>
<td>Not needed -- Tailscale rate limits at network level</td>
</tr>
<tr>
<td>Quarantine system</td>
<td>Not needed -- invalid tokens are simply rejected</td>
</tr>
<tr>
<td>TOFU key pinning</td>
<td>Replaced by explicit human-mediated pairing</td>
</tr>
<tr>
<td>~1,074 lines of security code</td>
<td>~40 lines of token validation</td>
</tr>
</tbody></table>
<h2>Troubleshooting</h2>
<h3>Peer rejected with &quot;unauthorized&quot;</h3>
<p>The peer&#39;s token doesn&#39;t match. This can happen if:</p>
<ol>
<li>The peer was removed and re-paired (old token is invalid)</li>
<li>The <code>peers.json</code> file was manually edited or corrupted</li>
<li>The peer registry was reset on one side</li>
</ol>
<p><strong>Fix</strong>: Remove the peer on both machines and re-pair:</p>
<pre><code># On both machines:
thrum peer remove &lt;name&gt;

# Then pair again:
# Machine A: thrum peer add
# Machine B: thrum peer join &lt;address&gt;</code></pre>
<h3>Pairing fails with &quot;no active pairing session&quot;</h3>
<p>The pairing session on Machine A expired or was never started.</p>
<p><strong>Fix</strong>: Run <code>thrum peer add</code> on Machine A first, then <code>thrum peer join</code> on
Machine B within 5 minutes.</p>
<h3>Pairing fails with &quot;too many failed attempts&quot;</h3>
<p>Three incorrect codes were entered.</p>
<p><strong>Fix</strong>: Run <code>thrum peer add</code> again on Machine A to start a fresh session with a
new code.</p>
<pre><code></code></pre>

</main>
<script>if(location.search.indexOf('nospa')===-1){location.replace('../docs.html#tailscale-security.html')}</script>
</body>
</html>