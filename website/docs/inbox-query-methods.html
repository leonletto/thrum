<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Inbox Query Methods â€” Thrum</title>
<meta name="description" content="RPC methods for querying messages, agents, and managing read state with filtering and pagination">
<link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#inbox-query-methods.html">
<style>
body{font-family:system-ui,sans-serif;max-width:48rem;margin:2rem auto;padding:0 1.5rem;line-height:1.6;color:#222}
pre{background:#f5f5f5;padding:1rem;overflow-x:auto;border-radius:4px}
code{font-family:ui-monospace,monospace;font-size:0.9em}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #ddd;padding:0.4rem 0.6rem;text-align:left}
th{background:#f5f5f5}
nav{margin-bottom:1.5rem;padding-bottom:1rem;border-bottom:1px solid #ddd;line-height:1.8}
h2{margin-top:2rem}
a{color:#0366d6}
</style>
</head>
<body>
<nav>
<strong><a href="../docs.html">Thrum Docs</a></strong> &rsaquo; API Reference &rsaquo; Inbox Query Methods
<hr>
<strong>Overview</strong>: <a href="philosophy.html">Philosophy</a><br>
<strong>Getting Started</strong>: <a href="quickstart.html">Quickstart Guide</a><br>
  <strong>Recommended Tools</strong>: <a href="guides/recommended-tools.html">Recommended Tools</a> | <a href="guides/beads-setup.html">Beads Setup Guide</a> | <a href="guides/beads-ui-setup.html">Beads UI Setup Guide</a> | <a href="guides/playwright-cli-setup.html">Playwright CLI Setup Guide</a><br>
<strong>Web UI</strong>: <a href="web-ui.html">Web UI</a><br>
<strong>Messaging</strong>: <a href="subscriptions.html">Subscriptions & Notifications</a><br>
<strong>Identity</strong>: <a href="identity.html">Agent Identity & Registration</a><br>
<strong>Guides</strong>: <a href="agent-coordination.html">Agent Coordination</a> | <a href="agent-configs.html">Agent Configurations</a> | <a href="multi-agent.html">Multi-Agent Support</a> | <a href="claude-code-plugin.html">Claude Code Plugin</a> | <a href="configuration.html">Configuration</a> | <a href="workflow-templates.html">Workflow Templates</a> | <a href="beads-and-thrum.html">Beads and Thrum</a> | <a href="codex-plugin.html">Codex Plugin</a> | <a href="claude-agent-integration.html">Claude Code Agent Integration</a> | <a href="messaging.html">Messaging</a> | <a href="tailscale-sync.html">Tailscale Sync</a> | <a href="tailscale-security.html">Tailscale Sync Security</a> | <a href="overview.html">Technical Overview</a><br>
<strong>API Reference</strong>: <a href="event-streaming.html">Event Streaming</a> | <strong>Inbox Query Methods</strong> | <a href="api/authentication.html">Authentication</a> | <a href="api/events.html">Event Reference</a> | <a href="rpc-api.html">RPC API</a> | <a href="api/websocket.html">WebSocket API</a><br>
<strong>Daemon</strong>: <a href="daemon.html">Daemon Architecture</a><br>
<strong>Sync</strong>: <a href="sync.html">Sync Protocol</a><br>
<strong>Development</strong>: <a href="development.html">Development Guide</a> | <a href="security-cicd.html">Security & CI/CD</a><br>
<strong>Architecture</strong>: <a href="architecture.html">Architecture</a><br>
<strong>Context</strong>: <a href="context.html">Agent Context Management</a><br>
<strong>Reference</strong>: <a href="cli.html">CLI Reference</a> | <a href="mcp-server.html">MCP Server</a><br>
<strong>uncategorized</strong>: <a href="role-templates.html">Role-Based Preamble Templates</a><br>
</nav>
<main>
<h2>Inbox Query RPC Methods</h2>
<h2>Overview</h2>
<p>The Thrum daemon provides a complete set of RPC methods for querying the inbox,
listing agents, and managing read state. These methods power both the CLI
(<code>thrum inbox</code>) and the Web UI.</p>
<p>All methods use JSON-RPC 2.0 over Unix socket (<code>.thrum/var/thrum.sock</code>) or
WebSocket (<code>ws://localhost:9999</code>). See <code>docs/rpc-api.md</code> for the full API
reference.</p>
<h2>Query Methods</h2>
<h3>1. agent.list</h3>
<p>Lists all registered agents with optional filtering by role or module.</p>
<p><strong>Request:</strong></p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;agent.list&quot;,
  &quot;params&quot;: {
    &quot;role&quot;: &quot;implementer&quot;,
    &quot;module&quot;: &quot;auth&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<p><strong>Response:</strong></p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;agents&quot;: [
      {
        &quot;agent_id&quot;: &quot;furiosa&quot;,
        &quot;kind&quot;: &quot;agent&quot;,
        &quot;role&quot;: &quot;implementer&quot;,
        &quot;module&quot;: &quot;auth&quot;,
        &quot;display&quot;: &quot;Furiosa&quot;,
        &quot;registered_at&quot;: &quot;2026-02-03T10:00:00Z&quot;,
        &quot;last_seen_at&quot;: &quot;2026-02-03T15:30:00Z&quot;
      }
    ]
  },
  &quot;id&quot;: 1
}</code></pre>
<p>Both <code>role</code> and <code>module</code> filters are optional. Omit both to list all agents.</p>
<h3>2. message.list</h3>
<p>Lists messages with comprehensive filtering, pagination, and sorting. This is
the primary inbox query method.</p>
<p><strong>Request:</strong></p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;message.list&quot;,
  &quot;params&quot;: {
    &quot;author_id&quot;: &quot;furiosa&quot;,
    &quot;scope&quot;: { &quot;type&quot;: &quot;module&quot;, &quot;value&quot;: &quot;auth&quot; },
    &quot;ref&quot;: { &quot;type&quot;: &quot;mention&quot;, &quot;value&quot;: &quot;reviewer&quot; },
    &quot;mentions&quot;: true,
    &quot;unread&quot;: true,
    &quot;mention_role&quot;: &quot;reviewer&quot;,
    &quot;unread_for_agent&quot;: &quot;furiosa&quot;,
    &quot;page_size&quot;: 50,
    &quot;page&quot;: 1,
    &quot;sort_by&quot;: &quot;created_at&quot;,
    &quot;sort_order&quot;: &quot;desc&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<p><strong>Filters (all optional):</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>author_id</code></td>
<td>string</td>
<td>Filter by author agent ID</td>
</tr>
<tr>
<td><code>scope</code></td>
<td>object</td>
<td>Filter by scope (<code>{&quot;type&quot;: &quot;...&quot;, &quot;value&quot;: &quot;...&quot;}</code>)</td>
</tr>
<tr>
<td><code>ref</code></td>
<td>object</td>
<td>Filter by ref (<code>{&quot;type&quot;: &quot;...&quot;, &quot;value&quot;: &quot;...&quot;}</code>)</td>
</tr>
<tr>
<td><code>mentions</code></td>
<td>boolean</td>
<td>Only messages mentioning current agent (resolved from local config)</td>
</tr>
<tr>
<td><code>unread</code></td>
<td>boolean</td>
<td>Only unread messages (resolved from local config)</td>
</tr>
<tr>
<td><code>mention_role</code></td>
<td>string</td>
<td>Explicit mention filter by role (for remote callers like the MCP server)</td>
</tr>
<tr>
<td><code>unread_for_agent</code></td>
<td>string</td>
<td>Explicit unread filter by agent ID (for remote callers like the MCP server)</td>
</tr>
</tbody></table>
<p><strong>Pagination and sorting (all optional):</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>page_size</code></td>
<td>integer</td>
<td>10</td>
<td>Items per page (max: 100)</td>
</tr>
<tr>
<td><code>page</code></td>
<td>integer</td>
<td>1</td>
<td>Page number</td>
</tr>
<tr>
<td><code>sort_by</code></td>
<td>string</td>
<td><code>&quot;created_at&quot;</code></td>
<td>Sort field: <code>&quot;created_at&quot;</code> or <code>&quot;updated_at&quot;</code></td>
</tr>
<tr>
<td><code>sort_order</code></td>
<td>string</td>
<td><code>&quot;desc&quot;</code></td>
<td>Sort direction: <code>&quot;asc&quot;</code> or <code>&quot;desc&quot;</code></td>
</tr>
</tbody></table>
<p><strong>Response:</strong></p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;messages&quot;: [
      {
        &quot;message_id&quot;: &quot;msg_01HXE...&quot;,
        &quot;agent_id&quot;: &quot;furiosa&quot;,
        &quot;body&quot;: {
          &quot;format&quot;: &quot;markdown&quot;,
          &quot;content&quot;: &quot;Auth module complete, all tests passing&quot;,
          &quot;structured&quot;: &quot;&quot;
        },
        &quot;created_at&quot;: &quot;2026-02-03T15:41:12Z&quot;,
        &quot;deleted&quot;: false,
        &quot;is_read&quot;: true
      }
    ],
    &quot;total&quot;: 150,
    &quot;unread&quot;: 5,
    &quot;page&quot;: 1,
    &quot;page_size&quot;: 50,
    &quot;total_pages&quot;: 3
  },
  &quot;id&quot;: 1
}</code></pre>
<p><strong>Filter resolution:</strong> The <code>mentions</code> and <code>unread</code> boolean filters are resolved
using the local agent config (via <code>THRUM_ROLE</code> / identity file). The
<code>mention_role</code> and <code>unread_for_agent</code> string filters are explicit overrides for
remote callers (like the MCP server) that cannot access local config.</p>
<p><strong>Subscription cleanup:</strong> As of v0.4.3, subscriptions are automatically deleted
when a session ends.</p>
<h3>3. message.get</h3>
<p>Retrieves a single message by ID with full details including scopes, refs,
author info, edit/delete metadata.</p>
<p><strong>Request:</strong></p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;message.get&quot;,
  &quot;params&quot;: {
    &quot;message_id&quot;: &quot;msg_01HXE...&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<p><strong>Response:</strong></p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;message&quot;: {
      &quot;message_id&quot;: &quot;msg_01HXE...&quot;,
      &quot;author&quot;: {
        &quot;agent_id&quot;: &quot;furiosa&quot;,
        &quot;session_id&quot;: &quot;ses_01HXE...&quot;
      },
      &quot;body&quot;: {
        &quot;format&quot;: &quot;markdown&quot;,
        &quot;content&quot;: &quot;Auth module complete, all tests passing&quot;,
        &quot;structured&quot;: &quot;&quot;
      },
      &quot;scopes&quot;: [{ &quot;type&quot;: &quot;module&quot;, &quot;value&quot;: &quot;auth&quot; }],
      &quot;refs&quot;: [{ &quot;type&quot;: &quot;mention&quot;, &quot;value&quot;: &quot;reviewer&quot; }],
      &quot;metadata&quot;: {
        &quot;deleted_at&quot;: &quot;&quot;,
        &quot;delete_reason&quot;: &quot;&quot;
      },
      &quot;created_at&quot;: &quot;2026-02-03T15:41:12Z&quot;,
      &quot;updated_at&quot;: &quot;&quot;,
      &quot;deleted&quot;: false
    }
  },
  &quot;id&quot;: 1
}</code></pre>
<h3>4. message.markRead</h3>
<p>Batch mark messages as read for the current agent and session.</p>
<p><strong>Request:</strong></p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;message.markRead&quot;,
  &quot;params&quot;: {
    &quot;message_ids&quot;: [&quot;msg_01HXE...&quot;, &quot;msg_01HXF...&quot;, &quot;msg_01HXG...&quot;]
  },
  &quot;id&quot;: 1
}</code></pre>
<p><strong>Response:</strong></p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;marked_count&quot;: 3,
    &quot;also_read_by&quot;: {
      &quot;msg_01HXE...&quot;: [&quot;other_agent&quot;]
    }
  },
  &quot;id&quot;: 1
}</code></pre>
<p>The <code>also_read_by</code> field returns collaboration info: other agents who have also
read the same messages. This is omitted if empty.</p>
<h2>Read/Unread Tracking</h2>
<p>Read state is fully implemented with the following infrastructure:</p>
<h3>Storage</h3>
<pre><code>CREATE TABLE message_reads (
  message_id TEXT NOT NULL,
  session_id TEXT NOT NULL,
  agent_id TEXT NOT NULL,
  read_at TEXT NOT NULL,
  PRIMARY KEY (message_id, session_id),
  FOREIGN KEY (message_id) REFERENCES messages(message_id) ON DELETE CASCADE
);</code></pre>
<p>Read state is tracked per message per session and per agent. A message is
considered read if any session or agent matching the current identity has a read
record.</p>
<h3>Query Integration</h3>
<ul>
<li><code>message.list</code> responses include <code>is_read</code> on each message and <code>unread</code> count
in the response envelope</li>
<li><code>message.list</code> supports <code>unread</code> (boolean, config-resolved) and
<code>unread_for_agent</code> (string, explicit) filters</li>
</ul>
<h3>Auto Mark-as-Read</h3>
<p>Several CLI commands mark messages as read automatically:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Behavior</th>
</tr>
</thead>
<tbody><tr>
<td><code>thrum inbox</code></td>
<td>Marks all displayed messages as read (skipped with <code>--unread</code>)</td>
</tr>
<tr>
<td><code>thrum reply MSG_ID ...</code></td>
<td>Marks the replied-to message as read</td>
</tr>
<tr>
<td><code>thrum message get MSG_ID</code></td>
<td>Marks the retrieved message as read</td>
</tr>
</tbody></table>
<h2>Features Summary</h2>
<ul>
<li><strong>Agent listing</strong> -- List all agents with role/module filters and metadata</li>
<li><strong>Message listing</strong> -- Filter by author, scope, ref, mentions, unread status</li>
<li><strong>Pagination</strong> -- Configurable page size (max 100), page numbers, total counts</li>
<li><strong>Sorting</strong> -- By <code>created_at</code> or <code>updated_at</code>, ascending or descending</li>
<li><strong>Read tracking</strong> -- Per-session and per-agent read state, auto mark-as-read</li>
<li><strong>Mention filtering</strong> -- Filter by mention role (config-resolved or explicit)</li>
<li><strong>Transport context</strong> -- Both Unix socket and WebSocket supported</li>
</ul>
<h2>Usage Examples</h2>
<h3>Loading inbox for a CLI agent</h3>
<pre><code># List unread messages mentioning the current agent&#39;s role
thrum inbox --mentions --unread</code></pre>
<h3>Loading inbox from the UI (WebSocket)</h3>
<pre><code>// Get list of agents
const agents = await rpc(&quot;agent.list&quot;, {});

// Get unread messages mentioning a specific role
const inbox = await rpc(&quot;message.list&quot;, {
  mention_role: &quot;reviewer&quot;,
  unread_for_agent: &quot;furiosa&quot;,
  page_size: 50,
  sort_by: &quot;created_at&quot;,
  sort_order: &quot;desc&quot;,
});

// Mark messages as read
await rpc(&quot;message.markRead&quot;, {
  message_ids: inbox.messages.map((m) =&gt; m.message_id),
});</code></pre>
<h3>Loading inbox from the MCP server</h3>
<p>The MCP server uses the explicit <code>mention_role</code> and <code>unread_for_agent</code> filters
because it cannot access the local agent config directly:</p>
<pre><code>// MCP check_messages tool uses:
const messages = await rpc(&quot;message.list&quot;, {
  mention_role: agentRole,
  unread_for_agent: agentID,
  sort_by: &quot;created_at&quot;,
  sort_order: &quot;desc&quot;,
});</code></pre>
<h2>Testing</h2>
<p>All methods have comprehensive test coverage in:</p>
<ul>
<li><code>internal/daemon/rpc/agent_test.go</code> -- Agent listing, filtering</li>
<li><code>internal/daemon/rpc/message_test.go</code> -- Message CRUD, pagination, sorting</li>
<li><code>internal/daemon/rpc/message_filter_test.go</code> -- Mention and unread filtering</li>
<li><code>internal/daemon/rpc/session_test.go</code> -- Session management</li>
<li><code>tests/e2e/messaging.spec.ts</code> -- End-to-end messaging scenarios</li>
</ul>
<h2>See Also</h2>
<ul>
<li>Full RPC API Reference: <code>docs/rpc-api.md</code></li>
<li>Messaging System (CLI): <code>docs/messaging.md</code></li>
<li>Daemon Architecture: <code>docs/daemon.md</code></li>
</ul>

</main>
<script>if(location.search.indexOf('nospa')===-1){location.replace('../docs.html#inbox-query-methods.html')}</script>
</body>
</html>