<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Subscriptions & Notifications â€” Thrum</title>
<meta name="description" content="Real-time push notification system with scope, mention, and all-message filters - subscription lifecycle and dispatch">
<link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#subscriptions.html">
<style>
body{font-family:system-ui,sans-serif;max-width:48rem;margin:2rem auto;padding:0 1.5rem;line-height:1.6;color:#222}
pre{background:#f5f5f5;padding:1rem;overflow-x:auto;border-radius:4px}
code{font-family:ui-monospace,monospace;font-size:0.9em}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #ddd;padding:0.4rem 0.6rem;text-align:left}
th{background:#f5f5f5}
nav{margin-bottom:1.5rem;padding-bottom:1rem;border-bottom:1px solid #ddd;line-height:1.8}
h2{margin-top:2rem}
a{color:#0366d6}
</style>
</head>
<body>
<nav>
<strong><a href="../docs.html">Thrum Docs</a></strong> &rsaquo; Messaging &rsaquo; Subscriptions & Notifications
<hr>
<strong>Overview</strong>: <a href="philosophy.html">Philosophy</a><br>
<strong>Getting Started</strong>: <a href="quickstart.html">Quickstart Guide</a><br>
  <strong>Recommended Tools</strong>: <a href="guides/recommended-tools.html">Recommended Tools</a> | <a href="guides/beads-setup.html">Beads Setup Guide</a> | <a href="guides/beads-ui-setup.html">Beads UI Setup Guide</a> | <a href="guides/playwright-cli-setup.html">Playwright CLI Setup Guide</a><br>
<strong>Web UI</strong>: <a href="web-ui.html">Web UI</a><br>
<strong>Messaging</strong>: <strong>Subscriptions & Notifications</strong><br>
<strong>Identity</strong>: <a href="identity.html">Agent Identity & Registration</a><br>
<strong>Guides</strong>: <a href="agent-coordination.html">Agent Coordination</a> | <a href="agent-configs.html">Agent Configurations</a> | <a href="multi-agent.html">Multi-Agent Support</a> | <a href="claude-code-plugin.html">Claude Code Plugin</a> | <a href="configuration.html">Configuration</a> | <a href="workflow-templates.html">Workflow Templates</a> | <a href="beads-and-thrum.html">Beads and Thrum</a> | <a href="codex-plugin.html">Codex Plugin</a> | <a href="claude-agent-integration.html">Claude Code Agent Integration</a> | <a href="messaging.html">Messaging</a> | <a href="tailscale-sync.html">Tailscale Sync</a> | <a href="tailscale-security.html">Tailscale Sync Security</a> | <a href="overview.html">Technical Overview</a><br>
<strong>API Reference</strong>: <a href="event-streaming.html">Event Streaming</a> | <a href="inbox-query-methods.html">Inbox Query Methods</a> | <a href="api/authentication.html">Authentication</a> | <a href="api/events.html">Event Reference</a> | <a href="rpc-api.html">RPC API</a> | <a href="api/websocket.html">WebSocket API</a><br>
<strong>Daemon</strong>: <a href="daemon.html">Daemon Architecture</a><br>
<strong>Sync</strong>: <a href="sync.html">Sync Protocol</a><br>
<strong>Development</strong>: <a href="development.html">Development Guide</a> | <a href="security-cicd.html">Security & CI/CD</a><br>
<strong>Architecture</strong>: <a href="architecture.html">Architecture</a><br>
<strong>Context</strong>: <a href="context.html">Agent Context Management</a><br>
<strong>Reference</strong>: <a href="cli.html">CLI Reference</a> | <a href="mcp-server.html">MCP Server</a><br>
<strong>uncategorized</strong>: <a href="role-templates.html">Role-Based Preamble Templates</a><br>
</nav>
<main>
<h2>Subscriptions &amp; Notifications</h2>
<h2>Quick Reference</h2>
<h3>CLI Commands</h3>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>thrum subscribe</code></td>
<td>Subscribe to notifications (scope, mention, all)</td>
</tr>
<tr>
<td><code>thrum unsubscribe ID</code></td>
<td>Remove a subscription by ID</td>
</tr>
<tr>
<td><code>thrum subscriptions</code></td>
<td>List active subscriptions for current session</td>
</tr>
<tr>
<td><code>thrum wait</code></td>
<td>Block until notification arrives or timeout</td>
</tr>
</tbody></table>
<h2>Overview</h2>
<p>The subscription system allows agents to receive real-time push notifications
when messages match their interests. Agents can subscribe to:</p>
<ul>
<li><strong>Scopes</strong> - Messages with specific scope (e.g., <code>module:auth</code>,
<code>file:main.go</code>)</li>
<li><strong>Mentions</strong> - Messages that @mention a specific role (e.g., <code>@reviewer</code>) or
agent name (e.g., <code>@furiosa</code>)</li>
<li><strong>All messages</strong> - Wildcard subscription to receive all messages</li>
</ul>
<p>Subscriptions are automatically deleted when a session ends (added in v0.4.3).
Subscription identity resolution now correctly uses the caller&#39;s agent ID for
filtering (caller_agent_id resolution fix in v0.4.3).</p>
<p>When a new message matches a subscription, the daemon:</p>
<ol>
<li>Identifies matching subscriptions via the <strong>dispatcher</strong></li>
<li>Sends <strong>push notifications</strong> to connected clients via the <strong>broadcaster</strong></li>
<li>Stores the message for later retrieval via <code>message.list</code> API</li>
</ol>
<h2>Architecture</h2>
<h3>Components</h3>
<pre><code>+-------------------------------------------------------------+
|                      Message Flow                            |
+-------------------------------------------------------------+

  message.send RPC
       |
       v
  +--------------+
  | Message      |  1. Write to JSONL (sharded per-agent)
  | Handler      |  2. Insert into SQLite
  +---------+----+  3. Extract scopes/refs
            |
            v
  +--------------+
  | Dispatcher   |  1. Query all subscriptions
  |              |  2. Match against message (scope/mention/all)
  +---------+----+  3. Build notifications
            |
            v
  +--------------+
  | Broadcaster  |  1. Try Unix socket clients first
  |              |  2. Fall back to WebSocket clients
  +---------+----+  3. Best-effort delivery
            |
       +----+----+
       |         |
       v         v
  Unix Socket   WebSocket
  Clients       Clients (port 9999)
       |         |
       v         v
    Connected clients receive notification.message</code></pre>
<h3>Database Schema</h3>
<p><strong>subscriptions table:</strong></p>
<pre><code>CREATE TABLE subscriptions (
  id           INTEGER PRIMARY KEY AUTOINCREMENT,
  session_id   TEXT NOT NULL,
  scope_type   TEXT,                    -- NULL for non-scope subscriptions
  scope_value  TEXT,                   -- NULL for non-scope subscriptions
  mention_role TEXT,                  -- NULL for non-mention subscriptions
  created_at   TEXT NOT NULL,
  UNIQUE(session_id, scope_type, scope_value, mention_role)
);

-- Indexes for efficient matching
CREATE INDEX idx_subscriptions_scope ON subscriptions(scope_type, scope_value);
CREATE INDEX idx_subscriptions_mention ON subscriptions(mention_role);
CREATE INDEX idx_subscriptions_session ON subscriptions(session_id);</code></pre>
<p><strong>Note:</strong> The subscriptions table does not have a foreign key constraint on
<code>session_id</code>. Subscription cleanup on session end is handled at the application
level.</p>
<p><strong>Subscription types (mutually exclusive):</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>scope_type</th>
<th>scope_value</th>
<th>mention_role</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Scope</td>
<td><code>&quot;module&quot;</code></td>
<td><code>&quot;auth&quot;</code></td>
<td><code>NULL</code></td>
<td>Matches messages with scope <code>module:auth</code></td>
</tr>
<tr>
<td>Mention</td>
<td><code>NULL</code></td>
<td><code>NULL</code></td>
<td><code>&quot;reviewer&quot;</code></td>
<td>Matches messages with <code>@reviewer</code> mention</td>
</tr>
<tr>
<td>All</td>
<td><code>NULL</code></td>
<td><code>NULL</code></td>
<td><code>NULL</code></td>
<td>Matches all messages (wildcard)</td>
</tr>
</tbody></table>
<h3>Duplicate Prevention</h3>
<p>SQLite&#39;s <code>UNIQUE</code> constraint doesn&#39;t work correctly with NULL values (treats
each NULL as unique). We implement <strong>application-level duplicate checking</strong> in
<code>service.go</code>:</p>
<pre><code>func (s *Service) subscriptionExists(...) (bool, error) {
    // Build query with explicit NULL checks for each combination
    if scopeType != nil &amp;&amp; scopeValue != nil {
        query = &quot;WHERE session_id = ? AND scope_type = ? AND scope_value = ?&quot;
    } else if mentionRole != nil {
        query = &quot;WHERE session_id = ? AND mention_role = ?&quot;
    } else {
        query = &quot;WHERE session_id = ? AND scope_type IS NULL AND ...&quot;
    }
}</code></pre>
<h2>Subscription Lifecycle</h2>
<h3>Creating Subscriptions</h3>
<ol>
<li>Client calls <code>subscribe</code> RPC with subscription criteria</li>
<li>Handler validates:<ul>
<li>Session is active (resolved from agent identity config)</li>
<li>At least one of scope, mention_role, or all specified</li>
<li>No duplicate subscription exists (application-level check)</li>
</ul>
</li>
<li>Insert into <code>subscriptions</code> table</li>
<li>Return subscription ID</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code>// Request
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;subscribe&quot;,
  &quot;params&quot;: {&quot;scope&quot;: {&quot;type&quot;: &quot;module&quot;, &quot;value&quot;: &quot;auth&quot;}},
  &quot;id&quot;: 1
}

// Response
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;subscription_id&quot;: 42,
    &quot;session_id&quot;: &quot;ses_01HXE...&quot;,
    &quot;created_at&quot;: &quot;2026-02-03T10:00:00Z&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<h3>Removing Subscriptions</h3>
<ol>
<li>Client calls <code>unsubscribe</code> RPC with subscription ID</li>
<li>Handler verifies subscription belongs to current session</li>
<li>Delete from <code>subscriptions</code> table</li>
<li>Return <code>{&quot;removed&quot;: true}</code> or <code>{&quot;removed&quot;: false}</code> (idempotent)</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code>// Request
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;unsubscribe&quot;,
  &quot;params&quot;: {&quot;subscription_id&quot;: 42},
  &quot;id&quot;: 2
}

// Response
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {&quot;removed&quot;: true},
  &quot;id&quot;: 2
}</code></pre>
<h3>Listing Subscriptions</h3>
<pre><code>// Request
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;subscriptions.list&quot;,
  &quot;id&quot;: 1
}

// Response
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;subscriptions&quot;: [
      {
        &quot;id&quot;: 42,
        &quot;scope_type&quot;: &quot;module&quot;,
        &quot;scope_value&quot;: &quot;auth&quot;,
        &quot;created_at&quot;: &quot;2026-02-03T10:00:00Z&quot;
      },
      {
        &quot;id&quot;: 43,
        &quot;mention_role&quot;: &quot;reviewer&quot;,
        &quot;created_at&quot;: &quot;2026-02-03T10:05:00Z&quot;
      },
      {
        &quot;id&quot;: 44,
        &quot;all&quot;: true,
        &quot;created_at&quot;: &quot;2026-02-03T10:10:00Z&quot;
      }
    ]
  },
  &quot;id&quot;: 1
}</code></pre>
<h2>Message Dispatch</h2>
<h3>Matching Algorithm</h3>
<p>When <code>message.send</code> is called, the dispatcher:</p>
<ol>
<li><strong>Query all subscriptions</strong> from database (joins with sessions and agents
tables for mention resolution)</li>
<li><strong>For each subscription</strong>, check if message matches:<ul>
<li><strong>Scope match</strong>: Any message scope matches subscription scope</li>
<li><strong>Mention match</strong>: Any message ref has <code>type=&quot;mention&quot;</code> and matches the
subscription&#39;s <code>mention_role</code>, the agent&#39;s role, or the agent&#39;s ID/name</li>
<li><strong>All match</strong>: Always matches (wildcard)</li>
</ul>
</li>
<li><strong>Build notification</strong> for each match</li>
<li><strong>Push to connected clients</strong> via the Broadcaster</li>
</ol>
<p><strong>Implementation (<code>dispatcher.go</code>):</strong></p>
<pre><code>// matchSubscription checks if a message matches a subscription.
// Supports both role-based mentions (@reviewer) and name-based mentions (@furiosa).
func matchSubscription(msg *MessageInfo, scopeType, scopeValue, mentionRole, agentID, agentRole sql.NullString) string {
    // All subscription - always matches
    if !scopeType.Valid &amp;&amp; !scopeValue.Valid &amp;&amp; !mentionRole.Valid {
        return &quot;all&quot;
    }

    // Scope subscription
    if scopeType.Valid &amp;&amp; scopeValue.Valid {
        for _, scope := range msg.Scopes {
            if scope.Type == scopeType.String &amp;&amp; scope.Value == scopeValue.String {
                return &quot;scope&quot;
            }
        }
    }

    // Mention subscription - matches on:
    // 1. subscription&#39;s mention_role
    // 2. agent&#39;s role (for role-based mentions)
    // 3. agent&#39;s ID/name (for name-based mentions like @furiosa)
    if mentionRole.Valid {
        for _, ref := range msg.Refs {
            if ref.Type == &quot;mention&quot; {
                if ref.Value == mentionRole.String {
                    return &quot;mention&quot;
                }
                if agentRole.Valid &amp;&amp; ref.Value == agentRole.String {
                    return &quot;mention&quot;
                }
                if agentID.Valid &amp;&amp; ref.Value == agentID.String {
                    return &quot;mention&quot;
                }
            }
        }
    }

    return &quot;&quot; // No match
}</code></pre>
<h3>Notification Building</h3>
<p>For each match, the dispatcher builds a notification payload:</p>
<pre><code>{
  &quot;method&quot;: &quot;notification.message&quot;,
  &quot;params&quot;: {
    &quot;message_id&quot;: &quot;msg_01HXE...&quot;,
    &quot;author&quot;: {
      &quot;agent_id&quot;: &quot;furiosa&quot;,
      &quot;name&quot;: &quot;furiosa&quot;,
      &quot;role&quot;: &quot;implementer&quot;,
      &quot;module&quot;: &quot;&quot;
    },
    &quot;preview&quot;: &quot;First 100 characters of content...&quot;,
    &quot;scopes&quot;: [{ &quot;type&quot;: &quot;module&quot;, &quot;value&quot;: &quot;auth&quot; }],
    &quot;matched_subscription&quot;: {
      &quot;subscription_id&quot;: 42,
      &quot;match_type&quot;: &quot;scope&quot;
    },
    &quot;timestamp&quot;: &quot;2026-02-03T10:00:00Z&quot;
  }
}</code></pre>
<p><strong>Author parsing:</strong></p>
<ul>
<li>Uses <code>identity.ParseAgentID()</code> to extract the role from the agent ID</li>
<li>The <code>name</code> field is set to the raw agent ID (which is the agent&#39;s name for
named agents)</li>
<li>The <code>module</code> field is empty -- module is not encoded in the agent ID and would
require a database lookup</li>
</ul>
<p><strong>Preview truncation:</strong></p>
<ul>
<li>If content is 100 chars or less: Use as-is</li>
<li>If content exceeds 100 chars: Truncate to 100 chars and append <code>&quot;...&quot;</code></li>
</ul>
<h2>Push Notifications</h2>
<h3>Broadcaster</h3>
<p>The daemon uses a <code>Broadcaster</code> (<code>internal/daemon/broadcaster.go</code>) that
implements the <code>ClientNotifier</code> interface. It tries both transport registries in
order:</p>
<ol>
<li><strong>Unix socket clients</strong> first (via <code>ClientRegistry</code> from
<code>internal/daemon/notify.go</code>)</li>
<li><strong>WebSocket clients</strong> as fallback (via <code>ClientRegistry</code> from
<code>internal/websocket/registry.go</code>)</li>
</ol>
<p>If the notification is delivered successfully via either transport, the
Broadcaster returns immediately. This means each session only receives one
notification per match, regardless of how many transports are available.</p>
<h3>Unix Socket Client Registry</h3>
<p><strong>Location:</strong> <code>internal/daemon/notify.go</code></p>
<pre><code>type ClientRegistry struct {
    mu      sync.RWMutex
    clients map[string]*ConnectedClient
}

type ConnectedClient struct {
    sessionID string
    conn      net.Conn
}</code></pre>
<p><strong>Operations:</strong></p>
<ul>
<li><code>Register(sessionID, conn)</code> - Add client when they connect</li>
<li><code>Unregister(sessionID)</code> - Remove client on disconnect</li>
<li><code>Notify(sessionID, *Notification)</code> - Send notification with newline framing</li>
</ul>
<h3>WebSocket Client Registry</h3>
<p><strong>Location:</strong> <code>internal/websocket/registry.go</code></p>
<pre><code>type ClientRegistry struct {
    mu      sync.RWMutex
    clients map[string]*Connection
}</code></pre>
<p><strong>Operations:</strong></p>
<ul>
<li><code>Register(sessionID, conn)</code> - Add client when they connect</li>
<li><code>Unregister(sessionID)</code> - Remove client on disconnect</li>
<li><code>Get(sessionID)</code> - Look up client by session ID</li>
<li><code>Count()</code> - Number of connected clients</li>
<li><code>CloseAll()</code> - Close all connections (used during shutdown)</li>
<li><code>Notify(sessionID, notification)</code> - Send JSON-RPC notification via WebSocket
frame</li>
</ul>
<h3>Sending Notifications</h3>
<p>When the dispatcher finds matches, it calls <code>Broadcaster.Notify()</code> for each:</p>
<ol>
<li><strong>Lookup session</strong> in Unix socket registry, then WebSocket registry<ul>
<li>If not found in either: Silently succeed (client will see message via
<code>message.list</code>)</li>
</ul>
</li>
<li><strong>Marshal notification</strong> to JSON-RPC format</li>
<li><strong>Write to transport</strong>:<ul>
<li>Unix socket: Newline-delimited JSON</li>
<li>WebSocket: Text frame via buffered send channel (256-message buffer)</li>
</ul>
</li>
<li><strong>Handle errors</strong>:<ul>
<li>Write error: Client disconnected - auto-unregister</li>
<li>Buffer full (WebSocket): Client disconnected - auto-unregister</li>
<li>Success: Continue</li>
</ul>
</li>
</ol>
<p><strong>JSON-RPC notification format:</strong></p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;notification.message&quot;,
  &quot;params&quot;: {
    /* NotifyParams */
  }
}</code></pre>
<p><strong>Note:</strong> No <code>id</code> field - notifications are one-way, no response expected.</p>
<h3>Connection Management</h3>
<p><strong>Client responsibilities:</strong></p>
<ol>
<li>Keep connection open during session</li>
<li>Listen for incoming notifications</li>
<li>Parse JSON-RPC notifications (no <code>id</code> field)</li>
<li>Fetch full message content with <code>message.get</code></li>
</ol>
<p><strong>Daemon responsibilities:</strong></p>
<ol>
<li>Track connected clients by session</li>
<li>Auto-unregister on write errors</li>
<li>Don&#39;t block message.send on notification failures</li>
<li>Silently ignore notifications to disconnected clients</li>
</ol>
<h2>Testing</h2>
<h3>Coverage</h3>
<p><strong>Key test scenarios:</strong></p>
<ol>
<li>Subscription CRUD (create, list, unsubscribe)</li>
<li>Duplicate prevention (all subscription types)</li>
<li>Scope matching (exact match, multiple scopes, no match)</li>
<li>Mention matching (role-based @reviewer, name-based @furiosa)</li>
<li>All subscription matching (wildcard)</li>
<li>Multiple subscriptions per session</li>
<li>Client registry (register, unregister, notify) for both Unix socket and
WebSocket</li>
<li>Notification format (JSON-RPC, field validation)</li>
<li>Preview truncation (short, long, exact 100 chars)</li>
<li>Disconnected client handling (auto-unregister)</li>
<li>Broadcaster routing (Unix socket first, WebSocket fallback)</li>
</ol>
<h3>Test Patterns</h3>
<p><strong>Database tests</strong> use temp directories:</p>
<pre><code>tmpDir := t.TempDir()
db, err := schema.OpenDB(filepath.Join(tmpDir, &quot;test.db&quot;))
defer db.Close()</code></pre>
<p><strong>Unix socket connection tests</strong> use <code>net.Pipe()</code>:</p>
<pre><code>server, client := net.Pipe()
defer server.Close()
defer client.Close()

// IMPORTANT: net.Pipe() is synchronous - use goroutines
go func() {
    buf := make([]byte, 1024)
    n, _ := client.Read(buf)
    // Process buffer
}()
registry.Notify(&quot;ses_001&quot;, notification)</code></pre>
<h2>Performance Considerations</h2>
<h3>Matching Efficiency</h3>
<p><strong>Current implementation:</strong></p>
<ul>
<li>Load ALL subscriptions from DB on every message</li>
<li>O(N) matching where N = number of subscriptions</li>
<li>Joins with sessions and agents tables for mention resolution</li>
</ul>
<p><strong>Rationale for simple approach:</strong></p>
<ul>
<li>Expected subscription count: &lt; 100 per daemon instance</li>
<li>Message send frequency: &lt; 10/second</li>
<li>Premature optimization avoided - measure first</li>
</ul>
<h3>Notification Delivery</h3>
<p><strong>Current:</strong></p>
<ul>
<li>Synchronous notification sending via Broadcaster</li>
<li>Blocks message.send briefly</li>
</ul>
<p><strong>Trade-off:</strong></p>
<ul>
<li>Simplicity vs. throughput</li>
<li>Current approach is correct and maintainable</li>
<li>Optimize when proven necessary</li>
</ul>
<h2>Error Handling</h2>
<h3>Subscription Errors</h3>
<table>
<thead>
<tr>
<th>Scenario</th>
<th>Behavior</th>
</tr>
</thead>
<tbody><tr>
<td>Duplicate subscription</td>
<td>Return error <code>&quot;subscription already exists&quot;</code></td>
</tr>
<tr>
<td>Invalid session</td>
<td>Return error <code>&quot;no active session found&quot;</code></td>
</tr>
<tr>
<td>Missing parameters</td>
<td>Return error <code>&quot;at least one of scope, mention_role, or all must be specified&quot;</code></td>
</tr>
<tr>
<td>Database error</td>
<td>Return error with details</td>
</tr>
</tbody></table>
<h3>Notification Errors</h3>
<table>
<thead>
<tr>
<th>Scenario</th>
<th>Behavior</th>
</tr>
</thead>
<tbody><tr>
<td>Client not connected</td>
<td>Silently succeed (client will poll)</td>
</tr>
<tr>
<td>Write error (disconnect)</td>
<td>Auto-unregister, return error</td>
</tr>
<tr>
<td>Buffer full (WebSocket)</td>
<td>Auto-unregister, return error</td>
</tr>
<tr>
<td>Marshal error</td>
<td>Return error (should never happen)</td>
</tr>
</tbody></table>
<h3>Recovery</h3>
<p><strong>Client reconnection:</strong></p>
<ul>
<li>Registry tracks by session ID</li>
<li>Re-register on reconnect</li>
<li>Previous subscriptions still active (tied to session, not connection)</li>
</ul>
<h2>Design Notes</h2>
<h3>Why Application-Level Duplicate Checking?</h3>
<p>SQLite&#39;s <code>UNIQUE</code> constraint fails with NULL values:</p>
<ul>
<li><code>(ses_001, NULL, NULL, NULL)</code> can be inserted multiple times</li>
<li>SQLite treats NULL != NULL in uniqueness checks</li>
</ul>
<p><strong>Alternatives considered:</strong></p>
<ol>
<li>Use empty string <code>&quot;&quot;</code> instead of NULL - Semantically incorrect</li>
<li>Separate tables per subscription type - Over-engineered</li>
<li><strong>Application-level checking</strong> - Simple, correct, maintainable (chosen)</li>
</ol>
<h3>Why Silently Ignore Disconnected Clients?</h3>
<p>When a notification can&#39;t be sent (client disconnected):</p>
<ol>
<li>Message is already in database (via <code>message.send</code>)</li>
<li>Client will see it when they call <code>message.list</code></li>
<li>Failing the entire <code>message.send</code> would be wrong</li>
</ol>
<p><strong>Design:</strong></p>
<ul>
<li>Notifications are <strong>best-effort delivery</strong></li>
<li>Database is <strong>source of truth</strong></li>
<li>Clients must poll <code>message.list</code> on reconnect</li>
</ul>
<h3>Why Preview Truncation?</h3>
<ul>
<li>Full message content can be large (megabytes)</li>
<li>Notifications should be lightweight</li>
<li>Clients can fetch full content with <code>message.get</code></li>
<li>100 chars is enough for preview/triage</li>
</ul>
<h2>References</h2>
<ul>
<li>RPC API: <code>docs/rpc-api.md</code></li>
<li>Messaging: <code>docs/messaging.md</code></li>
<li>Daemon Architecture: <code>docs/daemon.md</code></li>
<li>Event Streaming: <code>docs/event-streaming.md</code></li>
<li>WebSocket API: <code>docs/api/websocket.md</code></li>
<li>SQLite Schema: <code>internal/schema/schema.go</code></li>
<li>Subscription Service: <code>internal/subscriptions/service.go</code></li>
<li>Dispatcher: <code>internal/subscriptions/dispatcher.go</code></li>
<li>Broadcaster: <code>internal/daemon/broadcaster.go</code></li>
<li>Unix Socket Client Registry: <code>internal/daemon/notify.go</code></li>
<li>WebSocket Client Registry: <code>internal/websocket/registry.go</code></li>
</ul>
<pre><code></code></pre>

</main>
<script>if(location.search.indexOf('nospa')===-1){location.replace('../docs.html#subscriptions.html')}</script>
</body>
</html>