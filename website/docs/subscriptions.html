<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Subscriptions & Notifications — Thrum</title>
  <meta name="description" content="Real-time push notification system with scope, mention, and all-message filters - subscription lifecycle and dispatch">
  <!-- Open Graph -->
  <meta property="og:type" content="article">
  <meta property="og:title" content="Subscriptions &amp; Notifications — Thrum">
  <meta property="og:description" content="Real-time push notification system with scope, mention, and all-message filters - subscription lifecycle and dispatch">
  <meta property="og:url" content="https://leonletto.github.io/thrum/docs/subscriptions.html">
  <meta property="og:site_name" content="Thrum">
  <meta property="og:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Subscriptions &amp; Notifications — Thrum">
  <meta name="twitter:description" content="Real-time push notification system with scope, mention, and all-message filters - subscription lifecycle and dispatch">
  <meta name="twitter:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <!-- Canonical: SPA is the primary URL -->
  <link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#subscriptions.html">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x26A1;</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/theme.css">
  <link rel="stylesheet" href="../css/docs.css">
  <script>
    (function(){var t=localStorage.getItem('thrum-theme');if(t){document.documentElement.setAttribute('data-theme',t)}else if(window.matchMedia&&window.matchMedia('(prefers-color-scheme:light)').matches){document.documentElement.setAttribute('data-theme','light')}else{document.documentElement.setAttribute('data-theme','dark')}})();
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <nav class="header-nav">
        <a href="../index.html" class="logo">
          <span class="logo-glyph">&gt;_</span>
          <span class="logo-text">thrum</span>
        </a>
        <div class="nav-links">
          <a href="../index.html" class="nav-link">Home</a>
          <a href="../docs.html" class="nav-link nav-link-active">Docs</a>
          <a href="../about.html" class="nav-link">About</a>
          <a href="https://github.com/leonletto/thrum" class="nav-link nav-link-external" target="_blank" rel="noopener">GitHub</a>
        </div>
      </nav>
    </div>
  </header>
  <main class="docs-content" style="max-width:48rem;margin:2rem auto;padding:0 1.5rem">
    <div class="docs-content-inner">
<h2>Subscriptions &amp; Notifications</h2>
<h2>Quick Reference</h2>
<h3>CLI Commands</h3>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>thrum subscribe</code></td>
<td>Subscribe to notifications (scope, mention, all)</td>
</tr>
<tr>
<td><code>thrum unsubscribe ID</code></td>
<td>Remove a subscription by ID</td>
</tr>
<tr>
<td><code>thrum subscriptions</code></td>
<td>List active subscriptions for current session</td>
</tr>
<tr>
<td><code>thrum wait</code></td>
<td>Block until notification arrives or timeout</td>
</tr>
</tbody></table>
<h2>Overview</h2>
<p>The subscription system allows agents to receive real-time push notifications<br>when messages match their interests. Agents can subscribe to:</p>
<ul>
<li><strong>Scopes</strong> - Messages with specific scope (e.g., <code>module:auth</code>,<br><code>file:main.go</code>)</li>
<li><strong>Mentions</strong> - Messages that @mention a specific role (e.g., <code>@reviewer</code>) or<br>agent name (e.g., <code>@furiosa</code>)</li>
<li><strong>All messages</strong> - Wildcard subscription to receive all messages</li>
</ul>
<p>Subscriptions are automatically deleted when a session ends (added in v0.4.3).<br>Subscription identity resolution now correctly uses the caller&#39;s agent ID for<br>filtering (caller_agent_id resolution fix in v0.4.3).</p>
<p>When a new message matches a subscription, the daemon:</p>
<ol>
<li>Identifies matching subscriptions via the <strong>dispatcher</strong></li>
<li>Sends <strong>push notifications</strong> to connected clients via the <strong>broadcaster</strong></li>
<li>Stores the message for later retrieval via <code>message.list</code> API</li>
</ol>
<h2>Architecture</h2>
<h3>Components</h3>
<pre><code class="language-text hljs">+-------------------------------------------------------------+
|                      Message Flow                            |
+-------------------------------------------------------------+

  message.send RPC
       |
       v
  +--------------+
  | Message      |  1. Write to JSONL (sharded per-agent)
  | Handler      |  2. Insert into SQLite
  +---------+----+  3. Extract scopes/refs
            |
            v
  +--------------+
  | Dispatcher   |  1. Query all subscriptions
  |              |  2. Match against message (scope/mention/all)
  +---------+----+  3. Build notifications
            |
            v
  +--------------+
  | Broadcaster  |  1. Try Unix socket clients first
  |              |  2. Fall back to WebSocket clients
  +---------+----+  3. Best-effort delivery
            |
       +----+----+
       |         |
       v         v
  Unix Socket   WebSocket
  Clients       Clients (port 9999)
       |         |
       v         v
    Connected clients receive notification.message
```text

### Database Schema

**subscriptions table:**

```sql
CREATE TABLE subscriptions (
  id           INTEGER PRIMARY KEY AUTOINCREMENT,
  session_id   TEXT NOT NULL,
  scope_type   TEXT,                    -- NULL for non-scope subscriptions
  scope_value  TEXT,                   -- NULL for non-scope subscriptions
  mention_role TEXT,                  -- NULL for non-mention subscriptions
  created_at   TEXT NOT NULL,
  UNIQUE(session_id, scope_type, scope_value, mention_role)
);

-- Indexes for efficient matching
CREATE INDEX idx_subscriptions_scope ON subscriptions(scope_type, scope_value);
CREATE INDEX idx_subscriptions_mention ON subscriptions(mention_role);
CREATE INDEX idx_subscriptions_session ON subscriptions(session_id);
```go

**Note:** The subscriptions table does not have a foreign key constraint on
`session_id`. Subscription cleanup on session end is handled at the application
level.

**Subscription types (mutually exclusive):**

| Type    | scope_type | scope_value | mention_role | Description                               |
| ------- | ---------- | ----------- | ------------ | ----------------------------------------- |
| Scope   | `&quot;module&quot;` | `&quot;auth&quot;`    | `NULL`       | Matches messages with scope `module:auth` |
| Mention | `NULL`     | `NULL`      | `&quot;reviewer&quot;` | Matches messages with `@reviewer` mention |
| All     | `NULL`     | `NULL`      | `NULL`       | Matches all messages (wildcard)           |

### Duplicate Prevention

SQLite&#x27;s `UNIQUE` constraint doesn&#x27;t work correctly with NULL values (treats
each NULL as unique). We implement **application-level duplicate checking** in
`service.go`:

```go
func (s *Service) subscriptionExists(...) (bool, error) {
    // Build query with explicit NULL checks for each combination
    if scopeType != nil &amp;&amp; scopeValue != nil {
        query = &quot;WHERE session_id = ? AND scope_type = ? AND scope_value = ?&quot;
    } else if mentionRole != nil {
        query = &quot;WHERE session_id = ? AND mention_role = ?&quot;
    } else {
        query = &quot;WHERE session_id = ? AND scope_type IS NULL AND ...&quot;
    }
}
```go

## Subscription Lifecycle

### Creating Subscriptions

1. Client calls `subscribe` RPC with subscription criteria
2. Handler validates:
   - Session is active (resolved from agent identity config)
   - At least one of scope, mention_role, or all specified
   - No duplicate subscription exists (application-level check)
3. Insert into `subscriptions` table
4. Return subscription ID

**Example:**

```json
// Request
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;subscribe&quot;,
  &quot;params&quot;: {&quot;scope&quot;: {&quot;type&quot;: &quot;module&quot;, &quot;value&quot;: &quot;auth&quot;}},
  &quot;id&quot;: 1
}

// Response
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;subscription_id&quot;: 42,
    &quot;session_id&quot;: &quot;ses_01HXE...&quot;,
    &quot;created_at&quot;: &quot;2026-02-03T10:00:00Z&quot;
  },
  &quot;id&quot;: 1
}
```text

### Removing Subscriptions

1. Client calls `unsubscribe` RPC with subscription ID
2. Handler verifies subscription belongs to current session
3. Delete from `subscriptions` table
4. Return `{&quot;removed&quot;: true}` or `{&quot;removed&quot;: false}` (idempotent)

**Example:**

```json
// Request
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;unsubscribe&quot;,
  &quot;params&quot;: {&quot;subscription_id&quot;: 42},
  &quot;id&quot;: 2
}

// Response
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {&quot;removed&quot;: true},
  &quot;id&quot;: 2
}
```text

### Listing Subscriptions

```json
// Request
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;subscriptions.list&quot;,
  &quot;id&quot;: 1
}

// Response
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;subscriptions&quot;: [
      {
        &quot;id&quot;: 42,
        &quot;scope_type&quot;: &quot;module&quot;,
        &quot;scope_value&quot;: &quot;auth&quot;,
        &quot;created_at&quot;: &quot;2026-02-03T10:00:00Z&quot;
      },
      {
        &quot;id&quot;: 43,
        &quot;mention_role&quot;: &quot;reviewer&quot;,
        &quot;created_at&quot;: &quot;2026-02-03T10:05:00Z&quot;
      },
      {
        &quot;id&quot;: 44,
        &quot;all&quot;: true,
        &quot;created_at&quot;: &quot;2026-02-03T10:10:00Z&quot;
      }
    ]
  },
  &quot;id&quot;: 1
}
```go

## Message Dispatch

### Matching Algorithm

When `message.send` is called, the dispatcher:

1. **Query all subscriptions** from database (joins with sessions and agents
   tables for mention resolution)
2. **For each subscription**, check if message matches:
   - **Scope match**: Any message scope matches subscription scope
   - **Mention match**: Any message ref has `type=&quot;mention&quot;` and matches the
     subscription&#x27;s `mention_role`, the agent&#x27;s role, or the agent&#x27;s ID/name
   - **All match**: Always matches (wildcard)
3. **Build notification** for each match
4. **Push to connected clients** via the Broadcaster

**Implementation (`dispatcher.go`):**

```go
// matchSubscription checks if a message matches a subscription.
// Supports both role-based mentions (@reviewer) and name-based mentions (@furiosa).
func matchSubscription(msg *MessageInfo, scopeType, scopeValue, mentionRole, agentID, agentRole sql.NullString) string {
    // All subscription - always matches
    if !scopeType.Valid &amp;&amp; !scopeValue.Valid &amp;&amp; !mentionRole.Valid {
        return &quot;all&quot;
    }

    // Scope subscription
    if scopeType.Valid &amp;&amp; scopeValue.Valid {
        for _, scope := range msg.Scopes {
            if scope.Type == scopeType.String &amp;&amp; scope.Value == scopeValue.String {
                return &quot;scope&quot;
            }
        }
    }

    // Mention subscription - matches on:
    // 1. subscription&#x27;s mention_role
    // 2. agent&#x27;s role (for role-based mentions)
    // 3. agent&#x27;s ID/name (for name-based mentions like @furiosa)
    if mentionRole.Valid {
        for _, ref := range msg.Refs {
            if ref.Type == &quot;mention&quot; {
                if ref.Value == mentionRole.String {
                    return &quot;mention&quot;
                }
                if agentRole.Valid &amp;&amp; ref.Value == agentRole.String {
                    return &quot;mention&quot;
                }
                if agentID.Valid &amp;&amp; ref.Value == agentID.String {
                    return &quot;mention&quot;
                }
            }
        }
    }

    return &quot;&quot; // No match
}
```go

### Notification Building

For each match, the dispatcher builds a notification payload:

```json
{
  &quot;method&quot;: &quot;notification.message&quot;,
  &quot;params&quot;: {
    &quot;message_id&quot;: &quot;msg_01HXE...&quot;,
    &quot;author&quot;: {
      &quot;agent_id&quot;: &quot;furiosa&quot;,
      &quot;name&quot;: &quot;furiosa&quot;,
      &quot;role&quot;: &quot;implementer&quot;,
      &quot;module&quot;: &quot;&quot;
    },
    &quot;preview&quot;: &quot;First 100 characters of content...&quot;,
    &quot;scopes&quot;: [{ &quot;type&quot;: &quot;module&quot;, &quot;value&quot;: &quot;auth&quot; }],
    &quot;matched_subscription&quot;: {
      &quot;subscription_id&quot;: 42,
      &quot;match_type&quot;: &quot;scope&quot;
    },
    &quot;timestamp&quot;: &quot;2026-02-03T10:00:00Z&quot;
  }
}
```go

**Author parsing:**

- Uses `identity.ParseAgentID()` to extract the role from the agent ID
- The `name` field is set to the raw agent ID (which is the agent&#x27;s name for
  named agents)
- The `module` field is empty -- module is not encoded in the agent ID and would
  require a database lookup

**Preview truncation:**

- If content is 100 chars or less: Use as-is
- If content exceeds 100 chars: Truncate to 100 chars and append `&quot;...&quot;`

## Push Notifications

### Broadcaster

The daemon uses a `Broadcaster` (`internal/daemon/broadcaster.go`) that
implements the `ClientNotifier` interface. It tries both transport registries in
order:

1. **Unix socket clients** first (via `ClientRegistry` from
   `internal/daemon/notify.go`)
2. **WebSocket clients** as fallback (via `ClientRegistry` from
   `internal/websocket/registry.go`)

If the notification is delivered successfully via either transport, the
Broadcaster returns immediately. This means each session only receives one
notification per match, regardless of how many transports are available.

### Unix Socket Client Registry

**Location:** `internal/daemon/notify.go`

```go
type ClientRegistry struct {
    mu      sync.RWMutex
    clients map[string]*ConnectedClient
}

type ConnectedClient struct {
    sessionID string
    conn      net.Conn
}
```go

**Operations:**

- `Register(sessionID, conn)` - Add client when they connect
- `Unregister(sessionID)` - Remove client on disconnect
- `Notify(sessionID, *Notification)` - Send notification with newline framing

### WebSocket Client Registry

**Location:** `internal/websocket/registry.go`

```go
type ClientRegistry struct {
    mu      sync.RWMutex
    clients map[string]*Connection
}
```text

**Operations:**

- `Register(sessionID, conn)` - Add client when they connect
- `Unregister(sessionID)` - Remove client on disconnect
- `Get(sessionID)` - Look up client by session ID
- `Count()` - Number of connected clients
- `CloseAll()` - Close all connections (used during shutdown)
- `Notify(sessionID, notification)` - Send JSON-RPC notification via WebSocket
  frame

### Sending Notifications

When the dispatcher finds matches, it calls `Broadcaster.Notify()` for each:

1. **Lookup session** in Unix socket registry, then WebSocket registry
   - If not found in either: Silently succeed (client will see message via
     `message.list`)
2. **Marshal notification** to JSON-RPC format
3. **Write to transport**:
   - Unix socket: Newline-delimited JSON
   - WebSocket: Text frame via buffered send channel (256-message buffer)
4. **Handle errors**:
   - Write error: Client disconnected - auto-unregister
   - Buffer full (WebSocket): Client disconnected - auto-unregister
   - Success: Continue

**JSON-RPC notification format:**

```json
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;notification.message&quot;,
  &quot;params&quot;: {
    /* NotifyParams */
  }
}
```text

**Note:** No `id` field - notifications are one-way, no response expected.

### Connection Management

**Client responsibilities:**

1. Keep connection open during session
2. Listen for incoming notifications
3. Parse JSON-RPC notifications (no `id` field)
4. Fetch full message content with `message.get`

**Daemon responsibilities:**

1. Track connected clients by session
2. Auto-unregister on write errors
3. Don&#x27;t block message.send on notification failures
4. Silently ignore notifications to disconnected clients

## Testing

### Coverage

**Key test scenarios:**

1. Subscription CRUD (create, list, unsubscribe)
2. Duplicate prevention (all subscription types)
3. Scope matching (exact match, multiple scopes, no match)
4. Mention matching (role-based @reviewer, name-based @furiosa)
5. All subscription matching (wildcard)
6. Multiple subscriptions per session
7. Client registry (register, unregister, notify) for both Unix socket and
   WebSocket
8. Notification format (JSON-RPC, field validation)
9. Preview truncation (short, long, exact 100 chars)
10. Disconnected client handling (auto-unregister)
11. Broadcaster routing (Unix socket first, WebSocket fallback)

### Test Patterns

**Database tests** use temp directories:

```go
tmpDir := t.TempDir()
db, err := schema.OpenDB(filepath.Join(tmpDir, &quot;test.db&quot;))
defer db.Close()
```go

**Unix socket connection tests** use `net.Pipe()`:

```go
server, client := net.Pipe()
defer server.Close()
defer client.Close()

// IMPORTANT: net.Pipe() is synchronous - use goroutines
go func() {
    buf := make([]byte, 1024)
    n, _ := client.Read(buf)
    // Process buffer
}()
registry.Notify(&quot;ses_001&quot;, notification)
```text

## Performance Considerations

### Matching Efficiency

**Current implementation:**

- Load ALL subscriptions from DB on every message
- O(N) matching where N = number of subscriptions
- Joins with sessions and agents tables for mention resolution

**Rationale for simple approach:**

- Expected subscription count: &lt; 100 per daemon instance
- Message send frequency: &lt; 10/second
- Premature optimization avoided - measure first

### Notification Delivery

**Current:**

- Synchronous notification sending via Broadcaster
- Blocks message.send briefly

**Trade-off:**

- Simplicity vs. throughput
- Current approach is correct and maintainable
- Optimize when proven necessary

## Error Handling

### Subscription Errors

| Scenario               | Behavior                                                                       |
| ---------------------- | ------------------------------------------------------------------------------ |
| Duplicate subscription | Return error `&quot;subscription already exists&quot;`                                   |
| Invalid session        | Return error `&quot;no active session found&quot;`                                       |
| Missing parameters     | Return error `&quot;at least one of scope, mention_role, or all must be specified&quot;` |
| Database error         | Return error with details                                                      |

### Notification Errors

| Scenario                 | Behavior                            |
| ------------------------ | ----------------------------------- |
| Client not connected     | Silently succeed (client will poll) |
| Write error (disconnect) | Auto-unregister, return error       |
| Buffer full (WebSocket)  | Auto-unregister, return error       |
| Marshal error            | Return error (should never happen)  |

### Recovery

**Client reconnection:**

- Registry tracks by session ID
- Re-register on reconnect
- Previous subscriptions still active (tied to session, not connection)

## Design Notes

### Why Application-Level Duplicate Checking?

SQLite&#x27;s `UNIQUE` constraint fails with NULL values:

- `(ses_001, NULL, NULL, NULL)` can be inserted multiple times
- SQLite treats NULL != NULL in uniqueness checks

**Alternatives considered:**

1. Use empty string `&quot;&quot;` instead of NULL - Semantically incorrect
2. Separate tables per subscription type - Over-engineered
3. **Application-level checking** - Simple, correct, maintainable (chosen)

### Why Silently Ignore Disconnected Clients?

When a notification can&#x27;t be sent (client disconnected):

1. Message is already in database (via `message.send`)
2. Client will see it when they call `message.list`
3. Failing the entire `message.send` would be wrong

**Design:**

- Notifications are **best-effort delivery**
- Database is **source of truth**
- Clients must poll `message.list` on reconnect

### Why Preview Truncation?

- Full message content can be large (megabytes)
- Notifications should be lightweight
- Clients can fetch full content with `message.get`
- 100 chars is enough for preview/triage

## References

- RPC API: `docs/rpc-api.md`
- Messaging: `docs/messaging.md`
- Daemon Architecture: `docs/daemon.md`
- Event Streaming: `docs/event-streaming.md`
- WebSocket API: `docs/api/websocket.md`
- SQLite Schema: `internal/schema/schema.go`
- Subscription Service: `internal/subscriptions/service.go`
- Dispatcher: `internal/subscriptions/dispatcher.go`
- Broadcaster: `internal/daemon/broadcaster.go`
- Unix Socket Client Registry: `internal/daemon/notify.go`
- WebSocket Client Registry: `internal/websocket/registry.go`</code></pre>

    </div>
    <p style="margin-top:2rem"><a href="../docs.html#subscriptions.html">&larr; View in documentation</a></p>
  </main>
  <script>
    // Redirect browsers to the SPA for full navigation experience.
    // Crawlers (which don't execute JS) will index the static content above.
    if (window.location.search.indexOf('nospa') === -1) {
      window.location.replace('../docs.html#subscriptions.html');
    }
  </script>
</body>
</html>