<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Technical Overview — Thrum</title>
  <meta name="description" content="High-level overview of Thrum — architecture, storage, daemon, CLI, MCP server, and key concepts">
  <!-- Open Graph -->
  <meta property="og:type" content="article">
  <meta property="og:title" content="Technical Overview — Thrum">
  <meta property="og:description" content="High-level overview of Thrum — architecture, storage, daemon, CLI, MCP server, and key concepts">
  <meta property="og:url" content="https://leonletto.github.io/thrum/docs/overview.html">
  <meta property="og:site_name" content="Thrum">
  <meta property="og:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Technical Overview — Thrum">
  <meta name="twitter:description" content="High-level overview of Thrum — architecture, storage, daemon, CLI, MCP server, and key concepts">
  <meta name="twitter:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <!-- Canonical: SPA is the primary URL -->
  <link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#overview.html">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x26A1;</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/theme.css">
  <link rel="stylesheet" href="../css/docs.css">
  <script>
    (function(){var t=localStorage.getItem('thrum-theme');if(t){document.documentElement.setAttribute('data-theme',t)}else if(window.matchMedia&&window.matchMedia('(prefers-color-scheme:light)').matches){document.documentElement.setAttribute('data-theme','light')}else{document.documentElement.setAttribute('data-theme','dark')}})();
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <nav class="header-nav">
        <a href="../index.html" class="logo">
          <span class="logo-glyph">&gt;_</span>
          <span class="logo-text">thrum</span>
        </a>
        <div class="nav-links">
          <a href="../index.html" class="nav-link">Home</a>
          <a href="../docs.html" class="nav-link nav-link-active">Docs</a>
          <a href="../about.html" class="nav-link">About</a>
          <a href="https://github.com/leonletto/thrum" class="nav-link nav-link-external" target="_blank" rel="noopener">GitHub</a>
        </div>
      </nav>
    </div>
  </header>
  <main class="docs-content" style="max-width:48rem;margin:2rem auto;padding:0 1.5rem">
    <div class="docs-content-inner">
<h2>Technical Overview</h2>
<blockquote>
<p><strong>New here?</strong> Start with <a href="philosophy.html">Why Thrum Exists</a> for the philosophy<br>behind the project, or the <a href="quickstart.html">Quickstart Guide</a> to get running in<br>5 minutes. This document covers the technical architecture.</p>
</blockquote>
<p>Thrum is a Git-backed messaging system that helps you coordinate AI agents<br>across sessions, worktrees, and machines. It provides:</p>
<ul>
<li><strong>Persistent messaging</strong> that survives session boundaries</li>
<li><strong>Automatic synchronization</strong> via Git</li>
<li><strong>Real-time visibility</strong> into what other agents are working on</li>
<li><strong>Subscription-based notifications</strong> for targeted communication</li>
</ul>
<p>Everything is inspectable — messages are JSONL files on a Git branch, state is a<br>queryable SQLite database, and sync is plain Git push/pull.</p>
<p><strong>Quick Setup:</strong> After initialization, run <code>thrum setup claude-md --apply</code> to<br>generate agent coordination instructions for your CLAUDE.md file. Running<br><code>thrum prime</code> (or <code>thrum context prime</code>) checks for CLAUDE.md and suggests<br><code>thrum setup claude-md --apply</code> if no Thrum section is found.</p>
<h2>System Architecture</h2>
<pre><code class="language-go hljs">                    ┌─────────────────────────────────────────────────────────┐
                    │                     Thrum Daemon                         │
                    │  (Background service managing coordination &amp; sync)       │
                    ├─────────────────────────────────────────────────────────┤
                    │                                                          │
   ┌────────────┐   │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
   │   CLI      │◄──┼──┤ Unix Socket  │  │  Sync Loop   │  │  WebSocket   │  │
   │  (thrum)   │   │  │ JSON-RPC <span class="hljs-number">2.0</span> │  │  (<span class="hljs-number">60</span>s)       │  │  + SPA (<span class="hljs-number">9999</span>)│  │
   └────────────┘   │  └──────────────┘  └──────────────┘  └──────────────┘  │
                    │          │                │               │    │        │
   ┌────────────┐   │          │                │               │    └──►Web UI
   │ MCP Server │◄──┼──────────┘                │               │            │
   │  (stdio)   │   │          │                ▼               │            │
   └────────────┘   │          │  ┌─────────────────────────────────────┐   │
                    │          ▼  │         State Management             │   │
                    │             │  ┌─────────────┐  ┌──────────────┐  │   │
                    │             │  │  JSONL Logs  │  │   SQLite     │  │   │
                    │             │  │  (sharded)   │  │  Projection  │  │   │
                    │             │  └─────────────┘  └──────────────┘  │   │
                    │             └─────────────────────────────────────┘   │
                    │                          │                             │
                    └──────────────────────────┼─────────────────────────────┘
                                               │
                    ┌──────────────────────────┼──────────────────────────┐
                    │                          ▼                          │
                    │  .git/thrum-sync/a-sync/     .thrum/<span class="hljs-keyword">var</span>/            │
                    │  ├── events.jsonl            ├── messages.db        │
                    │  └── messages/               ├── thrum.sock         │
                    │      └── {agent}.jsonl       ├── thrum.pid (JSON)   │
                    │                              ├── thrum.lock (flock) │
                    │                              └── ws.port            │
                    └──────────────────────────┬──────────────────────────┘
                                               │ Git sync
                                               ▼
                                        ┌─────────────┐
                                        │   Remote    │
                                        │  (a-sync    │
                                        │   branch)   │
                                        └─────────────┘
<span class="hljs-string">``</span><span class="hljs-string">`text

## The Daemon: Central Coordinator

The daemon is the one process that everything else talks to. Start it once and
it handles messaging, sync, and state for all your agents — CLI, Web UI, and MCP
server all go through it.

### Core Services

| Service                     | Purpose                                       | Benefit                       |
| --------------------------- | --------------------------------------------- | ----------------------------- |
| **RPC Server**              | JSON-RPC 2.0 API over Unix socket             | CLI and programmatic access   |
| **WebSocket Server**        | Real-time bidirectional communication         | Web UI and live updates       |
| **Sync Loop**               | Automatic Git fetch/merge/push (60s interval) | Cross-machine synchronization |
| **Subscription Dispatcher** | Route notifications to interested clients     | Targeted communication        |
| **State Management**        | JSONL log + SQLite projection                 | Persistence + fast queries    |

### Everything Depends on the Daemon

`</span><span class="hljs-string">``</span>text
┌─────────────────────────────────────────────────────────────┐
│                     CLIENTS (Depend on Daemon)               │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌─────────────┐   ┌─────────────┐   ┌─────────────┐       │
│   │    CLI      │   │   Web UI    │   │  MCP Server │       │
│   │  (thrum)    │   │  (React)    │   │  (stdio)    │       │
│   └──────┬──────┘   └──────┬──────┘   └──────┬──────┘       │
│          │                 │                  │              │
│          │ Unix Socket     │ WebSocket        │ Unix Socket  │
│          │ JSON-RPC <span class="hljs-number">2.0</span>    │ JSON-RPC <span class="hljs-number">2.0</span>     │ + WebSocket  │
│          │                 │                  │              │
└──────────┼─────────────────┼──────────────────┼──────────────┘
           │                 │                  │
           ▼                 ▼                  ▼
    ┌─────────────────────────────────────────────────┐
    │                    DAEMON                        │
    │  (Single source of truth <span class="hljs-keyword">for</span> all clients)        │
    └─────────────────────────────────────────────────┘
<span class="hljs-string">``</span><span class="hljs-string">`text

**CLI** (`</span>thrum<span class="hljs-string">` command): Sends messages, checks inbox, manages sessions. All
commands go through the daemon via Unix socket.

**Web UI** (Embedded React SPA): Provides a graphical interface for viewing
messages and agent activity. Served from the same port as WebSocket (default
9999). Browser users are auto-registered via git config.

**MCP Server** (`</span>thrum mcp serve<span class="hljs-string">`): Exposes Thrum functionality as native MCP
tools over stdio, enabling LLM agents (e.g., Claude Code) to communicate
directly through MCP protocol without CLI shell-outs. Connects to the daemon via
Unix socket for RPC and WebSocket for real-time push notifications. Provides 5
core messaging tools (`</span>send_message<span class="hljs-string">`, `</span>check_messages<span class="hljs-string">`, `</span>wait_for_message<span class="hljs-string">`,
`</span>list_agents<span class="hljs-string">`, `</span>broadcast_message<span class="hljs-string">`) and 6 group management tools
(`</span>create_group<span class="hljs-string">`, `</span>delete_group<span class="hljs-string">`, `</span>add_group_member<span class="hljs-string">`, `</span>remove_group_member<span class="hljs-string">`,
`</span>list_groups<span class="hljs-string">`, `</span>get_group<span class="hljs-string">`).

## Key Features

### 1. Persistent Messaging

Messages are stored in append-only JSONL logs on a dedicated `</span>a-sync<span class="hljs-string">` orphan
branch, accessed via a sync worktree at `</span>.git/thrum-sync/a-sync/<span class="hljs-string">`:

`</span><span class="hljs-string">``</span><span class="hljs-keyword">go</span>
.git/thrum-sync/a-sync/   ← Sync worktree on a-sync branch
├── events.jsonl          ← Agent lifecycle events
└── messages/
    └── *.jsonl           ← Per-agent message logs

.thrum/                   ← Gitignored entirely
├── <span class="hljs-keyword">var</span>/
│   ├── messages.db       ← SQLite query cache
│   ├── thrum.sock        ← Unix socket
│   ├── thrum.pid         ← Process ID (JSON: PID, RepoPath, StartedAt, SocketPath)
│   ├── thrum.lock        ← flock <span class="hljs-keyword">for</span> SIGKILL resilience
│   ├── ws.port           ← WebSocket port number
│   └── sync.lock         ← Sync lock
├── identities/           ← Per-worktree agent identities
│   └── {agent_name}.json
├── context/              ← Per-agent context storage
│   └── {agent_name}.md
└── redirect              ← (feature worktrees only) points to main .thrum/
<span class="hljs-string">``</span><span class="hljs-string">`text

Messages survive:

- Session restarts
- Machine reboots
- Context window compaction
- Agent replacement

### 2. Git-Based Synchronization

The daemon automatically syncs messages via the sync worktree at
`</span>.git/thrum-sync/a-sync/<span class="hljs-string">`, checked out on the `</span>a-sync<span class="hljs-string">` orphan branch. No branch
switching is needed -- all git operations happen within the worktree:

`</span><span class="hljs-string">``</span>text
┌─────────────────────────────────────────────────────────────┐
│          Sync Loop (<span class="hljs-number">60</span>s) in .git/thrum-sync/a-sync/          │
├─────────────────────────────────────────────────────────────┤
│  <span class="hljs-number">1.</span> Acquire lock (.thrum/<span class="hljs-keyword">var</span>/sync.lock)                     │
│  <span class="hljs-number">2.</span> Fetch remote in worktree                                 │
│  <span class="hljs-number">3.</span> Merge JSONL (<span class="hljs-built_in">append</span>-only dedup by event ID)             │
│  <span class="hljs-number">4.</span> Project <span class="hljs-built_in">new</span> events into SQLite                           │
│  <span class="hljs-number">5.</span> Notify subscribers of <span class="hljs-built_in">new</span> events                         │
│  <span class="hljs-number">6.</span> Commit &amp; push local changes in worktree                  │
│  <span class="hljs-number">7.</span> Release lock                                             │
└─────────────────────────────────────────────────────────────┘
<span class="hljs-string">``</span><span class="hljs-string">`text

**Why Git?**

- Works offline (changes accumulate locally)
- Leverages existing authentication (SSH keys, HTTPS)
- Natural audit trail
- No additional infrastructure needed

### 3. Agent &amp; Session Management

Agents register with a human-readable name, role, and module:

`</span><span class="hljs-string">``</span>bash
thrum agent register --name furiosa --role=implementer --module=auth
<span class="hljs-string">``</span><span class="hljs-string">`go

Agent names follow the pattern `</span>[a-z0<span class="hljs-number">-9</span>_]+<span class="hljs-string">` (lowercase alphanumeric and
underscores). Reserved names: `</span>daemon<span class="hljs-string">`, `</span>system<span class="hljs-string">`, `</span>thrum<span class="hljs-string">`, `</span>all<span class="hljs-string">`, `</span>broadcast<span class="hljs-string">`.
Identity is resolved with the following priority: `</span>THRUM_NAME<span class="hljs-string">` env var &gt;
`</span>--name<span class="hljs-string">` flag &gt; solo-agent auto-select.

Each agent gets an identity file at `</span>.thrum/identities/{name}.json<span class="hljs-string">`. Multiple
agents can coexist in a single worktree, each with their own identity file.
Legacy `</span>agent:{role}:{hash}<span class="hljs-string">` IDs are still supported for backward compatibility.

Sessions track active work periods:

`</span><span class="hljs-string">``</span>bash
thrum session start   # Begin working
# ... do work ...
thrum session end     # Finish
<span class="hljs-string">``</span><span class="hljs-string">`text

Agents can be deleted and orphaned agents cleaned up:

`</span><span class="hljs-string">``</span>bash
thrum agent <span class="hljs-built_in">delete</span> furiosa           # Delete a specific agent
thrum agent cleanup --dry-run        # Preview orphaned agents
thrum agent cleanup --force          # Delete all orphaned agents
<span class="hljs-string">``</span><span class="hljs-string">`text

This enables:

- Identity tracking across sessions with human-readable names
- Multi-agent support per worktree
- Crash recovery (orphaned sessions auto-close)
- Orphan detection and cleanup
- Work context visibility

### 4. Subscription-Based Notifications

Agents subscribe to relevant events:

`</span><span class="hljs-string">``</span>bash
# Subscribe to your module
thrum subscribe --scope module:auth

# Subscribe to @mentions
thrum subscribe --mention @reviewer
<span class="hljs-string">``</span><span class="hljs-string">`text

When matching messages arrive, subscribers receive real-time notifications:

`</span><span class="hljs-string">``</span>json
{
  <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;notification.message&quot;</span>,
  <span class="hljs-string">&quot;params&quot;</span>: {
    <span class="hljs-string">&quot;message_id&quot;</span>: <span class="hljs-string">&quot;msg_01HXE...&quot;</span>,
    <span class="hljs-string">&quot;preview&quot;</span>: <span class="hljs-string">&quot;Auth implementation complete...&quot;</span>,
    <span class="hljs-string">&quot;matched_subscription&quot;</span>: {
      <span class="hljs-string">&quot;match_type&quot;</span>: <span class="hljs-string">&quot;scope&quot;</span>
    }
  }
}
<span class="hljs-string">``</span><span class="hljs-string">`text

### 5. Live Git State Tracking (Epic 21)

The daemon tracks what each agent is working on in real-time:

`</span><span class="hljs-string">``</span>sql
-- agent_work_contexts table
session_id        | agent_id        | branch      | unmerged_commits | uncommitted_files
ses_01HXE...      | furiosa         | feature/auth| <span class="hljs-number">3</span>                | [<span class="hljs-string">&quot;src/auth.go&quot;</span>]
ses_02HXF...      | maximus         | feature/db  | <span class="hljs-number">1</span>                | []
<span class="hljs-string">``</span><span class="hljs-string">`text

**What it tracks:**

- Current branch
- Unmerged commits vs main
- Changed files
- Uncommitted modifications
- Agent-set task and intent

**Why this matters:**

- Agent2 can see &quot;furiosa is working on auth.go with 3 unmerged commits&quot;
- No manual investigation needed
- Prevents duplicate work
- Enables intelligent handoffs

### 6. Dual-Transport API (Single Port)

The daemon serves the WebSocket API and embedded Web UI SPA on the same port
(default 9999, configurable via `</span>THRUM_WS_PORT<span class="hljs-string">`). The WebSocket endpoint is at
`</span>/ws<span class="hljs-string">`, and all other paths serve the React SPA with SPA fallback routing.

| Transport       | Endpoint                 | Use Case                           |
| --------------- | ------------------------ | ---------------------------------- |
| **Unix Socket** | `</span>.thrum/<span class="hljs-keyword">var</span>/thrum.sock<span class="hljs-string">`  | CLI, MCP server, scripts           |
| **WebSocket**   | `</span>ws:<span class="hljs-comment">//localhost:9999/ws` | Web UI, MCP waiter, real-time apps |</span>
| **HTTP**        | <span class="hljs-string">`http://localhost:9999/`</span> | Embedded React SPA (Web UI)        |

<span class="hljs-number">26</span> registered RPC methods on Unix socket (<span class="hljs-number">24</span> on WebSocket):

- <span class="hljs-string">`health`</span> - Daemon status
- <span class="hljs-string">`agent.register`</span>, <span class="hljs-string">`agent.list`</span>, <span class="hljs-string">`agent.whoami`</span>, <span class="hljs-string">`agent.listContext`</span>,
  <span class="hljs-string">`agent.delete`</span>, <span class="hljs-string">`agent.cleanup`</span>
- <span class="hljs-string">`session.start`</span>, <span class="hljs-string">`session.end`</span>, <span class="hljs-string">`session.list`</span>, <span class="hljs-string">`session.heartbeat`</span>,
  <span class="hljs-string">`session.setIntent`</span>, <span class="hljs-string">`session.setTask`</span>
- <span class="hljs-string">`message.send`</span>, <span class="hljs-string">`message.get`</span>, <span class="hljs-string">`message.list`</span>, <span class="hljs-string">`message.edit`</span>,
  <span class="hljs-string">`message.delete`</span>, <span class="hljs-string">`message.markRead`</span>
- <span class="hljs-string">`subscribe`</span>, <span class="hljs-string">`unsubscribe`</span>, <span class="hljs-string">`subscriptions.list`</span>
- <span class="hljs-string">`sync.force`</span>, <span class="hljs-string">`sync.status`</span>
- <span class="hljs-string">`user.register`</span>, <span class="hljs-string">`user.identify`</span> (user.register is WebSocket-only)

### <span class="hljs-number">7.</span> Message Lifecycle

Full message lifecycle management beyond send/receive:

<span class="hljs-string">``</span><span class="hljs-string">`bash
thrum message get MSG_ID        # Retrieve a message with full details
thrum message edit MSG_ID TEXT   # Edit your own messages (full replacement)
thrum message delete MSG_ID     # Delete a message (requires --force)
`</span><span class="hljs-string">``</span>text

Messages are automatically marked as read when viewed via <span class="hljs-string">`thrum inbox`</span> or
<span class="hljs-string">`thrum message get`</span>. Explicit mark-read is also available via the
<span class="hljs-string">`message.markRead`</span> RPC method.

### <span class="hljs-number">8.</span> Coordination Commands

Lightweight commands <span class="hljs-keyword">for</span> checking team activity:

<span class="hljs-string">``</span><span class="hljs-string">`bash
thrum who-has auth.go           # Which agents are editing a file?
thrum ping @reviewer            # Is an agent online? Show last-seen time
`</span><span class="hljs-string">``</span>text

These query agent work contexts to provide quick answers without full status
output.

### <span class="hljs-number">9.</span> Agent Context Management

Agents can save and retrieve volatile project state that doesn<span class="hljs-string">&#x27;t belong in git
commits but needs to survive session boundaries:

```bash
# Save context from a file or stdin
thrum context save --file continuation-notes.md
echo &quot;Next steps: finish JWT implementation&quot; | thrum context save

# View saved context
thrum context show

# Share context across worktrees (manual sync)
thrum context sync
```text

Context files are stored at `.thrum/context/{agent-name}.md` and integrated into
`thrum status` output. Use the `/update-context` skill in Claude Code for guided
context updates.

**Use cases:**

- Documenting architectural decisions under consideration
- Tracking partial investigation results
- Recording TODOs or questions for the next session
- Preserving context when handing off work

### 10. Understanding the CLI

Thrum has ~30 commands. Here&#x27;</span>s why that<span class="hljs-string">&#x27;s not as many as it sounds.

#### Daily Drivers (8 commands)

These are the commands you&#x27;</span>ll actually use. If you<span class="hljs-string">&#x27;re directing agents and
checking on their work, this is your whole toolkit:

| Command      | What it does                                     |
| ------------ | ------------------------------------------------ |
| `quickstart` | Register + start session + set intent — one step |
| `send`       | Send a message                                   |
| `inbox`      | Check your messages                              |
| `reply`      | Reply to a message                               |
| `team`       | What&#x27;</span>s everyone working on?                      |
| <span class="hljs-string">`overview`</span>   | Status + team + inbox in one view                |
| <span class="hljs-string">`status`</span>     | Your current state                               |
| <span class="hljs-string">`who-has`</span>    | Who<span class="hljs-string">&#x27;s editing this file?                         |

That&#x27;</span>s it <span class="hljs-keyword">for</span> daily use. Everything <span class="hljs-keyword">else</span> is infrastructure.

#### Designed <span class="hljs-keyword">for</span> Agents (~<span class="hljs-number">16</span> commands)

These commands exist because agents need programmatic lifecycle control. You
rarely use them directly — <span class="hljs-string">`quickstart`</span> handles the common <span class="hljs-keyword">case</span> — but agents
call them constantly:

| Area          | Commands                         | Why agents need them                    |
| ------------- | -------------------------------- | --------------------------------------- |
| Identity      | <span class="hljs-string">`agent register`</span>, <span class="hljs-string">`agent whoami`</span> | Agents register on startup              |
| Sessions      | <span class="hljs-string">`session start/end/heartbeat`</span>    | Track work periods, extract git state   |
| Work context  | <span class="hljs-string">`session set-intent/set-task`</span>    | Declare what they<span class="hljs-string">&#x27;re doing              |
| Notifications | `subscribe`, `wait`              | Block until relevant messages arrive    |
| Context       | `context save/show/clear`        | Persist state across compaction         |
| Messages      | `message get/edit/delete/read`   | CRUD on individual messages             |
| Groups        | `group create/add/remove/list`   | Organize teams programmatically         |
| MCP           | `mcp serve`                      | Native tool access for Claude Code etc. |

#### Setup &amp; Admin (run once)

`init`, `daemon start/stop`, `setup`, `migrate`, `agent delete/cleanup`,
`sync force/status`, `runtime list/show`, `ping`

#### Aliases (because agents get creative)

AI agents are unpredictable in how they guess command names. An agent told to
&quot;start working&quot; might try `thrum agent start` or `thrum session start`. Both
work. These duplicates exist on purpose — they reduce friction for non-human
users:

| Alias              | Points to            | Why it exists                               |
| ------------------ | -------------------- | ------------------------------------------- |
| `agent start`      | `session start`      | Agents think &quot;I&#x27;</span>m an agent, I should start<span class="hljs-string">&quot; |
| `agent end`        | `session end`        | Same pattern                                |
| `agent set-intent` | `session set-intent` | Natural grouping under `agent`              |
| `agent set-task`   | `session set-task`   | Same                                        |
| `agent heartbeat`  | `session heartbeat`  | Same                                        |
| `whoami`           | `agent whoami`       | Common enough to promote to top-level       |

## Storage Architecture

Thrum uses event sourcing with CQRS:

```text
┌─────────────────────────────────────────────────────────────┐
│                    Event Sourcing + CQRS                     │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────────────┐     ┌─────────────────────────┐    │
│  │   JSONL Event Logs  │     │   SQLite Projection     │    │
│  │   (Source of Truth) │────▶│   (Query Model)         │    │
│  │   in sync worktree  │     │   in .thrum/var/        │    │
│  └─────────────────────┘     └─────────────────────────┘    │
│        │                              │                      │
│        │ On a-sync branch             │ Gitignored           │
│        │ Append-only                  │ Rebuildable          │
│        │ Conflict-free merge          │ Fast queries         │
│        │                              │                      │
└────────┼──────────────────────────────┼──────────────────────┘
         │                              │
         ▼                              ▼
    Sync via worktree           Local CLI/UI queries
```go

**Benefits:**

- JSONL can be merged conflict-free (immutable events with unique IDs)
- SQLite provides fast queries with indexes
- SQLite can be rebuilt from JSONL anytime
- Offline-first: works without network

## What the Daemon Enables

### For the CLI

| Command                               | Daemon Feature Used                                           |
| ------------------------------------- | ------------------------------------------------------------- |
| `thrum send &quot;</span>Hello<span class="hljs-string">&quot;`                  | `message.send` RPC + auto-sync                                |
| `thrum inbox`                         | `message.list` RPC with filtering                             |
| `thrum subscribe --scope module:auth` | `subscribe` RPC + push notifications                          |
| `thrum agent list --context`          | `agent.listContext` RPC (live git state)                      |
| `thrum who-has FILE`                  | `agent.listContext` RPC filtered by file                      |
| `thrum ping @role`                    | `agent.list` + `agent.listContext` RPCs                       |
| `thrum quickstart --name NAME`        | `agent.register` + `session.start` + `session.setIntent` RPCs |
| `thrum overview`                      | Multiple RPCs combined into one view                          |
| `thrum sync force`                    | `sync.force` RPC                                              |
| `thrum sync status`                   | `sync.status` RPC                                             |
| `thrum agent delete NAME`             | `agent.delete` RPC                                            |
| `thrum agent cleanup`                 | `agent.cleanup` RPC                                           |

### For the Web UI

| Feature                | Daemon Feature Used                |
| ---------------------- | ---------------------------------- |
| Real-time message feed | WebSocket + `notification.message` |
| Agent activity         | `agent.listContext` RPC            |
| Unread counts          | `message.list` with `unread: true` |
| Live updates           | WebSocket notifications            |

### For MCP Integration

`thrum mcp serve` runs an MCP server on stdio (JSON-RPC over stdin/stdout),
enabling LLM agents to communicate via native MCP tools:

| MCP Tool              | Description                                                                   |
| --------------------- | ----------------------------------------------------------------------------- |
| `send_message`        | Send a message to another agent, role, or group                               |
| `check_messages`      | Poll for unread messages mentioning this agent, auto-marks read               |
| `wait_for_message`    | Block until a message arrives (WebSocket push) or timeout                     |
| `list_agents`         | List registered agents with active/offline status                             |
| `broadcast_message`   | Send to all agents (convenience wrapper around `send_message` to `@everyone`) |
| `create_group`        | Create a named group                                                          |
| `delete_group`        | Delete a group                                                                |
| `add_group_member`    | Add member to group                                                           |
| `remove_group_member` | Remove member from group                                                      |
| `list_groups`         | List all groups                                                               |
| `get_group`           | Get group details with optional expansion                                     |

Configure in Claude Code&#x27;s `.claude/settings.json`:

```json
{
  &quot;</span>mcpServers<span class="hljs-string">&quot;: {
    &quot;</span>thrum<span class="hljs-string">&quot;: {
      &quot;</span><span class="hljs-keyword">type</span><span class="hljs-string">&quot;: &quot;</span>stdio<span class="hljs-string">&quot;,
      &quot;</span>command<span class="hljs-string">&quot;: &quot;</span>thrum<span class="hljs-string">&quot;,
      &quot;</span>args<span class="hljs-string">&quot;: [&quot;</span>mcp<span class="hljs-string">&quot;, &quot;</span>serve<span class="hljs-string">&quot;]
    }
  }
}
```text

Use `--agent-id NAME` to override the agent identity, or set `THRUM_NAME` env
var. The MCP server connects to the daemon via Unix socket for RPC and WebSocket
for real-time push notifications via the `wait_for_message` tool.

## Getting Started

### Quick Start

```bash
# 1. Initialize in your project
cd your-project
thrum init

# 2. Start the daemon
thrum daemon start

# 3. Register, start session, and set intent in one step
thrum quickstart --name myagent --role implementer --module feature --intent &quot;</span>Working on feature X<span class="hljs-string">&quot;

# 4. Send your first message
thrum send &quot;</span>Starting work on feature X<span class="hljs-string">&quot; --scope module:feature

# 5. Subscribe to your module
thrum subscribe --scope module:feature
```text

### Check What Other Agents Are Working On

```bash
# List all agent work contexts
thrum agent list --context

# Output:
# AGENT      BRANCH         UNMERGED  FILES
# furiosa    feature/auth   3         src/auth.go, src/auth_test.go
# maximus    feature/db     1         internal/db/schema.go
```text

### Monitor Messages in Real-Time

```bash
# Wait for relevant messages
thrum wait --scope module:feature --timeout 5m
```text

## Documentation Index

| Document                                    | Description                                     |
| ------------------------------------------- | ----------------------------------------------- |
| [Philosophy](philosophy.md)                 | Why Thrum exists and how it thinks about agents |
| [Quickstart Guide](quickstart.md)           | 5-minute getting started                        |
| [Daemon Architecture](daemon.md)            | Technical daemon internals                      |
| [RPC API Reference](rpc-api.md)             | All RPC methods                                 |
| [Sync Protocol](sync.md)                    | Git synchronization details                     |
| [WebSocket API](api/websocket.md)           | WebSocket-specific docs                         |
| [Event Streaming](event-streaming.md)       | Notifications and subscriptions                 |
| [CLI Reference](cli.md)                     | All CLI commands                                |
| [Identity System](identity.md)              | Agent identity and registration                 |
| [Context Management](context.md)            | Agent context storage and persistence           |
| [Multi-Agent Support](multi-agent.md)       | Groups, runtime presets, and team coordination  |
| [Tailscale Sync](tailscale-sync.md)         | Cross-machine sync via Tailscale with security  |
| [Agent Coordination](agent-coordination.md) | Multi-agent workflows and Beads integration     |
| [Workflow Templates](workflow-templates.md) | Three-phase agent development templates         |
| [Architecture](architecture.md)             | Foundation packages                             |

## Design Principles

### You Stay in Control

Thrum is infrastructure you can inspect, not a service you depend on. Everything
is files, Git branches, and a local daemon. See
[Why Thrum Exists](philosophy.md) for the full philosophy.

### Offline-First

Everything works locally. Network is optional for sync.

### Git as Infrastructure

No additional servers. Uses existing Git authentication and hosting.

### Event Sourcing

JSONL log is the source of truth. SQLite is a rebuildable projection.

### Conflict-Free

Immutable events + unique IDs = conflict-free merging.

### Minimal Dependencies

Pure Go with minimal external packages. No CGO.

### Graceful Degradation

Network failures, missing remotes, and partial sync all handled gracefully.

## Summary

Thrum&#x27;s daemon is the foundation that enables:

- **Persistent communication** across session boundaries
- **Automatic synchronization** via Git (60s interval)
- **Real-time notifications** for targeted messaging
- **Work context visibility** so agents know what others are doing
- **Multiple access methods** (CLI, WebSocket, MCP)
- **Full message lifecycle** (get, edit, delete, mark-read)
- **Coordination shortcuts** (who-has, ping, quickstart, overview)
- **Agent naming** with human-readable identities and cleanup
- **Daemon lifecycle hardening** (flock, JSON PID, defer cleanup)

The CLI, Web UI, and MCP server are all thin clients that communicate through
the daemon. This architecture ensures consistency, enables real-time updates,
and provides a single point for synchronization and coordination.</span></code></pre>

    </div>
    <p style="margin-top:2rem"><a href="../docs.html#overview.html">&larr; View in documentation</a></p>
  </main>
  <script>
    // Redirect browsers to the SPA for full navigation experience.
    // Crawlers (which don't execute JS) will index the static content above.
    if (window.location.search.indexOf('nospa') === -1) {
      window.location.replace('../docs.html#overview.html');
    }
  </script>
</body>
</html>