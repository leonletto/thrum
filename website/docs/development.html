<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Development Guide — Thrum</title>
  <meta name="description" content="Setup, testing, building, contributing - complete guide for developing and extending Thrum">
  <!-- Open Graph -->
  <meta property="og:type" content="article">
  <meta property="og:title" content="Development Guide — Thrum">
  <meta property="og:description" content="Setup, testing, building, contributing - complete guide for developing and extending Thrum">
  <meta property="og:url" content="https://leonletto.github.io/thrum/docs/development.html">
  <meta property="og:site_name" content="Thrum">
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Development Guide — Thrum">
  <meta name="twitter:description" content="Setup, testing, building, contributing - complete guide for developing and extending Thrum">
  <!-- Canonical: SPA is the primary URL -->
  <link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#development.html">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x26A1;</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/theme.css">
  <link rel="stylesheet" href="../css/docs.css">
  <script>
    (function(){var t=localStorage.getItem('thrum-theme');if(t){document.documentElement.setAttribute('data-theme',t)}else if(window.matchMedia&&window.matchMedia('(prefers-color-scheme:light)').matches){document.documentElement.setAttribute('data-theme','light')}else{document.documentElement.setAttribute('data-theme','dark')}})();
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <nav class="header-nav">
        <a href="../index.html" class="logo">
          <span class="logo-glyph">&gt;_</span>
          <span class="logo-text">thrum</span>
        </a>
        <div class="nav-links">
          <a href="../index.html" class="nav-link">Home</a>
          <a href="../docs.html" class="nav-link nav-link-active">Docs</a>
          <a href="../about.html" class="nav-link">About</a>
          <a href="https://github.com/leonletto/thrum" class="nav-link nav-link-external" target="_blank" rel="noopener">GitHub</a>
        </div>
      </nav>
    </div>
  </header>
  <main class="docs-content" style="max-width:48rem;margin:2rem auto;padding:0 1.5rem">
    <div class="docs-content-inner">
<h1>Thrum Development Guide</h1>
<p>This guide explains how to set up and work with the Thrum codebase.</p>
<h2>Prerequisites</h2>
<ul>
<li><strong>Go 1.25+</strong>: <a href="https://go.dev/dl/">Install Go</a></li>
<li><strong>Node.js 18+</strong> and <strong>pnpm</strong>: Required for building the UI monorepo</li>
<li><strong>Make</strong>: Build automation</li>
<li><strong>Playwright</strong>: E2E testing (<code>npx playwright install chromium</code>)</li>
<li><strong>golangci-lint</strong>: Code linting (auto-installed by <code>make lint</code>)</li>
<li><strong>markdownlint-cli</strong>: Markdown linting (auto-installed by <code>make lint-md</code>)</li>
</ul>
<h2>Quick Start</h2>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Clone repository</span>
git <span class="hljs-built_in">clone</span> &lt;repo-url&gt;
<span class="hljs-built_in">cd</span> thrum

<span class="hljs-comment"># Install dependencies</span>
go mod download
<span class="hljs-built_in">cd</span> ui &amp;&amp; pnpm install &amp;&amp; <span class="hljs-built_in">cd</span> ..

<span class="hljs-comment"># Run Go tests</span>
make <span class="hljs-built_in">test</span>

<span class="hljs-comment"># Full build (UI + Go binary) and install to ~/.local/bin</span>
make install

<span class="hljs-comment"># Start daemon and verify</span>
thrum daemon start
thrum daemon status</code></pre>
<h2>Project Structure</h2>
<pre><code>thrum/
├── cmd/
│   └── thrum/               # CLI entry point
│       ├── main.go          # Cobra command tree (all CLI commands)
│       └── mcp.go           # MCP server command
├── internal/                # Private packages
│   ├── cli/                 # CLI business logic (one file per command)
│   ├── config/              # Configuration loading and identity files
│   ├── daemon/              # Daemon core
│   │   ├── cleanup/         # Agent work context cleanup
│   │   ├── rpc/             # JSON-RPC 2.0 method handlers
│   │   ├── state/           # Persistent state (JSONL + SQLite)
│   │   ├── server.go        # Unix socket server
│   │   ├── lifecycle.go     # Signal handling, defer cleanup, flock
│   │   ├── pidfile.go       # JSON PID file with repo-affinity metadata
│   │   ├── client.go        # Client library
│   │   ├── flock.go         # FileLock struct definition
│   │   ├── flock_unix.go    # flock() implementation (Unix)
│   │   ├── flock_other.go   # No-op stubs (non-Unix)
│   │   └── testutil_test.go # StartTestDaemon() helper
│   ├── gitctx/              # Git-derived work context (branch, uncommitted files)
│   ├── identity/            # ID generation (ULID-based: repo, agent, session, message, event)
│   ├── jsonl/               # JSONL reader/writer with file locking
│   ├── mcp/                 # MCP stdio server (5 tools, WebSocket waiter)
│   ├── paths/               # Path resolution, .thrum/redirect, sync worktree path
│   ├── projection/          # JSONL to SQLite event replay (projector)
│   ├── schema/              # SQLite schema, DDL, and migrations (v7)
│   ├── subscriptions/       # Notification dispatcher and subscription service
│   ├── sync/                # Sync engine (loop, merge, push, dedup, branch management)
│   ├── transport/           # Transport abstraction layer
│   ├── types/               # Shared event type definitions
│   ├── web/                 # Embedded SPA (//go:embed React build)
│   └── websocket/           # WebSocket server, connections, registry
├── ui/                      # UI monorepo (Turborepo + pnpm workspaces)
│   ├── packages/
│   │   ├── shared-logic/    # Framework-agnostic business logic (TanStack, Zod)
│   │   ├── web-app/         # React web application (Vite, shadcn/ui)
│   │   └── tui-app/         # Terminal UI (Ink, placeholder)
│   ├── turbo.json           # Turborepo configuration
│   ├── pnpm-workspace.yaml  # pnpm workspace configuration
│   └── package.json         # Root monorepo scripts
├── tests/
│   └── e2e/                 # Playwright E2E tests (13 spec files)
│       ├── helpers/         # Test helpers (CLI wrapper, fixtures)
│       ├── global-setup.ts  # Daemon start + agent registration
│       └── global-teardown.ts
├── scripts/                 # Setup scripts
│   ├── setup-worktree-thrum.sh  # Configure .thrum/redirect for worktrees
│   └── setup-worktree-beads.sh  # Configure .beads/redirect for worktrees
├── docs/                    # User documentation
├── dev-docs/                # Design documents and prompts
├── .agents/                 # Agent workflow instructions (hidden directory)
├── .beads/                  # Issue tracking (beads)
├── Makefile                 # Build targets
├── go.mod                   # Go module (github.com/leonletto/thrum)
├── playwright.config.ts     # Playwright E2E configuration
└── llms.txt / llms-full.txt # Agent reference files</code></pre>
<h2>Development Workflow</h2>
<h3>1. Running Tests</h3>
<h4>Go Tests</h4>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Run all Go tests</span>
make <span class="hljs-built_in">test</span>

<span class="hljs-comment"># Run unit tests only (fast, skips integration)</span>
make test-unit

<span class="hljs-comment"># Run integration tests</span>
make test-integration

<span class="hljs-comment"># Run tests with verbose output</span>
make test-verbose

<span class="hljs-comment"># Run specific package tests</span>
go <span class="hljs-built_in">test</span> ./internal/config/... -v

<span class="hljs-comment"># Run with race detector</span>
go <span class="hljs-built_in">test</span> -race ./...</code></pre>
<h4>UI Tests</h4>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Run all UI tests (from monorepo root)</span>
<span class="hljs-built_in">cd</span> ui &amp;&amp; pnpm <span class="hljs-built_in">test</span>

<span class="hljs-comment"># Run web-app tests only</span>
<span class="hljs-built_in">cd</span> ui/packages/web-app &amp;&amp; pnpm <span class="hljs-built_in">test</span>

<span class="hljs-comment"># Run shared-logic tests only</span>
<span class="hljs-built_in">cd</span> ui/packages/shared-logic &amp;&amp; pnpm <span class="hljs-built_in">test</span>

<span class="hljs-comment"># Watch mode</span>
<span class="hljs-built_in">cd</span> ui/packages/web-app &amp;&amp; pnpm <span class="hljs-built_in">test</span>:watch

<span class="hljs-comment"># Coverage report</span>
<span class="hljs-built_in">cd</span> ui/packages/web-app &amp;&amp; pnpm <span class="hljs-built_in">test</span>:coverage</code></pre>
<h4>E2E Tests (Playwright)</h4>
<p>E2E tests require the daemon to be running and the binary to be built:</p>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Build and install</span>
make install

<span class="hljs-comment"># Start daemon</span>
thrum daemon start

<span class="hljs-comment"># Run all E2E tests (serial execution required)</span>
npx playwright <span class="hljs-built_in">test</span> --workers=1

<span class="hljs-comment"># Run a specific spec file</span>
npx playwright <span class="hljs-built_in">test</span> tests/e2e/messaging.spec.ts --workers=1

<span class="hljs-comment"># View HTML report</span>
npx playwright show-report</code></pre>
<p>The E2E test suite uses <code>global-setup.ts</code> to start the daemon and register a<br>test agent, and <code>global-teardown.ts</code> to stop the daemon after all tests<br>complete.</p>
<h3>2. Code Coverage</h3>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Generate Go coverage report</span>
make test-coverage
<span class="hljs-comment"># Report output: output/coverage.html</span></code></pre>
<h3>3. Linting</h3>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Run Go linter (auto-installs golangci-lint if missing)</span>
make lint

<span class="hljs-comment"># Auto-fix Go lint issues</span>
make lint-fix

<span class="hljs-comment"># Run Markdown linter</span>
make lint-md

<span class="hljs-comment"># Auto-fix Markdown issues</span>
make lint-md-fix

<span class="hljs-comment"># Run all linters (Go + Markdown)</span>
make lint-all</code></pre>
<h3>4. Formatting</h3>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Format Go code</span>
make <span class="hljs-built_in">fmt</span>

<span class="hljs-comment"># Format Markdown files (requires prettier)</span>
make fmt-md

<span class="hljs-comment"># Format all files (Go + Markdown)</span>
make fmt-all</code></pre>
<h3>5. Building</h3>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Full build: UI + Go binary</span>
make build
<span class="hljs-comment"># Output: ./bin/thrum</span>

<span class="hljs-comment"># Build Go binary only (skip UI rebuild, uses existing internal/web/dist/)</span>
make build-go

<span class="hljs-comment"># Build UI only (pnpm install + build, copies to internal/web/dist/)</span>
make build-ui

<span class="hljs-comment"># Full build + install to ~/.local/bin</span>
make install

<span class="hljs-comment"># Run built binary</span>
./bin/thrum</code></pre>
<p>The build embeds the React SPA into the Go binary via <code>//go:embed</code> in<br><code>internal/web/embed.go</code>. The <code>make build-ui</code> step copies the Vite build output<br>into <code>internal/web/dist/</code> so the Go embed directive can include it.</p>
<p>A <code>.gitkeep</code> file in <code>internal/web/dist/</code> ensures <code>go build</code> and <code>go vet</code> work<br>even when the UI has not been built.</p>
<h2>Makefile Targets</h2>
<table>
<thead>
<tr>
<th>Target</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>make help</code></td>
<td>Show all available targets (default)</td>
</tr>
<tr>
<td><code>make build</code></td>
<td>Full build: UI + Go binary</td>
</tr>
<tr>
<td><code>make build-ui</code></td>
<td>Build UI and copy to embed location</td>
</tr>
<tr>
<td><code>make build-go</code></td>
<td>Build Go binary only (skip UI rebuild)</td>
</tr>
<tr>
<td><code>make install</code></td>
<td>Full build and install to <code>~/.local/bin</code></td>
</tr>
<tr>
<td><code>make test</code></td>
<td>Run all Go tests</td>
</tr>
<tr>
<td><code>make test-unit</code></td>
<td>Run unit tests only (fast)</td>
</tr>
<tr>
<td><code>make test-integration</code></td>
<td>Run integration tests</td>
</tr>
<tr>
<td><code>make test-coverage</code></td>
<td>Generate coverage report to <code>output/</code></td>
</tr>
<tr>
<td><code>make test-verbose</code></td>
<td>Run tests with verbose output</td>
</tr>
<tr>
<td><code>make fmt</code></td>
<td>Format Go code</td>
</tr>
<tr>
<td><code>make fmt-md</code></td>
<td>Format Markdown files with prettier</td>
</tr>
<tr>
<td><code>make fmt-all</code></td>
<td>Format all files (Go + Markdown)</td>
</tr>
<tr>
<td><code>make lint</code></td>
<td>Run golangci-lint</td>
</tr>
<tr>
<td><code>make lint-fix</code></td>
<td>Run golangci-lint with auto-fix</td>
</tr>
<tr>
<td><code>make lint-md</code></td>
<td>Run markdownlint</td>
</tr>
<tr>
<td><code>make lint-md-fix</code></td>
<td>Run markdownlint with auto-fix</td>
</tr>
<tr>
<td><code>make lint-all</code></td>
<td>Run all linters (Go + Markdown)</td>
</tr>
<tr>
<td><code>make vet</code></td>
<td>Run <code>go vet</code></td>
</tr>
<tr>
<td><code>make tidy</code></td>
<td>Tidy Go dependencies</td>
</tr>
<tr>
<td><code>make clean</code></td>
<td>Remove build artifacts (<code>output/</code>, <code>bin/</code>, <code>dist/</code>)</td>
</tr>
<tr>
<td><code>make install-tools</code></td>
<td>Install dev tools (golangci-lint, markdownlint-cli)</td>
</tr>
<tr>
<td><code>make quick-check</code></td>
<td>Fast pre-commit checks: format, vet, test, build</td>
</tr>
<tr>
<td><code>make ci</code></td>
<td>Full CI checks: format-all, lint-all, vet, test, build</td>
</tr>
<tr>
<td><code>make pre-commit</code></td>
<td>Alias for <code>quick-check</code></td>
</tr>
<tr>
<td><code>make pre-push</code></td>
<td>Alias for <code>ci</code></td>
</tr>
</tbody></table>
<h2>Common Tasks</h2>
<h3>Adding a New Event Type</h3>
<ol>
<li>Define event struct in <code>internal/types/events.go</code></li>
<li>Add handler in <code>internal/projection/projector.go</code></li>
<li>Add case in the <code>Apply()</code> switch statement</li>
<li>Write tests in <code>internal/projection/projector_test.go</code></li>
</ol>
<p>Current event types handled by the projector:</p>
<ul>
<li><code>message.create</code>, <code>message.edit</code>, <code>message.delete</code></li>
<li><code>agent.register</code></li>
<li><code>agent.session.start</code>, <code>agent.session.end</code></li>
<li><code>agent.update</code></li>
</ul>
<p>Example:</p>
<pre><code class="language-go hljs"><span class="hljs-comment">// 1. Define event type in internal/types/events.go</span>
<span class="hljs-keyword">type</span> MyNewEvent <span class="hljs-keyword">struct</span> {
    BaseEvent
    MyField <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;my_field&quot;`</span>
}

<span class="hljs-comment">// 2. Add handler in internal/projection/projector.go</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Projector)</span></span> applyMyNew(data json.RawMessage) <span class="hljs-type">error</span> {
    <span class="hljs-keyword">var</span> event types.MyNewEvent
    <span class="hljs-keyword">if</span> err := json.Unmarshal(data, &amp;event); err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unmarshal my.new: %w&quot;</span>, err)
    }

    <span class="hljs-comment">// Insert/update database</span>
    _, err := p.db.Exec(<span class="hljs-string">`...`</span>)
    <span class="hljs-keyword">return</span> err
}

<span class="hljs-comment">// 3. Update switch in Apply()</span>
<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;my.new&quot;</span>:
    <span class="hljs-keyword">return</span> p.applyMyNew(event)</code></pre>
<h3>Modifying Database Schema</h3>
<ol>
<li>Update table definitions in <code>internal/schema/schema.go</code></li>
<li>Increment <code>CurrentVersion</code> constant (currently v7)</li>
<li>Add migration logic in the <code>Migrate()</code> function</li>
<li>Write tests for the new schema</li>
<li>Update <code>docs/architecture.md</code></li>
</ol>
<h3>Testing with Temporary Databases</h3>
<pre><code class="language-go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMyFeature</span><span class="hljs-params">(t *testing.T)</span></span> {
    <span class="hljs-comment">// Create temp database</span>
    tmpDir := t.TempDir()
    dbPath := filepath.Join(tmpDir, <span class="hljs-string">&quot;test.db&quot;</span>)

    db, _ := schema.OpenDB(dbPath)
    <span class="hljs-keyword">defer</span> db.Close()

    schema.InitDB(db)

    <span class="hljs-comment">// Test your feature</span>
    <span class="hljs-comment">// ...</span>
}</code></pre>
<h3>Adding a New RPC Method</h3>
<ol>
<li>Create handler file in <code>internal/daemon/rpc/</code>:</li>
</ol>
<pre><code class="language-go hljs"><span class="hljs-comment">// internal/daemon/rpc/mymethod.go</span>
<span class="hljs-keyword">package</span> rpc

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">&quot;context&quot;</span>
    <span class="hljs-string">&quot;encoding/json&quot;</span>
)

<span class="hljs-keyword">type</span> MyMethodHandler <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">// dependencies</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMyMethodHandler</span><span class="hljs-params">(deps...)</span></span> *MyMethodHandler {
    <span class="hljs-keyword">return</span> &amp;MyMethodHandler{...}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MyMethodHandler)</span></span> Handle(ctx context.Context, params json.RawMessage) (any, <span class="hljs-type">error</span>) {
    <span class="hljs-comment">// Parse params</span>
    <span class="hljs-keyword">var</span> args MyMethodArgs
    <span class="hljs-keyword">if</span> err := json.Unmarshal(params, &amp;args); err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;invalid params: %w&quot;</span>, err)
    }

    <span class="hljs-comment">// Implementation</span>
    result := MyMethodResponse{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">return</span> result, <span class="hljs-literal">nil</span>
}</code></pre>
<ol start="2">
<li><p>Add tests in <code>internal/daemon/rpc/mymethod_test.go</code></p>
</li>
<li><p>Register in daemon startup (in <code>cmd/thrum/main.go</code>):</p>
</li>
</ol>
<pre><code class="language-go hljs">myMethodHandler := rpc.NewMyMethodHandler()
server.RegisterHandler(<span class="hljs-string">&quot;mymethod&quot;</span>, myMethodHandler.Handle)</code></pre>
<ol start="4">
<li>Update documentation in <code>docs/rpc-api.md</code></li>
</ol>
<h2>Environment Variables</h2>
<p>Configuration is resolved in priority order:</p>
<ol>
<li><code>THRUM_NAME</code> env var to select which identity file (highest priority)</li>
<li>Environment variables: <code>THRUM_ROLE</code>, <code>THRUM_MODULE</code>, <code>THRUM_DISPLAY</code></li>
<li>CLI flags (<code>--role</code>, <code>--module</code>, <code>--name</code>)</li>
<li>Identity file in <code>.thrum/identities/{name}.json</code></li>
<li>Error if required fields are missing</li>
</ol>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Select a named agent identity</span>
<span class="hljs-built_in">export</span> THRUM_NAME=furiosa

<span class="hljs-comment"># Or set agent properties directly</span>
<span class="hljs-built_in">export</span> THRUM_ROLE=implementer
<span class="hljs-built_in">export</span> THRUM_MODULE=auth
<span class="hljs-built_in">export</span> THRUM_DISPLAY=<span class="hljs-string">&quot;Auth Agent&quot;</span></code></pre>
<p>Identity files are stored per-agent at <code>.thrum/identities/{name}.json</code> and<br>contain repo ID, agent config, worktree name, and metadata.</p>
<h2>Storage Layout</h2>
<p>Thrum uses a split storage model:</p>
<pre><code>.git/thrum-sync/a-sync/              # Sync worktree (a-sync orphan branch)
├── events.jsonl                     # Agent lifecycle events (register, session, update)
└── messages/                        # Per-agent message files (sharded)
    ├── furiosa.jsonl                # Messages authored by agent &quot;furiosa&quot;
    └── coordinator.jsonl            # Messages authored by agent &quot;coordinator&quot;

.thrum/                              # Runtime directory (gitignored)
├── var/
│   ├── messages.db                  # SQLite projection cache (rebuilt from JSONL)
│   ├── thrum.sock                   # Unix socket for daemon RPC
│   ├── thrum.pid                    # JSON PID file with repo-affinity metadata
│   └── ws.port                      # WebSocket port file (default 9999)
├── identities/                      # Per-agent identity files
│   └── {name}.json                  # Agent identity (repo_id, role, module, etc.)
└── redirect                         # Points to main worktree .thrum/ (feature worktrees only)</code></pre>
<h3>Inspecting JSONL Files</h3>
<pre><code class="language-bash hljs"><span class="hljs-comment"># View all events (agent lifecycle)</span>
<span class="hljs-built_in">cat</span> .git/thrum-sync/a-sync/events.jsonl | jq .

<span class="hljs-comment"># View messages for a specific agent</span>
<span class="hljs-built_in">cat</span> .git/thrum-sync/a-sync/messages/furiosa.jsonl | jq .

<span class="hljs-comment"># Filter by event type</span>
<span class="hljs-built_in">cat</span> .git/thrum-sync/a-sync/events.jsonl | jq <span class="hljs-string">&#x27;select(.type == &quot;agent.register&quot;)&#x27;</span>

<span class="hljs-comment"># Count events</span>
<span class="hljs-built_in">wc</span> -l .git/thrum-sync/a-sync/events.jsonl</code></pre>
<h3>Inspecting the SQLite Database</h3>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Open database</span>
sqlite3 .thrum/var/messages.db

<span class="hljs-comment"># List tables</span>
.tables

<span class="hljs-comment"># Query messages</span>
SELECT * FROM messages LIMIT 10;

<span class="hljs-comment"># Check schema version</span>
SELECT * FROM schema_version;</code></pre>
<h2>Daemon Development</h2>
<h3>Daemon Architecture</h3>
<p>The daemon runs as a background service handling client connections via Unix<br>socket, with a WebSocket server and embedded SPA all on a single port (default<br>9999).</p>
<p><strong>Key components:</strong></p>
<ul>
<li><strong>Server</strong> (<code>internal/daemon/server.go</code>): JSON-RPC 2.0 over Unix socket</li>
<li><strong>Lifecycle</strong> (<code>internal/daemon/lifecycle.go</code>): Signal handling, defer cleanup<br>safety net, flock-based process detection</li>
<li><strong>PID file</strong> (<code>internal/daemon/pidfile.go</code>): JSON format with <code>PIDInfo</code> struct<br>(PID, repo path, socket path, started at). Backward-compatible reader falls<br>back to plain integer format.</li>
<li><strong>File lock</strong> (<code>internal/daemon/flock.go</code>, <code>flock_unix.go</code>): OS-level<br><code>flock()</code> on socket file. Auto-released on process death (even SIGKILL). No-op<br>stubs for non-Unix platforms.</li>
<li><strong>State</strong> (<code>internal/daemon/state/</code>): Manages JSONL writes (sharded per-agent)<br>and SQLite projection. <code>NewState(thrumDir, syncDir, repoID)</code> separates runtime<br>state from sync data.</li>
<li><strong>RPC handlers</strong> (<code>internal/daemon/rpc/</code>): Method implementations for agent,<br>session, message, thread, health, sync, subscribe, and user operations</li>
<li><strong>Client</strong> (<code>internal/daemon/client.go</code>): Connection library for CLI-to-daemon<br>communication</li>
<li><strong>WebSocket</strong> (<code>internal/websocket/</code>): Server, connection registry, event<br>streaming</li>
<li><strong>Web</strong> (<code>internal/web/embed.go</code>): Embedded SPA served at <code>/</code> on the same port<br>as WebSocket (<code>/ws</code>)</li>
</ul>
<p>See <code>docs/daemon.md</code> for detailed architecture.</p>
<h3>Running the Daemon</h3>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Start daemon (background, auto-creates sync worktree)</span>
thrum daemon start

<span class="hljs-comment"># Start in foreground (for debugging)</span>
thrum daemon start --foreground

<span class="hljs-comment"># Check status (shows PID, repo path, WebSocket port)</span>
thrum daemon status

<span class="hljs-comment"># Stop daemon</span>
thrum daemon stop

<span class="hljs-comment"># Auto-start (happens automatically via any CLI command)</span>
thrum send <span class="hljs-string">&quot;Hello&quot;</span> --to @coordinator</code></pre>
<h3>Testing Daemon Code</h3>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Run daemon tests</span>
go <span class="hljs-built_in">test</span> ./internal/daemon/...

<span class="hljs-comment"># With coverage</span>
go <span class="hljs-built_in">test</span> -cover ./internal/daemon/...

<span class="hljs-comment"># RPC handler tests</span>
go <span class="hljs-built_in">test</span> ./internal/daemon/rpc/... -v

<span class="hljs-comment"># State tests</span>
go <span class="hljs-built_in">test</span> ./internal/daemon/state/... -v</code></pre>
<p>Use the <code>StartTestDaemon()</code> helper in <code>internal/daemon/testutil_test.go</code> for<br>integration tests. It provides automatic <code>t.Cleanup()</code> with force-kill to<br>prevent test orphan processes on timeout or panic.</p>
<h3>Debugging Daemon</h3>
<p><strong>Check if daemon is running:</strong></p>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Check PID file (JSON format)</span>
<span class="hljs-built_in">cat</span> .thrum/var/thrum.pid | jq .

<span class="hljs-comment"># Check process</span>
ps aux | grep thrum

<span class="hljs-comment"># Check socket</span>
<span class="hljs-built_in">ls</span> -l .thrum/var/thrum.sock</code></pre>
<p><strong>Test RPC calls manually:</strong></p>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Using netcat</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;health&quot;,&quot;id&quot;:1}&#x27;</span> | nc -U .thrum/var/thrum.sock</code></pre>
<p><strong>View daemon logs:</strong></p>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Run daemon in foreground for debugging</span>
thrum daemon start --foreground
<span class="hljs-comment"># Logs appear in stdout/stderr</span></code></pre>
<p><strong>Clean restart:</strong></p>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Stop daemon</span>
thrum daemon stop

<span class="hljs-comment"># Remove stale files if needed</span>
<span class="hljs-built_in">rm</span> .thrum/var/thrum.sock
<span class="hljs-built_in">rm</span> .thrum/var/thrum.pid

<span class="hljs-comment"># Restart</span>
thrum daemon start</code></pre>
<h3>Common Daemon Issues</h3>
<p><strong>Socket path too long:</strong></p>
<ul>
<li>Unix sockets limited to ~104 characters</li>
<li>Use shorter temp directory paths in tests</li>
<li>Example: <code>filepath.Join(tmpDir, &quot;d.sock&quot;)</code> not<br><code>filepath.Join(tmpDir, &quot;.thrum&quot;, &quot;var&quot;, &quot;thrum.sock&quot;)</code></li>
</ul>
<p><strong>Permission denied:</strong></p>
<ul>
<li>Socket should be 0600 (owner only)</li>
<li>Check <code>.thrum/var/</code> directory permissions</li>
</ul>
<p><strong>Bind: address already in use:</strong></p>
<ul>
<li>Another daemon already running</li>
<li>Pre-startup duplicate detection validates no existing daemon serves this repo</li>
<li>Check PID file and kill process</li>
<li>Remove stale socket file</li>
</ul>
<p><strong>Connection refused:</strong></p>
<ul>
<li>Daemon not running</li>
<li>Check PID file exists</li>
<li>Verify socket file exists</li>
</ul>
<h2>MCP Server Development</h2>
<p>The MCP server (<code>thrum mcp serve</code>) provides native MCP tools for Claude Code<br>agents instead of shelling out to the CLI. It uses stdio transport (JSON-RPC<br>over stdin/stdout).</p>
<p><strong>Key files:</strong></p>
<ul>
<li><code>internal/mcp/server.go</code>: Server skeleton and tool registration</li>
<li><code>internal/mcp/tools.go</code>: Tool handler implementations</li>
<li><code>internal/mcp/types.go</code>: Request/response type definitions</li>
<li><code>internal/mcp/waiter.go</code>: WebSocket-based blocking message waiter</li>
<li><code>cmd/thrum/mcp.go</code>: <code>thrum mcp serve</code> Cobra command</li>
</ul>
<p><strong>MCP Tools (5):</strong></p>
<table>
<thead>
<tr>
<th>Tool</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>send_message</code></td>
<td>Send a message to another agent via @role addressing</td>
</tr>
<tr>
<td><code>check_messages</code></td>
<td>Poll for unread messages mentioning this agent</td>
</tr>
<tr>
<td><code>wait_for_message</code></td>
<td>Block until a message arrives (WebSocket push) or timeout</td>
</tr>
<tr>
<td><code>list_agents</code></td>
<td>List registered agents with active/offline status</td>
</tr>
<tr>
<td><code>broadcast_message</code></td>
<td>Send to all active agents with exclude filters</td>
</tr>
</tbody></table>
<p><strong>Architecture:</strong></p>
<ul>
<li>Per-call <code>cli.Client</code> creation (thread-safe; Unix socket connections are<br>cheap)</li>
<li>WebSocket waiter with atomic incrementing JSON-RPC IDs</li>
<li>Identity resolved at startup from <code>.thrum/identities/{name}.json</code></li>
<li><code>THRUM_NAME</code> env var or <code>--agent-id</code> flag for multi-agent worktrees</li>
</ul>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Start MCP server</span>
thrum mcp serve

<span class="hljs-comment"># Override agent identity</span>
thrum mcp serve --agent-id furiosa</code></pre>
<h2>Sync Engine</h2>
<p>The sync engine runs in the daemon, performing fetch/merge/push every 60 seconds<br>(configurable via <code>--sync-interval</code>).</p>
<p><strong>Key files:</strong></p>
<ul>
<li><code>internal/sync/loop.go</code>: <code>SyncLoop</code> with periodic and manual sync triggers</li>
<li><code>internal/sync/merge.go</code>: JSONL merge with deduplication (ULID event_id)</li>
<li><code>internal/sync/push.go</code>: Git push to remote</li>
<li><code>internal/sync/branch.go</code>: Safe orphan branch creation via <code>git commit-tree</code> +<br><code>git update-ref</code>, sync worktree with sparse checkout, 4-level health checks</li>
<li><code>internal/sync/dedup.go</code>: Event deduplication by event_id</li>
</ul>
<p><strong>Sync worktree location:</strong> <code>.git/thrum-sync/a-sync/</code> (uses <code>git-common-dir</code> for<br>nested worktree support).</p>
<p><strong>Sparse checkout patterns:</strong> <code>/events.jsonl</code>, <code>/messages/</code>, <code>/messages.jsonl</code><br>(migration compat).</p>
<h2>Worktree Setup</h2>
<p>Thrum supports multiple git worktrees sharing a single daemon and data store via<br>the <code>.thrum/redirect</code> mechanism. Feature worktrees point to the main worktree&#39;s<br><code>.thrum/</code> directory so all worktrees share one daemon, one SQLite database, and<br>one set of JSONL files.</p>
<h3>Setting Up a Worktree</h3>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Option 1: Use the thrum setup command</span>
thrum setup /path/to/worktree

<span class="hljs-comment"># Option 2: Use the setup script</span>
./scripts/setup-worktree-thrum.sh /path/to/worktree

<span class="hljs-comment"># Option 3: Manual setup</span>
<span class="hljs-built_in">mkdir</span> -p /path/to/worktree/.thrum/identities
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/path/to/main/repo/.thrum&quot;</span> &gt; /path/to/worktree/.thrum/redirect</code></pre>
<h3>Beads Issue Tracking for Worktrees</h3>
<p>All worktrees should share the same beads issue database:</p>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Use the setup script</span>
./scripts/setup-worktree-beads.sh /path/to/worktree

<span class="hljs-comment"># Or manual setup</span>
<span class="hljs-built_in">mkdir</span> -p /path/to/worktree/.beads
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/path/to/main/repo/.beads&quot;</span> &gt; /path/to/worktree/.beads/redirect

<span class="hljs-comment"># Verify</span>
<span class="hljs-built_in">cd</span> /path/to/worktree &amp;&amp; bd <span class="hljs-built_in">where</span></code></pre>
<h2>Testing Best Practices</h2>
<h3>1. Use Table-Driven Tests</h3>
<pre><code class="language-go hljs">tests := []<span class="hljs-keyword">struct</span> {
    name <span class="hljs-type">string</span>
    input <span class="hljs-type">string</span>
    want <span class="hljs-type">string</span>
}{
    {<span class="hljs-string">&quot;case 1&quot;</span>, <span class="hljs-string">&quot;input1&quot;</span>, <span class="hljs-string">&quot;expected1&quot;</span>},
    {<span class="hljs-string">&quot;case 2&quot;</span>, <span class="hljs-string">&quot;input2&quot;</span>, <span class="hljs-string">&quot;expected2&quot;</span>},
}

<span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests {
    t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> {
        got := MyFunction(tt.input)
        <span class="hljs-keyword">if</span> got != tt.want {
            t.Errorf(<span class="hljs-string">&quot;got %v, want %v&quot;</span>, got, tt.want)
        }
    })
}</code></pre>
<h3>2. Clean Up Resources</h3>
<pre><code class="language-go hljs"><span class="hljs-comment">// Use t.TempDir() for automatic cleanup</span>
tmpDir := t.TempDir()

<span class="hljs-comment">// Or defer cleanup</span>
db, _ := schema.OpenDB(dbPath)
<span class="hljs-keyword">defer</span> db.Close()</code></pre>
<h3>3. Test Error Cases</h3>
<pre><code class="language-go hljs"><span class="hljs-comment">// Test both happy path and error cases</span>
_, err := MyFunction(invalidInput)
<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
    t.Error(<span class="hljs-string">&quot;expected error, got nil&quot;</span>)
}</code></pre>
<h3>4. Use StartTestDaemon for Integration Tests</h3>
<pre><code class="language-go hljs"><span class="hljs-comment">// Automatically cleans up on test completion (even on panic/timeout)</span>
daemon := StartTestDaemon(t, tmpDir)
<span class="hljs-keyword">defer</span> daemon.Stop()</code></pre>
<h2>Code Style</h2>
<ul>
<li><strong>Formatting</strong>: Use <code>go fmt</code> (or <code>gofmt -s</code>)</li>
<li><strong>Imports</strong>: Group stdlib, external, internal</li>
<li><strong>Comments</strong>: Document exported functions and types</li>
<li><strong>Error messages</strong>: Lowercase, no punctuation, wrap with <code>fmt.Errorf</code></li>
<li><strong>Variable names</strong>: Short, descriptive (e.g., <code>db</code>, <code>cfg</code>, <code>msg</code>)</li>
</ul>
<h2>Git Workflow</h2>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Create feature branch</span>
git checkout -b feature/my-feature

<span class="hljs-comment"># Make changes and test</span>
go <span class="hljs-built_in">test</span> ./...

<span class="hljs-comment"># Commit</span>
git add .
git commit -m <span class="hljs-string">&quot;Add my feature&quot;</span>

<span class="hljs-comment"># Push</span>
git push origin feature/my-feature

<span class="hljs-comment"># Create PR</span>
gh <span class="hljs-built_in">pr</span> create</code></pre>
<h2>Troubleshooting</h2>
<h3>&quot;no such table&quot; error</h3>
<p>The SQLite projection database is a rebuild-able cache. Delete it and restart<br>the daemon to rebuild from JSONL:</p>
<pre><code class="language-bash hljs"><span class="hljs-built_in">rm</span> .thrum/var/messages.db
thrum daemon stop
thrum daemon start</code></pre>
<h3>&quot;cannot open file&quot; error</h3>
<p>Check file permissions and directory existence:</p>
<pre><code class="language-bash hljs"><span class="hljs-built_in">ls</span> -la .thrum/
<span class="hljs-built_in">ls</span> -la .thrum/var/</code></pre>
<h3>Tests fail with &quot;database is locked&quot;</h3>
<p>Close any open SQLite connections or delete WAL files:</p>
<pre><code class="language-bash hljs"><span class="hljs-built_in">rm</span> .thrum/var/*.db-wal
<span class="hljs-built_in">rm</span> .thrum/var/*.db-shm</code></pre>
<h3>Daemon won&#39;t start (duplicate detection)</h3>
<p>The daemon validates no existing instance serves the same repository before<br>starting. Check for a stale PID file:</p>
<pre><code class="language-bash hljs"><span class="hljs-built_in">cat</span> .thrum/var/thrum.pid | jq .
<span class="hljs-comment"># If the process is dead, remove the PID file</span>
<span class="hljs-built_in">rm</span> .thrum/var/thrum.pid
thrum daemon start</code></pre>
<h3><code>go build</code> fails with embed error</h3>
<p>If the UI has not been built, <code>internal/web/dist/</code> needs at least a <code>.gitkeep</code><br>file:</p>
<pre><code class="language-bash hljs"><span class="hljs-built_in">touch</span> internal/web/dist/.gitkeep</code></pre>
<p>Or build the UI first: <code>make build-ui</code></p>
<h2>Key Dependencies</h2>
<table>
<thead>
<tr>
<th>Dependency</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/spf13/cobra">cobra</a></td>
<td>CLI command framework</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/modernc.org/sqlite">modernc.org/sqlite</a></td>
<td>Pure Go SQLite driver</td>
</tr>
<tr>
<td><a href="https://github.com/oklog/ulid">oklog/ulid</a></td>
<td>ULID generation for event IDs</td>
</tr>
<tr>
<td><a href="https://github.com/gorilla/websocket">gorilla/websocket</a></td>
<td>WebSocket server</td>
</tr>
<tr>
<td><a href="https://github.com/modelcontextprotocol/go-sdk">go-sdk (MCP)</a></td>
<td>MCP server SDK</td>
</tr>
</tbody></table>
<h2>Resources</h2>
<ul>
<li><strong>Architecture</strong>: <code>docs/architecture.md</code></li>
<li><strong>Daemon Architecture</strong>: <code>docs/daemon.md</code></li>
<li><strong>RPC API Reference</strong>: <code>docs/rpc-api.md</code></li>
<li><strong>Sync Design</strong>: <code>docs/sync.md</code></li>
<li><strong>Quickstart Guide</strong>: <code>docs/quickstart.md</code></li>
<li><strong>CLI Reference</strong>: <code>docs/cli.md</code></li>
<li><strong>Identity System</strong>: <code>docs/identity.md</code></li>
<li><strong>Agent Reference</strong>: <code>llms.txt</code> (concise) and <code>llms-full.txt</code> (detailed)</li>
</ul>

    </div>
    <p style="margin-top:2rem"><a href="../docs.html#development.html">&larr; View in documentation</a></p>
  </main>
  <script>
    // Redirect browsers to the SPA for full navigation experience.
    // Crawlers (which don't execute JS) will index the static content above.
    if (window.location.search.indexOf('nospa') === -1) {
      window.location.replace('../docs.html#development.html');
    }
  </script>
</body>
</html>