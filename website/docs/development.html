<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Development Guide — Thrum</title>
  <meta name="description" content="Setup, testing, building, contributing - complete guide for developing and extending Thrum">
  <!-- Open Graph -->
  <meta property="og:type" content="article">
  <meta property="og:title" content="Development Guide — Thrum">
  <meta property="og:description" content="Setup, testing, building, contributing - complete guide for developing and extending Thrum">
  <meta property="og:url" content="https://leonletto.github.io/thrum/docs/development.html">
  <meta property="og:site_name" content="Thrum">
  <meta property="og:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Development Guide — Thrum">
  <meta name="twitter:description" content="Setup, testing, building, contributing - complete guide for developing and extending Thrum">
  <meta name="twitter:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <!-- Canonical: SPA is the primary URL -->
  <link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#development.html">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x26A1;</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/theme.css">
  <link rel="stylesheet" href="../css/docs.css">
  <script>
    (function(){var t=localStorage.getItem('thrum-theme');if(t){document.documentElement.setAttribute('data-theme',t)}else if(window.matchMedia&&window.matchMedia('(prefers-color-scheme:light)').matches){document.documentElement.setAttribute('data-theme','light')}else{document.documentElement.setAttribute('data-theme','dark')}})();
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <nav class="header-nav">
        <a href="../index.html" class="logo">
          <span class="logo-glyph">&gt;_</span>
          <span class="logo-text">thrum</span>
        </a>
        <div class="nav-links">
          <a href="../index.html" class="nav-link">Home</a>
          <a href="../docs.html" class="nav-link nav-link-active">Docs</a>
          <a href="../about.html" class="nav-link">About</a>
          <a href="https://github.com/leonletto/thrum" class="nav-link nav-link-external" target="_blank" rel="noopener">GitHub</a>
        </div>
      </nav>
    </div>
  </header>
  <main class="docs-content" style="max-width:48rem;margin:2rem auto;padding:0 1.5rem">
    <div class="docs-content-inner">
<h2>Thrum Development Guide</h2>
<p>This guide explains how to set up and work with the Thrum codebase.</p>
<h2>Prerequisites</h2>
<ul>
<li><strong>Go 1.25+</strong>: <a href="https://go.dev/dl/">Install Go</a></li>
<li><strong>Node.js 18+</strong> and <strong>pnpm</strong>: Required for building the UI monorepo</li>
<li><strong>Make</strong>: Build automation</li>
<li><strong>Playwright</strong>: E2E testing (<code>npx playwright install chromium</code>)</li>
<li><strong>golangci-lint</strong>: Code linting (auto-installed by <code>make lint</code>)</li>
<li><strong>markdownlint-cli</strong>: Markdown linting (auto-installed by <code>make lint-md</code>)</li>
</ul>
<h2>Quick Start</h2>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Clone repository</span>
git <span class="hljs-built_in">clone</span> &lt;repo-url&gt;
<span class="hljs-built_in">cd</span> thrum

<span class="hljs-comment"># Install dependencies</span>
go mod download
<span class="hljs-built_in">cd</span> ui &amp;&amp; pnpm install &amp;&amp; <span class="hljs-built_in">cd</span> ..

<span class="hljs-comment"># Run Go tests</span>
make <span class="hljs-built_in">test</span>

<span class="hljs-comment"># Full build (UI + Go binary) and install to ~/.local/bin</span>
make install

<span class="hljs-comment"># Start daemon and verify</span>
thrum daemon start
thrum daemon status
```text

<span class="hljs-comment">## Project Structure</span>

```text
thrum/
├── cmd/
│   └── thrum/               <span class="hljs-comment"># CLI entry point</span>
│       ├── main.go          <span class="hljs-comment"># Cobra command tree (all CLI commands)</span>
│       └── mcp.go           <span class="hljs-comment"># MCP server command</span>
├── internal/                <span class="hljs-comment"># Private packages</span>
│   ├── cli/                 <span class="hljs-comment"># CLI business logic (one file per command)</span>
│   ├── config/              <span class="hljs-comment"># Configuration loading and identity files</span>
│   ├── daemon/              <span class="hljs-comment"># Daemon core</span>
│   │   ├── cleanup/         <span class="hljs-comment"># Agent work context cleanup</span>
│   │   ├── rpc/             <span class="hljs-comment"># JSON-RPC 2.0 method handlers</span>
│   │   ├── state/           <span class="hljs-comment"># Persistent state (JSONL + SQLite)</span>
│   │   ├── server.go        <span class="hljs-comment"># Unix socket server</span>
│   │   ├── lifecycle.go     <span class="hljs-comment"># Signal handling, defer cleanup, flock</span>
│   │   ├── pidfile.go       <span class="hljs-comment"># JSON PID file with repo-affinity metadata</span>
│   │   ├── client.go        <span class="hljs-comment"># Client library</span>
│   │   ├── flock.go         <span class="hljs-comment"># FileLock struct definition</span>
│   │   ├── flock_unix.go    <span class="hljs-comment"># flock() implementation (Unix)</span>
│   │   ├── flock_other.go   <span class="hljs-comment"># No-op stubs (non-Unix)</span>
│   │   └── testutil_test.go <span class="hljs-comment"># StartTestDaemon() helper</span>
│   ├── gitctx/              <span class="hljs-comment"># Git-derived work context (branch, uncommitted files)</span>
│   ├── identity/            <span class="hljs-comment"># ID generation (ULID-based: repo, agent, session, message, event)</span>
│   ├── jsonl/               <span class="hljs-comment"># JSONL reader/writer with file locking</span>
│   ├── mcp/                 <span class="hljs-comment"># MCP stdio server (5 tools, WebSocket waiter)</span>
│   ├── paths/               <span class="hljs-comment"># Path resolution, .thrum/redirect, sync worktree path</span>
│   ├── projection/          <span class="hljs-comment"># JSONL to SQLite event replay (projector)</span>
│   ├── schema/              <span class="hljs-comment"># SQLite schema, DDL, and migrations (v7)</span>
│   ├── subscriptions/       <span class="hljs-comment"># Notification dispatcher and subscription service</span>
│   ├── <span class="hljs-built_in">sync</span>/                <span class="hljs-comment"># Sync engine (loop, merge, push, dedup, branch management)</span>
│   ├── transport/           <span class="hljs-comment"># Transport abstraction layer</span>
│   ├── types/               <span class="hljs-comment"># Shared event type definitions</span>
│   ├── web/                 <span class="hljs-comment"># Embedded SPA (//go:embed React build)</span>
│   └── websocket/           <span class="hljs-comment"># WebSocket server, connections, registry</span>
├── ui/                      <span class="hljs-comment"># UI monorepo (Turborepo + pnpm workspaces)</span>
│   ├── packages/
│   │   ├── shared-logic/    <span class="hljs-comment"># Framework-agnostic business logic (TanStack, Zod)</span>
│   │   ├── web-app/         <span class="hljs-comment"># React web application (Vite, shadcn/ui)</span>
│   │   └── tui-app/         <span class="hljs-comment"># Terminal UI (Ink, placeholder)</span>
│   ├── turbo.json           <span class="hljs-comment"># Turborepo configuration</span>
│   ├── pnpm-workspace.yaml  <span class="hljs-comment"># pnpm workspace configuration</span>
│   └── package.json         <span class="hljs-comment"># Root monorepo scripts</span>
├── tests/
│   └── e2e/                 <span class="hljs-comment"># Playwright E2E tests (13 spec files)</span>
│       ├── helpers/         <span class="hljs-comment"># Test helpers (CLI wrapper, fixtures)</span>
│       ├── global-setup.ts  <span class="hljs-comment"># Daemon start + agent registration</span>
│       └── global-teardown.ts
├── scripts/                 <span class="hljs-comment"># Setup scripts</span>
│   ├── setup-worktree-thrum.sh  <span class="hljs-comment"># Configure .thrum/redirect for worktrees</span>
│   └── setup-worktree-beads.sh  <span class="hljs-comment"># Configure .beads/redirect for worktrees</span>
├── docs/                    <span class="hljs-comment"># User documentation</span>
├── dev-docs/                <span class="hljs-comment"># Design documents and prompts</span>
├── .agents/                 <span class="hljs-comment"># Agent workflow instructions (hidden directory)</span>
├── .beads/                  <span class="hljs-comment"># Issue tracking (beads)</span>
├── Makefile                 <span class="hljs-comment"># Build targets</span>
├── go.mod                   <span class="hljs-comment"># Go module (github.com/leonletto/thrum)</span>
├── playwright.config.ts     <span class="hljs-comment"># Playwright E2E configuration</span>
└── llms.txt / llms-full.txt <span class="hljs-comment"># Agent reference files</span>
```text

<span class="hljs-comment">## Development Workflow</span>

<span class="hljs-comment">### 1. Running Tests</span>

<span class="hljs-comment">#### Go Tests</span>

```bash
<span class="hljs-comment"># Run all Go tests</span>
make <span class="hljs-built_in">test</span>

<span class="hljs-comment"># Run unit tests only (fast, skips integration)</span>
make test-unit

<span class="hljs-comment"># Run integration tests</span>
make test-integration

<span class="hljs-comment"># Run tests with verbose output</span>
make test-verbose

<span class="hljs-comment"># Run specific package tests</span>
go <span class="hljs-built_in">test</span> ./internal/config/... -v

<span class="hljs-comment"># Run with race detector</span>
go <span class="hljs-built_in">test</span> -race ./...

<span class="hljs-comment"># Run resilience tests (requires build tag)</span>
go <span class="hljs-built_in">test</span> -tags=resilience ./internal/daemon/...
```text

**Resilience Test Suite (v0.4.3):**

The resilience <span class="hljs-built_in">test</span> suite includes 39 tests covering crash recovery, concurrent
access, and <span class="hljs-built_in">timeout</span> enforcement. These tests require the `-tags=resilience`
build flag:

- Crash recovery scenarios (daemon restart, state restoration)
- Concurrent access patterns (multiple goroutines, race conditions)
- Timeout enforcement (I/O timeouts, RPC timeouts, WebSocket timeouts)

Run the full resilience suite:

```bash
go <span class="hljs-built_in">test</span> -tags=resilience -v ./internal/daemon/resilience_test.go
```text

<span class="hljs-comment">#### UI Tests</span>

```bash
<span class="hljs-comment"># Run all UI tests (from monorepo root)</span>
<span class="hljs-built_in">cd</span> ui &amp;&amp; pnpm <span class="hljs-built_in">test</span>

<span class="hljs-comment"># Run web-app tests only</span>
<span class="hljs-built_in">cd</span> ui/packages/web-app &amp;&amp; pnpm <span class="hljs-built_in">test</span>

<span class="hljs-comment"># Run shared-logic tests only</span>
<span class="hljs-built_in">cd</span> ui/packages/shared-logic &amp;&amp; pnpm <span class="hljs-built_in">test</span>

<span class="hljs-comment"># Watch mode</span>
<span class="hljs-built_in">cd</span> ui/packages/web-app &amp;&amp; pnpm <span class="hljs-built_in">test</span>:watch

<span class="hljs-comment"># Coverage report</span>
<span class="hljs-built_in">cd</span> ui/packages/web-app &amp;&amp; pnpm <span class="hljs-built_in">test</span>:coverage
```text

<span class="hljs-comment">#### E2E Tests (Playwright)</span>

E2E tests require the daemon to be running and the binary to be built:

```bash
<span class="hljs-comment"># Build and install</span>
make install

<span class="hljs-comment"># Start daemon</span>
thrum daemon start

<span class="hljs-comment"># Run all E2E tests (serial execution required)</span>
npx playwright <span class="hljs-built_in">test</span> --workers=1

<span class="hljs-comment"># Run a specific spec file</span>
npx playwright <span class="hljs-built_in">test</span> tests/e2e/messaging.spec.ts --workers=1

<span class="hljs-comment"># View HTML report</span>
npx playwright show-report
```text

The E2E <span class="hljs-built_in">test</span> suite uses `global-setup.ts` to start the daemon and register a
<span class="hljs-built_in">test</span> agent, and `global-teardown.ts` to stop the daemon after all tests
complete.

<span class="hljs-comment">### 2. Code Coverage</span>

```bash
<span class="hljs-comment"># Generate Go coverage report</span>
make test-coverage
<span class="hljs-comment"># Report output: output/coverage.html</span>
```text

<span class="hljs-comment">### 3. Linting</span>

```bash
<span class="hljs-comment"># Run Go linter (auto-installs golangci-lint if missing)</span>
make lint

<span class="hljs-comment"># Auto-fix Go lint issues</span>
make lint-fix

<span class="hljs-comment"># Run Markdown linter</span>
make lint-md

<span class="hljs-comment"># Auto-fix Markdown issues</span>
make lint-md-fix

<span class="hljs-comment"># Run all linters (Go + Markdown)</span>
make lint-all
```text

<span class="hljs-comment">### 4. Formatting</span>

```bash
<span class="hljs-comment"># Format Go code</span>
make <span class="hljs-built_in">fmt</span>

<span class="hljs-comment"># Format Markdown files (requires prettier)</span>
make fmt-md

<span class="hljs-comment"># Format all files (Go + Markdown)</span>
make fmt-all
```text

<span class="hljs-comment">### 5. Building</span>

```bash
<span class="hljs-comment"># Full build: UI + Go binary</span>
make build
<span class="hljs-comment"># Output: ./bin/thrum</span>

<span class="hljs-comment"># Build Go binary only (skip UI rebuild, uses existing internal/web/dist/)</span>
make build-go

<span class="hljs-comment"># Build UI only (pnpm install + build, copies to internal/web/dist/)</span>
make build-ui

<span class="hljs-comment"># Full build + install to ~/.local/bin</span>
make install

<span class="hljs-comment"># Run built binary</span>
./bin/thrum
```go

The build embeds the React SPA into the Go binary via `//go:embed` <span class="hljs-keyword">in</span>
`internal/web/embed.go`. The `make build-ui` step copies the Vite build output
into `internal/web/dist/` so the Go embed directive can include it.

A `.gitkeep` file <span class="hljs-keyword">in</span> `internal/web/dist/` ensures `go build` and `go vet` work
even when the UI has not been built.

<span class="hljs-comment">## Makefile Targets</span>

| Target                  | Description                                            |
| ----------------------- | ------------------------------------------------------ |
| `make <span class="hljs-built_in">help</span>`             | Show all available targets (default)                   |
| `make build`            | Full build: UI + Go binary                             |
| `make build-ui`         | Build UI and copy to embed location                    |
| `make build-go`         | Build Go binary only (skip UI rebuild)                 |
| `make install`          | Full build and install to `~/.local/bin`               |
| `make <span class="hljs-built_in">test</span>`             | Run all Go tests                                       |
| `make test-unit`        | Run unit tests only (fast)                             |
| `make test-integration` | Run integration tests                                  |
| `make test-coverage`    | Generate coverage report to `output/`                  |
| `make test-verbose`     | Run tests with verbose output                          |
| `make <span class="hljs-built_in">fmt</span>`              | Format Go code                                         |
| `make fmt-md`           | Format Markdown files with prettier                    |
| `make fmt-all`          | Format all files (Go + Markdown)                       |
| `make lint`             | Run golangci-lint                                      |
| `make lint-fix`         | Run golangci-lint with auto-fix                        |
| `make lint-md`          | Run markdownlint                                       |
| `make lint-md-fix`      | Run markdownlint with auto-fix                         |
| `make lint-all`         | Run all linters (Go + Markdown)                        |
| `make vet`              | Run `go vet`                                           |
| `make tidy`             | Tidy Go dependencies                                   |
| `make clean`            | Remove build artifacts (`output/`, `bin/`, `dist/`)    |
| `make install-tools`    | Install dev tools (golangci-lint, markdownlint-cli)    |
| `make quick-check`      | Fast pre-commit checks: format, vet, <span class="hljs-built_in">test</span>, build       |
| `make ci`               | Full CI checks: format-all, lint-all, vet, <span class="hljs-built_in">test</span>, build |
| `make pre-commit`       | Alias <span class="hljs-keyword">for</span> `quick-check`                                |
| `make pre-push`         | Alias <span class="hljs-keyword">for</span> `ci`                                         |

<span class="hljs-comment">## Common Tasks</span>

<span class="hljs-comment">### Adding a New Event Type</span>

1. Define event struct <span class="hljs-keyword">in</span> `internal/types/events.go`
2. Add handler <span class="hljs-keyword">in</span> `internal/projection/projector.go`
3. Add <span class="hljs-keyword">case</span> <span class="hljs-keyword">in</span> the `Apply()` switch statement
4. Write tests <span class="hljs-keyword">in</span> `internal/projection/projector_test.go`

Current event types handled by the projector:

- `message.create`, `message.edit`, `message.delete`
- `agent.register`
- `agent.session.start`, `agent.session.end`
- `agent.update`

Example:

```go
// 1. Define event <span class="hljs-built_in">type</span> <span class="hljs-keyword">in</span> internal/types/events.go
<span class="hljs-built_in">type</span> MyNewEvent struct {
    BaseEvent
    MyField string `json:<span class="hljs-string">&quot;my_field&quot;</span>`
}

// 2. Add handler <span class="hljs-keyword">in</span> internal/projection/projector.go
func (p *Projector) applyMyNew(data json.RawMessage) error {
    var event types.MyNewEvent
    <span class="hljs-keyword">if</span> err := json.Unmarshal(data, &amp;event); err != nil {
        <span class="hljs-built_in">return</span> fmt.Errorf(<span class="hljs-string">&quot;unmarshal my.new: %w&quot;</span>, err)
    }

    // Insert/update database
    _, err := p.db.Exec(`...`)
    <span class="hljs-built_in">return</span> err
}

// 3. Update switch <span class="hljs-keyword">in</span> Apply()
<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;my.new&quot;</span>:
    <span class="hljs-built_in">return</span> p.applyMyNew(event)
```go

<span class="hljs-comment">### Modifying Database Schema</span>

1. Update table definitions <span class="hljs-keyword">in</span> `internal/schema/schema.go`
2. Increment `CurrentVersion` constant (currently v7)
3. Add migration logic <span class="hljs-keyword">in</span> the `Migrate()` <span class="hljs-keyword">function</span>
4. Write tests <span class="hljs-keyword">for</span> the new schema
5. Update `docs/architecture.md`

<span class="hljs-comment">### Testing with Temporary Databases</span>

```go
func TestMyFeature(t *testing.T) {
    // Create temp database
    tmpDir := t.TempDir()
    dbPath := filepath.Join(tmpDir, <span class="hljs-string">&quot;test.db&quot;</span>)

    db, _ := schema.OpenDB(dbPath)
    defer db.Close()

    schema.InitDB(db)

    // Test your feature
    // ...
}
```go

<span class="hljs-comment">### Adding a New RPC Method</span>

1. Create handler file <span class="hljs-keyword">in</span> `internal/daemon/rpc/`:

```go
// internal/daemon/rpc/mymethod.go
package rpc

import (
    <span class="hljs-string">&quot;context&quot;</span>
    <span class="hljs-string">&quot;encoding/json&quot;</span>
)

<span class="hljs-built_in">type</span> MyMethodHandler struct {
    // dependencies
}

func NewMyMethodHandler(deps...) *MyMethodHandler {
    <span class="hljs-built_in">return</span> &amp;MyMethodHandler{...}
}

func (h *MyMethodHandler) Handle(ctx context.Context, params json.RawMessage) (any, error) {
    // Parse params
    var args MyMethodArgs
    <span class="hljs-keyword">if</span> err := json.Unmarshal(params, &amp;args); err != nil {
        <span class="hljs-built_in">return</span> nil, fmt.Errorf(<span class="hljs-string">&quot;invalid params: %w&quot;</span>, err)
    }

    // Implementation
    result := MyMethodResponse{
        // ...
    }

    <span class="hljs-built_in">return</span> result, nil
}
```text

2. Add tests <span class="hljs-keyword">in</span> `internal/daemon/rpc/mymethod_test.go`

3. Register <span class="hljs-keyword">in</span> daemon startup (<span class="hljs-keyword">in</span> `cmd/thrum/main.go`):

```go
myMethodHandler := rpc.NewMyMethodHandler()
server.RegisterHandler(<span class="hljs-string">&quot;mymethod&quot;</span>, myMethodHandler.Handle)
```go

4. Update documentation <span class="hljs-keyword">in</span> `docs/rpc-api.md`

<span class="hljs-comment">## Environment Variables</span>

Configuration is resolved <span class="hljs-keyword">in</span> priority order:

1. `THRUM_NAME` <span class="hljs-built_in">env</span> var to <span class="hljs-keyword">select</span> <span class="hljs-built_in">which</span> identity file (highest priority)
2. Environment variables: `THRUM_ROLE`, `THRUM_MODULE`, `THRUM_DISPLAY`
3. CLI flags (`--role`, `--module`, `--name`)
4. Identity file <span class="hljs-keyword">in</span> `.thrum/identities/{name}.json`
5. Error <span class="hljs-keyword">if</span> required fields are missing

```bash
<span class="hljs-comment"># Select a named agent identity</span>
<span class="hljs-built_in">export</span> THRUM_NAME=furiosa

<span class="hljs-comment"># Or set agent properties directly</span>
<span class="hljs-built_in">export</span> THRUM_ROLE=implementer
<span class="hljs-built_in">export</span> THRUM_MODULE=auth
<span class="hljs-built_in">export</span> THRUM_DISPLAY=<span class="hljs-string">&quot;Auth Agent&quot;</span>
```text

Identity files are stored per-agent at `.thrum/identities/{name}.json` and
contain repo ID, agent config, worktree name, and metadata.

<span class="hljs-comment">## Storage Layout</span>

Thrum uses a <span class="hljs-built_in">split</span> storage model:

```go
.git/thrum-sync/a-sync/              <span class="hljs-comment"># Sync worktree (a-sync orphan branch)</span>
├── events.jsonl                     <span class="hljs-comment"># Agent lifecycle events (register, session, update)</span>
└── messages/                        <span class="hljs-comment"># Per-agent message files (sharded)</span>
    ├── furiosa.jsonl                <span class="hljs-comment"># Messages authored by agent &quot;furiosa&quot;</span>
    └── coordinator.jsonl            <span class="hljs-comment"># Messages authored by agent &quot;coordinator&quot;</span>

.thrum/                              <span class="hljs-comment"># Runtime directory (gitignored)</span>
├── var/
│   ├── messages.db                  <span class="hljs-comment"># SQLite projection cache (rebuilt from JSONL)</span>
│   ├── thrum.sock                   <span class="hljs-comment"># Unix socket for daemon RPC</span>
│   ├── thrum.pid                    <span class="hljs-comment"># JSON PID file with repo-affinity metadata</span>
│   └── ws.port                      <span class="hljs-comment"># WebSocket port file (default 9999)</span>
├── identities/                      <span class="hljs-comment"># Per-agent identity files</span>
│   └── {name}.json                  <span class="hljs-comment"># Agent identity (repo_id, role, module, etc.)</span>
└── redirect                         <span class="hljs-comment"># Points to main worktree .thrum/ (feature worktrees only)</span>
```text

<span class="hljs-comment">### Inspecting JSONL Files</span>

```bash
<span class="hljs-comment"># View all events (agent lifecycle)</span>
<span class="hljs-built_in">cat</span> .git/thrum-sync/a-sync/events.jsonl | jq .

<span class="hljs-comment"># View messages for a specific agent</span>
<span class="hljs-built_in">cat</span> .git/thrum-sync/a-sync/messages/furiosa.jsonl | jq .

<span class="hljs-comment"># Filter by event type</span>
<span class="hljs-built_in">cat</span> .git/thrum-sync/a-sync/events.jsonl | jq <span class="hljs-string">&#x27;select(.type == &quot;agent.register&quot;)&#x27;</span>

<span class="hljs-comment"># Count events</span>
<span class="hljs-built_in">wc</span> -l .git/thrum-sync/a-sync/events.jsonl
```go

<span class="hljs-comment">### Inspecting the SQLite Database</span>

```bash
<span class="hljs-comment"># Open database</span>
sqlite3 .thrum/var/messages.db

<span class="hljs-comment"># List tables</span>
.tables

<span class="hljs-comment"># Query messages</span>
SELECT * FROM messages LIMIT 10;

<span class="hljs-comment"># Check schema version</span>
SELECT * FROM schema_version;
```text

<span class="hljs-comment">## Daemon Development</span>

<span class="hljs-comment">### Daemon Architecture</span>

The daemon runs as a background service handling client connections via Unix
socket, with a WebSocket server and embedded SPA all on a single port (default
9999).

**Key components:**

- **Server** (`internal/daemon/server.go`): JSON-RPC 2.0 over Unix socket
- **Lifecycle** (`internal/daemon/lifecycle.go`): Signal handling, defer cleanup
  safety net, flock-based process detection
- **PID file** (`internal/daemon/pidfile.go`): JSON format with `PIDInfo` struct
  (PID, repo path, socket path, started at). Backward-compatible reader falls
  back to plain <span class="hljs-built_in">integer</span> format.
- **File lock** (`internal/daemon/flock.go`, `flock_unix.go`): OS-level
  `flock()` on socket file. Auto-released on process death (even SIGKILL). No-op
  stubs <span class="hljs-keyword">for</span> non-Unix platforms.
- **State** (`internal/daemon/state/`): Manages JSONL writes (sharded per-agent)
  and SQLite projection. `NewState(thrumDir, syncDir, repoID)` separates runtime
  state from <span class="hljs-built_in">sync</span> data.
- **RPC handlers** (`internal/daemon/rpc/`): Method implementations <span class="hljs-keyword">for</span> agent,
  session, message, thread, health, <span class="hljs-built_in">sync</span>, subscribe, and user operations
- **Client** (`internal/daemon/client.go`): Connection library <span class="hljs-keyword">for</span> CLI-to-daemon
  communication
- **WebSocket** (`internal/websocket/`): Server, connection registry, event
  streaming
- **Web** (`internal/web/embed.go`): Embedded SPA served at `/` on the same port
  as WebSocket (`/ws`)

See `docs/daemon.md` <span class="hljs-keyword">for</span> detailed architecture.

<span class="hljs-comment">### Running the Daemon</span>

```bash
<span class="hljs-comment"># Start daemon (background, auto-creates sync worktree)</span>
thrum daemon start

<span class="hljs-comment"># Start in foreground (for debugging)</span>
thrum daemon start --foreground

<span class="hljs-comment"># Check status (shows PID, repo path, WebSocket port)</span>
thrum daemon status

<span class="hljs-comment"># Stop daemon</span>
thrum daemon stop

<span class="hljs-comment"># Auto-start (happens automatically via any CLI command)</span>
thrum send <span class="hljs-string">&quot;Hello&quot;</span> --to @coordinator
```text

<span class="hljs-comment">### Testing Daemon Code</span>

```bash
<span class="hljs-comment"># Run daemon tests</span>
go <span class="hljs-built_in">test</span> ./internal/daemon/...

<span class="hljs-comment"># With coverage</span>
go <span class="hljs-built_in">test</span> -cover ./internal/daemon/...

<span class="hljs-comment"># RPC handler tests</span>
go <span class="hljs-built_in">test</span> ./internal/daemon/rpc/... -v

<span class="hljs-comment"># State tests</span>
go <span class="hljs-built_in">test</span> ./internal/daemon/state/... -v
```text

Use the `StartTestDaemon()` helper <span class="hljs-keyword">in</span> `internal/daemon/testutil_test.go` <span class="hljs-keyword">for</span>
integration tests. It provides automatic `t.Cleanup()` with force-kill to
prevent <span class="hljs-built_in">test</span> orphan processes on <span class="hljs-built_in">timeout</span> or panic.

<span class="hljs-comment">### Debugging Daemon</span>

**Check <span class="hljs-keyword">if</span> daemon is running:**

```bash
<span class="hljs-comment"># Check PID file (JSON format)</span>
<span class="hljs-built_in">cat</span> .thrum/var/thrum.pid | jq .

<span class="hljs-comment"># Check process</span>
ps aux | grep thrum

<span class="hljs-comment"># Check socket</span>
<span class="hljs-built_in">ls</span> -l .thrum/var/thrum.sock
```go

**Test RPC calls manually:**

```bash
<span class="hljs-comment"># Using netcat</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;health&quot;,&quot;id&quot;:1}&#x27;</span> | nc -U .thrum/var/thrum.sock
```text

**View daemon logs:**

```bash
<span class="hljs-comment"># Run daemon in foreground for debugging</span>
thrum daemon start --foreground
<span class="hljs-comment"># Logs appear in stdout/stderr</span>
```text

**Clean restart:**

```bash
<span class="hljs-comment"># Stop daemon</span>
thrum daemon stop

<span class="hljs-comment"># Remove stale files if needed</span>
<span class="hljs-built_in">rm</span> .thrum/var/thrum.sock
<span class="hljs-built_in">rm</span> .thrum/var/thrum.pid

<span class="hljs-comment"># Restart</span>
thrum daemon start
```go

<span class="hljs-comment">### Common Daemon Issues</span>

**Socket path too long:**

- Unix sockets limited to ~104 characters
- Use shorter temp directory paths <span class="hljs-keyword">in</span> tests
- Example: `filepath.Join(tmpDir, <span class="hljs-string">&quot;d.sock&quot;</span>)` not
  `filepath.Join(tmpDir, <span class="hljs-string">&quot;.thrum&quot;</span>, <span class="hljs-string">&quot;var&quot;</span>, <span class="hljs-string">&quot;thrum.sock&quot;</span>)`

**Permission denied:**

- Socket should be 0600 (owner only)
- Check `.thrum/var/` directory permissions

**Bind: address already <span class="hljs-keyword">in</span> use:**

- Another daemon already running
- Pre-startup duplicate detection validates no existing daemon serves this repo
- Check PID file and <span class="hljs-built_in">kill</span> process
- Remove stale socket file

**Connection refused:**

- Daemon not running
- Check PID file exists
- Verify socket file exists

<span class="hljs-comment">## MCP Server Development</span>

The MCP server (`thrum mcp serve`) provides native MCP tools <span class="hljs-keyword">for</span> Claude Code
agents instead of shelling out to the CLI. It uses stdio transport (JSON-RPC
over stdin/stdout).

**Key files:**

- `internal/mcp/server.go`: Server skeleton and tool registration
- `internal/mcp/tools.go`: Tool handler implementations
- `internal/mcp/types.go`: Request/response <span class="hljs-built_in">type</span> definitions
- `internal/mcp/waiter.go`: WebSocket-based blocking message waiter
- `cmd/thrum/mcp.go`: `thrum mcp serve` Cobra <span class="hljs-built_in">command</span>

**MCP Tools (5):**

| Tool                | Description                                                                   |
| ------------------- | ----------------------------------------------------------------------------- |
| `send_message`      | Send a message to another agent via @role addressing                          |
| `check_messages`    | Poll <span class="hljs-keyword">for</span> unread messages mentioning this agent                                |
| `wait_for_message`  | Block <span class="hljs-keyword">until</span> a message arrives (WebSocket push) or <span class="hljs-built_in">timeout</span>                     |
| `list_agents`       | List registered agents with active/offline status                             |
| `broadcast_message` | Send to all agents (convenience wrapper around `send_message` to `@everyone`) |

**Architecture:**

- Per-call `cli.Client` creation (thread-safe; Unix socket connections are
  cheap)
- WebSocket waiter with atomic incrementing JSON-RPC IDs
- Identity resolved at startup from `.thrum/identities/{name}.json`
- `THRUM_NAME` <span class="hljs-built_in">env</span> var or `--agent-id` flag <span class="hljs-keyword">for</span> multi-agent worktrees

```bash
<span class="hljs-comment"># Start MCP server</span>
thrum mcp serve

<span class="hljs-comment"># Override agent identity</span>
thrum mcp serve --agent-id furiosa
```text

<span class="hljs-comment">## Sync Engine</span>

The <span class="hljs-built_in">sync</span> engine runs <span class="hljs-keyword">in</span> the daemon, performing fetch/merge/push every 60 seconds
(configurable via `--sync-interval`).

**Key files:**

- `internal/sync/loop.go`: `SyncLoop` with periodic and manual <span class="hljs-built_in">sync</span> triggers
- `internal/sync/merge.go`: JSONL merge with deduplication (ULID event_id)
- `internal/sync/push.go`: Git push to remote
- `internal/sync/branch.go`: Safe orphan branch creation via `git commit-tree` +
  `git update-ref`, <span class="hljs-built_in">sync</span> worktree with sparse checkout, 4-level health checks
- `internal/sync/dedup.go`: Event deduplication by event_id

**Sync worktree location:** `.git/thrum-sync/a-sync/` (uses `git-common-dir` <span class="hljs-keyword">for</span>
nested worktree support).

**Sparse checkout patterns:** `/events.jsonl`, `/messages/`, `/messages.jsonl`
(migration compat).

<span class="hljs-comment">## Worktree Setup</span>

Thrum supports multiple git worktrees sharing a single daemon and data store via
the `.thrum/redirect` mechanism. Feature worktrees point to the main worktree<span class="hljs-string">&#x27;s
`.thrum/` directory so all worktrees share one daemon, one SQLite database, and
one set of JSONL files.

### Setting Up a Worktree

```bash
# Option 1: Use the thrum setup command
thrum setup /path/to/worktree

# Option 2: Use the setup script
./scripts/setup-worktree-thrum.sh /path/to/worktree

# Option 3: Manual setup
mkdir -p /path/to/worktree/.thrum/identities
echo &quot;/path/to/main/repo/.thrum&quot; &gt; /path/to/worktree/.thrum/redirect
```text

### Beads Issue Tracking for Worktrees

All worktrees should share the same beads issue database:

```bash
# Use the setup script
./scripts/setup-worktree-beads.sh /path/to/worktree

# Or manual setup
mkdir -p /path/to/worktree/.beads
echo &quot;/path/to/main/repo/.beads&quot; &gt; /path/to/worktree/.beads/redirect

# Verify
cd /path/to/worktree &amp;&amp; bd where
```go

## Testing Best Practices

### 1. Use Table-Driven Tests

```go
tests := []struct {
    name string
    input string
    want string
}{
    {&quot;case 1&quot;, &quot;input1&quot;, &quot;expected1&quot;},
    {&quot;case 2&quot;, &quot;input2&quot;, &quot;expected2&quot;},
}

for _, tt := range tests {
    t.Run(tt.name, func(t *testing.T) {
        got := MyFunction(tt.input)
        if got != tt.want {
            t.Errorf(&quot;got %v, want %v&quot;, got, tt.want)
        }
    })
}
```text

### 2. Clean Up Resources

```go
// Use t.TempDir() for automatic cleanup
tmpDir := t.TempDir()

// Or defer cleanup
db, _ := schema.OpenDB(dbPath)
defer db.Close()
```text

### 3. Test Error Cases

```go
// Test both happy path and error cases
_, err := MyFunction(invalidInput)
if err == nil {
    t.Error(&quot;expected error, got nil&quot;)
}
```text

### 4. Use StartTestDaemon for Integration Tests

```go
// Automatically cleans up on test completion (even on panic/timeout)
daemon := StartTestDaemon(t, tmpDir)
defer daemon.Stop()
```text

## Code Style

- **Formatting**: Use `go fmt` (or `gofmt -s`)
- **Imports**: Group stdlib, external, internal
- **Comments**: Document exported functions and types
- **Error messages**: Lowercase, no punctuation, wrap with `fmt.Errorf`
- **Variable names**: Short, descriptive (e.g., `db`, `cfg`, `msg`)

## Git Workflow

```bash
# Create feature branch
git checkout -b feature/my-feature

# Make changes and test
go test ./...

# Commit
git add .
git commit -m &quot;Add my feature&quot;

# Push
git push origin feature/my-feature

# Create PR
gh pr create
```text

## Troubleshooting

### &quot;no such table&quot; error

The SQLite projection database is a rebuild-able cache. Delete it and restart
the daemon to rebuild from JSONL:

```bash
rm .thrum/var/messages.db
thrum daemon stop
thrum daemon start
```text

### &quot;cannot open file&quot; error

Check file permissions and directory existence:

```bash
ls -la .thrum/
ls -la .thrum/var/
```text

### Tests fail with &quot;database is locked&quot;

Close any open SQLite connections or delete WAL files:

```bash
rm .thrum/var/*.db-wal
rm .thrum/var/*.db-shm
```text

### Daemon won&#x27;</span>t start (duplicate detection)

The daemon validates no existing instance serves the same repository before
starting. Check <span class="hljs-keyword">for</span> a stale PID file:

```bash
<span class="hljs-built_in">cat</span> .thrum/var/thrum.pid | jq .
<span class="hljs-comment"># If the process is dead, remove the PID file</span>
<span class="hljs-built_in">rm</span> .thrum/var/thrum.pid
thrum daemon start
```text

<span class="hljs-comment">### `go build` fails with embed error</span>

If the UI has not been built, `internal/web/dist/` needs at least a `.gitkeep`
file:

```bash
<span class="hljs-built_in">touch</span> internal/web/dist/.gitkeep
```text

Or build the UI first: `make build-ui`

<span class="hljs-comment">## Key Dependencies</span>

| Dependency                                                     | Purpose                       |
| -------------------------------------------------------------- | ----------------------------- |
| [cobra](https://github.com/spf13/cobra)                        | CLI <span class="hljs-built_in">command</span> framework         |
| [modernc.org/sqlite](https://pkg.go.dev/modernc.org/sqlite)    | Pure Go SQLite driver         |
| [oklog/ulid](https://github.com/oklog/ulid)                    | ULID generation <span class="hljs-keyword">for</span> event IDs |
| [gorilla/websocket](https://github.com/gorilla/websocket)      | WebSocket server              |
| [go-sdk (MCP)](https://github.com/modelcontextprotocol/go-sdk) | MCP server SDK                |

<span class="hljs-comment">## Resources</span>

- **Architecture**: `docs/architecture.md`
- **Daemon Architecture**: `docs/daemon.md`
- **RPC API Reference**: `docs/rpc-api.md`
- **Sync Design**: `docs/sync.md`
- **Quickstart Guide**: `docs/quickstart.md`
- **CLI Reference**: `docs/cli.md`
- **Identity System**: `docs/identity.md`
- **Workflow Templates**: `docs/workflow-templates.md` (structured feature
  development with AI agents)
- **Agent Reference**: `llms.txt` (concise) and `llms-full.txt` (detailed)</code></pre>

    </div>
    <p style="margin-top:2rem"><a href="../docs.html#development.html">&larr; View in documentation</a></p>
  </main>
  <script>
    // Redirect browsers to the SPA for full navigation experience.
    // Crawlers (which don't execute JS) will index the static content above.
    if (window.location.search.indexOf('nospa') === -1) {
      window.location.replace('../docs.html#development.html');
    }
  </script>
</body>
</html>