<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Development Guide — Thrum</title>
<meta name="description" content="Setup, testing, building, contributing - complete guide for developing and extending Thrum">
<link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#development.html">
<style>
body{font-family:system-ui,sans-serif;max-width:48rem;margin:2rem auto;padding:0 1.5rem;line-height:1.6;color:#222}
pre{background:#f5f5f5;padding:1rem;overflow-x:auto;border-radius:4px}
code{font-family:ui-monospace,monospace;font-size:0.9em}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #ddd;padding:0.4rem 0.6rem;text-align:left}
th{background:#f5f5f5}
nav{margin-bottom:1.5rem;padding-bottom:1rem;border-bottom:1px solid #ddd;line-height:1.8}
h2{margin-top:2rem}
a{color:#0366d6}
</style>
</head>
<body>
<nav>
<strong><a href="../docs.html">Thrum Docs</a></strong> &rsaquo; Development &rsaquo; Development Guide
<hr>
<strong>Overview</strong>: <a href="philosophy.html">Philosophy</a><br>
<strong>Getting Started</strong>: <a href="quickstart.html">Quickstart Guide</a><br>
  <strong>Recommended Tools</strong>: <a href="guides/recommended-tools.html">Recommended Tools</a> | <a href="guides/beads-setup.html">Beads Setup Guide</a> | <a href="guides/beads-ui-setup.html">Beads UI Setup Guide</a> | <a href="guides/playwright-cli-setup.html">Playwright CLI Setup Guide</a><br>
<strong>Web UI</strong>: <a href="web-ui.html">Web UI</a><br>
<strong>Messaging</strong>: <a href="subscriptions.html">Subscriptions & Notifications</a><br>
<strong>Identity</strong>: <a href="identity.html">Agent Identity & Registration</a><br>
<strong>Guides</strong>: <a href="agent-coordination.html">Agent Coordination</a> | <a href="agent-configs.html">Agent Configurations</a> | <a href="multi-agent.html">Multi-Agent Support</a> | <a href="claude-code-plugin.html">Claude Code Plugin</a> | <a href="configuration.html">Configuration</a> | <a href="workflow-templates.html">Workflow Templates</a> | <a href="beads-and-thrum.html">Beads and Thrum</a> | <a href="codex-plugin.html">Codex Plugin</a> | <a href="claude-agent-integration.html">Claude Code Agent Integration</a> | <a href="messaging.html">Messaging</a> | <a href="tailscale-sync.html">Tailscale Sync</a> | <a href="tailscale-security.html">Tailscale Sync Security</a> | <a href="overview.html">Technical Overview</a><br>
<strong>API Reference</strong>: <a href="event-streaming.html">Event Streaming</a> | <a href="inbox-query-methods.html">Inbox Query Methods</a> | <a href="api/authentication.html">Authentication</a> | <a href="api/events.html">Event Reference</a> | <a href="rpc-api.html">RPC API</a> | <a href="api/websocket.html">WebSocket API</a><br>
<strong>Daemon</strong>: <a href="daemon.html">Daemon Architecture</a><br>
<strong>Sync</strong>: <a href="sync.html">Sync Protocol</a><br>
<strong>Development</strong>: <strong>Development Guide</strong> | <a href="security-cicd.html">Security & CI/CD</a><br>
<strong>Architecture</strong>: <a href="architecture.html">Architecture</a><br>
<strong>Context</strong>: <a href="context.html">Agent Context Management</a><br>
<strong>Reference</strong>: <a href="cli.html">CLI Reference</a> | <a href="mcp-server.html">MCP Server</a><br>
<strong>uncategorized</strong>: <a href="role-templates.html">Role-Based Preamble Templates</a><br>
</nav>
<main>
<h2>Thrum Development Guide</h2>
<p>This guide explains how to set up and work with the Thrum codebase.</p>
<h2>Prerequisites</h2>
<ul>
<li><strong>Go 1.26+</strong>: <a href="https://go.dev/dl/">Install Go</a></li>
<li><strong>Node.js 22+</strong> and <strong>pnpm 10+</strong>: Required for building the UI monorepo</li>
<li><strong>Make</strong>: Build automation</li>
<li><strong>Playwright</strong>: E2E testing (<code>npx playwright install chromium</code>)</li>
<li><strong>golangci-lint</strong>: Code linting (auto-installed by <code>make lint</code>)</li>
<li><strong>markdownlint-cli</strong>: Markdown linting (auto-installed by <code>make lint-md</code>)</li>
</ul>
<h2>Quick Start</h2>
<pre><code># Clone repository
git clone &lt;repo-url&gt;
cd thrum

# Install dependencies
go mod download
cd ui &amp;&amp; pnpm install &amp;&amp; cd ..

# Run Go tests
make test

# Full build (UI + Go binary) and install to ~/.local/bin
make install

# Start daemon and verify
thrum daemon start
thrum daemon status</code></pre>
<h2>Project Structure</h2>
<pre><code>thrum/
├── cmd/
│   └── thrum/               # CLI entry point
│       ├── main.go          # Cobra command tree (all CLI commands)
│       └── mcp.go           # MCP server command
├── internal/                # Private packages
│   ├── cli/                 # CLI business logic (one file per command)
│   ├── config/              # Configuration loading and identity files
│   ├── daemon/              # Daemon core
│   │   ├── cleanup/         # Agent work context cleanup
│   │   ├── rpc/             # JSON-RPC 2.0 method handlers
│   │   ├── state/           # Persistent state (JSONL + SQLite)
│   │   ├── server.go        # Unix socket server
│   │   ├── lifecycle.go     # Signal handling, defer cleanup, flock
│   │   ├── pidfile.go       # JSON PID file with repo-affinity metadata
│   │   ├── client.go        # Client library
│   │   ├── flock.go         # FileLock struct definition
│   │   ├── flock_unix.go    # flock() implementation (Unix)
│   │   ├── flock_other.go   # No-op stubs (non-Unix)
│   │   └── testutil_test.go # StartTestDaemon() helper
│   ├── gitctx/              # Git-derived work context (branch, uncommitted files)
│   ├── identity/            # ID generation (ULID-based: repo, agent, session, message, event)
│   ├── jsonl/               # JSONL reader/writer with file locking
│   ├── mcp/                 # MCP stdio server (5 tools, WebSocket waiter)
│   ├── paths/               # Path resolution, .thrum/redirect, sync worktree path
│   ├── projection/          # JSONL to SQLite event replay (projector)
│   ├── schema/              # SQLite schema, DDL, and migrations (v7)
│   ├── subscriptions/       # Notification dispatcher and subscription service
│   ├── sync/                # Sync engine (loop, merge, push, dedup, branch management)
│   ├── transport/           # Transport abstraction layer
│   ├── types/               # Shared event type definitions
│   ├── web/                 # Embedded SPA (//go:embed React build)
│   └── websocket/           # WebSocket server, connections, registry
├── ui/                      # UI monorepo (Turborepo + pnpm workspaces)
│   ├── packages/
│   │   ├── shared-logic/    # Framework-agnostic business logic (TanStack, Zod)
│   │   ├── web-app/         # React web application (Vite, shadcn/ui)
│   │   └── tui-app/         # Terminal UI (Ink, placeholder)
│   ├── turbo.json           # Turborepo configuration
│   ├── pnpm-workspace.yaml  # pnpm workspace configuration
│   └── package.json         # Root monorepo scripts
├── tests/
│   └── e2e/                 # Playwright E2E tests (13 spec files)
│       ├── helpers/         # Test helpers (CLI wrapper, fixtures)
│       ├── global-setup.ts  # Daemon start + agent registration
│       └── global-teardown.ts
├── scripts/                 # Setup scripts
│   ├── setup-worktree-thrum.sh  # Configure .thrum/redirect for worktrees
│   └── setup-worktree-beads.sh  # Configure .beads/redirect for worktrees
├── docs/                    # User documentation
├── dev-docs/                # Design documents and prompts
├── .agents/                 # Agent workflow instructions (hidden directory)
├── .beads/                  # Issue tracking (beads)
├── Makefile                 # Build targets
├── go.mod                   # Go module (github.com/leonletto/thrum)
├── playwright.config.ts     # Playwright E2E configuration
└── llms.txt / llms-full.txt # Agent reference files</code></pre>
<h2>Development Workflow</h2>
<h3>1. Running Tests</h3>
<h4>Go Tests</h4>
<pre><code># Run all Go tests
make test

# Run unit tests only (fast, skips integration)
make test-unit

# Run integration tests
make test-integration

# Run tests with verbose output
make test-verbose

# Run specific package tests
go test ./internal/config/... -v

# Run with race detector
go test -race ./...

# Run resilience tests (requires build tag)
go test -tags=resilience ./internal/daemon/...</code></pre>
<p><strong>Resilience Test Suite (v0.4.3):</strong></p>
<p>The resilience test suite includes 39 tests covering crash recovery, concurrent
access, and timeout enforcement. These tests require the <code>-tags=resilience</code>
build flag:</p>
<ul>
<li>Crash recovery scenarios (daemon restart, state restoration)</li>
<li>Concurrent access patterns (multiple goroutines, race conditions)</li>
<li>Timeout enforcement (I/O timeouts, RPC timeouts, WebSocket timeouts)</li>
</ul>
<p>Run the full resilience suite:</p>
<pre><code>go test -tags=resilience -v ./internal/daemon/resilience_test.go</code></pre>
<h4>UI Tests</h4>
<pre><code># Run all UI tests (from monorepo root)
cd ui &amp;&amp; pnpm test

# Run web-app tests only
cd ui/packages/web-app &amp;&amp; pnpm test

# Run shared-logic tests only
cd ui/packages/shared-logic &amp;&amp; pnpm test

# Watch mode
cd ui/packages/web-app &amp;&amp; pnpm test:watch

# Coverage report
cd ui/packages/web-app &amp;&amp; pnpm test:coverage</code></pre>
<h4>E2E Tests (Playwright)</h4>
<p>E2E tests require the daemon to be running and the binary to be built:</p>
<pre><code># Build and install
make install

# Start daemon
thrum daemon start

# Run all E2E tests (serial execution required)
npx playwright test --workers=1

# Run a specific spec file
npx playwright test tests/e2e/messaging.spec.ts --workers=1

# View HTML report
npx playwright show-report</code></pre>
<p>The E2E test suite uses <code>global-setup.ts</code> to start the daemon and register a
test agent, and <code>global-teardown.ts</code> to stop the daemon after all tests
complete.</p>
<h3>2. Code Coverage</h3>
<pre><code># Generate Go coverage report
make test-coverage
# Report output: output/coverage.html</code></pre>
<h3>3. Linting</h3>
<pre><code># Run Go linter (auto-installs golangci-lint if missing)
make lint

# Auto-fix Go lint issues
make lint-fix

# Run Markdown linter
make lint-md

# Auto-fix Markdown issues
make lint-md-fix

# Run all linters (Go + Markdown)
make lint-all</code></pre>
<h3>4. Formatting</h3>
<pre><code># Format Go code
make fmt

# Format Markdown files (requires prettier)
make fmt-md

# Format all files (Go + Markdown)
make fmt-all</code></pre>
<h3>5. Building</h3>
<pre><code># Full build: UI + Go binary
make build
# Output: ./bin/thrum

# Build Go binary only (skip UI rebuild, uses existing internal/web/dist/)
make build-go

# Build UI only (pnpm install + build, copies to internal/web/dist/)
make build-ui

# Full build + install to ~/.local/bin
make install

# Run built binary
./bin/thrum</code></pre>
<p>The build embeds the React SPA into the Go binary via <code>//go:embed</code> in
<code>internal/web/embed.go</code>. The <code>make build-ui</code> step copies the Vite build output
into <code>internal/web/dist/</code> so the Go embed directive can include it.</p>
<p>A <code>.gitkeep</code> file in <code>internal/web/dist/</code> ensures <code>go build</code> and <code>go vet</code> work
even when the UI has not been built.</p>
<h2>Makefile Targets</h2>
<table>
<thead>
<tr>
<th>Target</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>make help</code></td>
<td>Show all available targets (default)</td>
</tr>
<tr>
<td><code>make build</code></td>
<td>Full build: UI + Go binary</td>
</tr>
<tr>
<td><code>make build-ui</code></td>
<td>Build UI and copy to embed location</td>
</tr>
<tr>
<td><code>make build-go</code></td>
<td>Build Go binary only (skip UI rebuild)</td>
</tr>
<tr>
<td><code>make install</code></td>
<td>Full build and install to <code>~/.local/bin</code></td>
</tr>
<tr>
<td><code>make test</code></td>
<td>Run all Go tests</td>
</tr>
<tr>
<td><code>make test-unit</code></td>
<td>Run unit tests only (fast)</td>
</tr>
<tr>
<td><code>make test-integration</code></td>
<td>Run integration tests</td>
</tr>
<tr>
<td><code>make test-coverage</code></td>
<td>Generate coverage report to <code>output/</code></td>
</tr>
<tr>
<td><code>make test-verbose</code></td>
<td>Run tests with verbose output</td>
</tr>
<tr>
<td><code>make fmt</code></td>
<td>Format Go code</td>
</tr>
<tr>
<td><code>make fmt-md</code></td>
<td>Format Markdown files with prettier</td>
</tr>
<tr>
<td><code>make fmt-all</code></td>
<td>Format all files (Go + Markdown)</td>
</tr>
<tr>
<td><code>make lint</code></td>
<td>Run golangci-lint</td>
</tr>
<tr>
<td><code>make lint-fix</code></td>
<td>Run golangci-lint with auto-fix</td>
</tr>
<tr>
<td><code>make lint-md</code></td>
<td>Run markdownlint</td>
</tr>
<tr>
<td><code>make lint-md-fix</code></td>
<td>Run markdownlint with auto-fix</td>
</tr>
<tr>
<td><code>make lint-all</code></td>
<td>Run all linters (Go + Markdown)</td>
</tr>
<tr>
<td><code>make vet</code></td>
<td>Run <code>go vet</code></td>
</tr>
<tr>
<td><code>make tidy</code></td>
<td>Tidy Go dependencies</td>
</tr>
<tr>
<td><code>make clean</code></td>
<td>Remove build artifacts (<code>output/</code>, <code>bin/</code>, <code>dist/</code>)</td>
</tr>
<tr>
<td><code>make install-tools</code></td>
<td>Install dev tools (golangci-lint, markdownlint-cli)</td>
</tr>
<tr>
<td><code>make quick-check</code></td>
<td>Fast pre-commit checks: format, vet, test, build</td>
</tr>
<tr>
<td><code>make ci</code></td>
<td>Full CI checks: format-all, lint-all, vet, test, build</td>
</tr>
<tr>
<td><code>make pre-commit</code></td>
<td>Alias for <code>quick-check</code></td>
</tr>
<tr>
<td><code>make pre-push</code></td>
<td>Alias for <code>ci</code></td>
</tr>
</tbody></table>
<h2>Common Tasks</h2>
<h3>Adding a New Event Type</h3>
<ol>
<li>Define event struct in <code>internal/types/events.go</code></li>
<li>Add handler in <code>internal/projection/projector.go</code></li>
<li>Add case in the <code>Apply()</code> switch statement</li>
<li>Write tests in <code>internal/projection/projector_test.go</code></li>
</ol>
<p>Current event types handled by the projector:</p>
<ul>
<li><code>message.create</code>, <code>message.edit</code>, <code>message.delete</code></li>
<li><code>agent.register</code></li>
<li><code>agent.session.start</code>, <code>agent.session.end</code></li>
<li><code>agent.update</code></li>
</ul>
<p>Example:</p>
<pre><code>// 1. Define event type in internal/types/events.go
type MyNewEvent struct {
    BaseEvent
    MyField string `json:&quot;my_field&quot;`
}

// 2. Add handler in internal/projection/projector.go
func (p *Projector) applyMyNew(data json.RawMessage) error {
    var event types.MyNewEvent
    if err := json.Unmarshal(data, &amp;event); err != nil {
        return fmt.Errorf(&quot;unmarshal my.new: %w&quot;, err)
    }

    // Insert/update database
    _, err := p.db.Exec(`...`)
    return err
}

// 3. Update switch in Apply()
case &quot;my.new&quot;:
    return p.applyMyNew(event)</code></pre>
<h3>Modifying Database Schema</h3>
<ol>
<li>Update table definitions in <code>internal/schema/schema.go</code></li>
<li>Increment <code>CurrentVersion</code> constant (currently v7)</li>
<li>Add migration logic in the <code>Migrate()</code> function</li>
<li>Write tests for the new schema</li>
<li>Update <code>docs/architecture.md</code></li>
</ol>
<h3>Testing with Temporary Databases</h3>
<pre><code>func TestMyFeature(t *testing.T) {
    // Create temp database
    tmpDir := t.TempDir()
    dbPath := filepath.Join(tmpDir, &quot;test.db&quot;)

    db, _ := schema.OpenDB(dbPath)
    defer db.Close()

    schema.InitDB(db)

    // Test your feature
    // ...
}</code></pre>
<h3>Adding a New RPC Method</h3>
<ol>
<li>Create handler file in <code>internal/daemon/rpc/</code>:</li>
</ol>
<pre><code>// internal/daemon/rpc/mymethod.go
package rpc

import (
    &quot;context&quot;
    &quot;encoding/json&quot;
)

type MyMethodHandler struct {
    // dependencies
}

func NewMyMethodHandler(deps...) *MyMethodHandler {
    return &amp;MyMethodHandler{...}
}

func (h *MyMethodHandler) Handle(ctx context.Context, params json.RawMessage) (any, error) {
    // Parse params
    var args MyMethodArgs
    if err := json.Unmarshal(params, &amp;args); err != nil {
        return nil, fmt.Errorf(&quot;invalid params: %w&quot;, err)
    }

    // Implementation
    result := MyMethodResponse{
        // ...
    }

    return result, nil
}</code></pre>
<ol start="2">
<li><p>Add tests in <code>internal/daemon/rpc/mymethod_test.go</code></p>
</li>
<li><p>Register in daemon startup (in <code>cmd/thrum/main.go</code>):</p>
</li>
</ol>
<pre><code>myMethodHandler := rpc.NewMyMethodHandler()
server.RegisterHandler(&quot;mymethod&quot;, myMethodHandler.Handle)</code></pre>
<ol start="4">
<li>Update documentation in <code>docs/rpc-api.md</code></li>
</ol>
<h2>Environment Variables</h2>
<p>Configuration is resolved in priority order:</p>
<ol>
<li><code>THRUM_NAME</code> env var to select which identity file (highest priority)</li>
<li>Environment variables: <code>THRUM_ROLE</code>, <code>THRUM_MODULE</code>, <code>THRUM_DISPLAY</code></li>
<li>CLI flags (<code>--role</code>, <code>--module</code>, <code>--name</code>)</li>
<li>Identity file in <code>.thrum/identities/{name}.json</code></li>
<li>Error if required fields are missing</li>
</ol>
<pre><code># Select a named agent identity
export THRUM_NAME=furiosa

# Or set agent properties directly
export THRUM_ROLE=implementer
export THRUM_MODULE=auth
export THRUM_DISPLAY=&quot;Auth Agent&quot;</code></pre>
<p>Identity files are stored per-agent at <code>.thrum/identities/{name}.json</code> and
contain repo ID, agent config, worktree name, and metadata.</p>
<h2>Storage Layout</h2>
<p>Thrum uses a split storage model:</p>
<pre><code>.git/thrum-sync/a-sync/              # Sync worktree (a-sync orphan branch)
├── events.jsonl                     # Agent lifecycle events (register, session, update)
└── messages/                        # Per-agent message files (sharded)
    ├── furiosa.jsonl                # Messages authored by agent &quot;furiosa&quot;
    └── coordinator.jsonl            # Messages authored by agent &quot;coordinator&quot;

.thrum/                              # Runtime directory (gitignored)
├── var/
│   ├── messages.db                  # SQLite projection cache (rebuilt from JSONL)
│   ├── thrum.sock                   # Unix socket for daemon RPC
│   ├── thrum.pid                    # JSON PID file with repo-affinity metadata
│   └── ws.port                      # WebSocket port file (default 9999)
├── identities/                      # Per-agent identity files
│   └── {name}.json                  # Agent identity (repo_id, role, module, etc.)
└── redirect                         # Points to main worktree .thrum/ (feature worktrees only)</code></pre>
<h3>Inspecting JSONL Files</h3>
<pre><code># View all events (agent lifecycle)
cat .git/thrum-sync/a-sync/events.jsonl | jq .

# View messages for a specific agent
cat .git/thrum-sync/a-sync/messages/furiosa.jsonl | jq .

# Filter by event type
cat .git/thrum-sync/a-sync/events.jsonl | jq &#39;select(.type == &quot;agent.register&quot;)&#39;

# Count events
wc -l .git/thrum-sync/a-sync/events.jsonl</code></pre>
<h3>Inspecting the SQLite Database</h3>
<pre><code># Open database
sqlite3 .thrum/var/messages.db

# List tables
.tables

# Query messages
SELECT * FROM messages LIMIT 10;

# Check schema version
SELECT * FROM schema_version;</code></pre>
<h2>Daemon Development</h2>
<h3>Daemon Architecture</h3>
<p>The daemon runs as a background service handling client connections via Unix
socket, with a WebSocket server and embedded SPA all on a single port (default
9999).</p>
<p><strong>Key components:</strong></p>
<ul>
<li><strong>Server</strong> (<code>internal/daemon/server.go</code>): JSON-RPC 2.0 over Unix socket</li>
<li><strong>Lifecycle</strong> (<code>internal/daemon/lifecycle.go</code>): Signal handling, defer cleanup
safety net, flock-based process detection</li>
<li><strong>PID file</strong> (<code>internal/daemon/pidfile.go</code>): JSON format with <code>PIDInfo</code> struct
(PID, repo path, socket path, started at). Backward-compatible reader falls
back to plain integer format.</li>
<li><strong>File lock</strong> (<code>internal/daemon/flock.go</code>, <code>flock_unix.go</code>): OS-level
<code>flock()</code> on socket file. Auto-released on process death (even SIGKILL). No-op
stubs for non-Unix platforms.</li>
<li><strong>State</strong> (<code>internal/daemon/state/</code>): Manages JSONL writes (sharded per-agent)
and SQLite projection. <code>NewState(thrumDir, syncDir, repoID)</code> separates runtime
state from sync data.</li>
<li><strong>RPC handlers</strong> (<code>internal/daemon/rpc/</code>): Method implementations for agent,
session, message, thread, health, sync, subscribe, and user operations</li>
<li><strong>Client</strong> (<code>internal/daemon/client.go</code>): Connection library for CLI-to-daemon
communication</li>
<li><strong>WebSocket</strong> (<code>internal/websocket/</code>): Server, connection registry, event
streaming</li>
<li><strong>Web</strong> (<code>internal/web/embed.go</code>): Embedded SPA served at <code>/</code> on the same port
as WebSocket (<code>/ws</code>)</li>
</ul>
<p>See <code>docs/daemon.md</code> for detailed architecture.</p>
<h3>Running the Daemon</h3>
<pre><code># Start daemon (background, auto-creates sync worktree)
thrum daemon start

# Start in foreground (for debugging)
thrum daemon start --foreground

# Check status (shows PID, repo path, WebSocket port)
thrum daemon status

# Stop daemon
thrum daemon stop

# Auto-start (happens automatically via any CLI command)
thrum send &quot;Hello&quot; --to @coordinator</code></pre>
<h3>Testing Daemon Code</h3>
<pre><code># Run daemon tests
go test ./internal/daemon/...

# With coverage
go test -cover ./internal/daemon/...

# RPC handler tests
go test ./internal/daemon/rpc/... -v

# State tests
go test ./internal/daemon/state/... -v</code></pre>
<p>Use the <code>StartTestDaemon()</code> helper in <code>internal/daemon/testutil_test.go</code> for
integration tests. It provides automatic <code>t.Cleanup()</code> with force-kill to
prevent test orphan processes on timeout or panic.</p>
<h3>Debugging Daemon</h3>
<p><strong>Check if daemon is running:</strong></p>
<pre><code># Check PID file (JSON format)
cat .thrum/var/thrum.pid | jq .

# Check process
ps aux | grep thrum

# Check socket
ls -l .thrum/var/thrum.sock</code></pre>
<p><strong>Test RPC calls manually:</strong></p>
<pre><code># Using netcat
echo &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;health&quot;,&quot;id&quot;:1}&#39; | nc -U .thrum/var/thrum.sock</code></pre>
<p><strong>View daemon logs:</strong></p>
<pre><code># Run daemon in foreground for debugging
thrum daemon start --foreground
# Logs appear in stdout/stderr</code></pre>
<p><strong>Clean restart:</strong></p>
<pre><code># Stop daemon
thrum daemon stop

# Remove stale files if needed
rm .thrum/var/thrum.sock
rm .thrum/var/thrum.pid

# Restart
thrum daemon start</code></pre>
<h3>Common Daemon Issues</h3>
<p><strong>Socket path too long:</strong></p>
<ul>
<li>Unix sockets limited to ~104 characters</li>
<li>Use shorter temp directory paths in tests</li>
<li>Example: <code>filepath.Join(tmpDir, &quot;d.sock&quot;)</code> not
<code>filepath.Join(tmpDir, &quot;.thrum&quot;, &quot;var&quot;, &quot;thrum.sock&quot;)</code></li>
</ul>
<p><strong>Permission denied:</strong></p>
<ul>
<li>Socket should be 0600 (owner only)</li>
<li>Check <code>.thrum/var/</code> directory permissions</li>
</ul>
<p><strong>Bind: address already in use:</strong></p>
<ul>
<li>Another daemon already running</li>
<li>Pre-startup duplicate detection validates no existing daemon serves this repo</li>
<li>Check PID file and kill process</li>
<li>Remove stale socket file</li>
</ul>
<p><strong>Connection refused:</strong></p>
<ul>
<li>Daemon not running</li>
<li>Check PID file exists</li>
<li>Verify socket file exists</li>
</ul>
<h2>MCP Server Development</h2>
<p>The MCP server (<code>thrum mcp serve</code>) provides native MCP tools for Claude Code
agents instead of shelling out to the CLI. It uses stdio transport (JSON-RPC
over stdin/stdout).</p>
<p><strong>Key files:</strong></p>
<ul>
<li><code>internal/mcp/server.go</code>: Server skeleton and tool registration</li>
<li><code>internal/mcp/tools.go</code>: Tool handler implementations</li>
<li><code>internal/mcp/types.go</code>: Request/response type definitions</li>
<li><code>internal/mcp/waiter.go</code>: WebSocket-based blocking message waiter</li>
<li><code>cmd/thrum/mcp.go</code>: <code>thrum mcp serve</code> Cobra command</li>
</ul>
<p><strong>MCP Tools (5):</strong></p>
<table>
<thead>
<tr>
<th>Tool</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>send_message</code></td>
<td>Send a message to another agent via @role addressing</td>
</tr>
<tr>
<td><code>check_messages</code></td>
<td>Poll for unread messages mentioning this agent</td>
</tr>
<tr>
<td><code>wait_for_message</code></td>
<td>Block until a message arrives (WebSocket push) or timeout</td>
</tr>
<tr>
<td><code>list_agents</code></td>
<td>List registered agents with active/offline status</td>
</tr>
<tr>
<td><code>broadcast_message</code></td>
<td>Send to all agents (convenience wrapper around <code>send_message</code> to <code>@everyone</code>)</td>
</tr>
</tbody></table>
<p><strong>Architecture:</strong></p>
<ul>
<li>Per-call <code>cli.Client</code> creation (thread-safe; Unix socket connections are
cheap)</li>
<li>WebSocket waiter with atomic incrementing JSON-RPC IDs</li>
<li>Identity resolved at startup from <code>.thrum/identities/{name}.json</code></li>
<li><code>THRUM_NAME</code> env var or <code>--agent-id</code> flag for multi-agent worktrees</li>
</ul>
<pre><code># Start MCP server
thrum mcp serve

# Override agent identity
thrum mcp serve --agent-id furiosa</code></pre>
<h2>Sync Engine</h2>
<p>The sync engine runs in the daemon, performing fetch/merge/push every 60 seconds
(configurable via <code>--sync-interval</code>).</p>
<p><strong>Key files:</strong></p>
<ul>
<li><code>internal/sync/loop.go</code>: <code>SyncLoop</code> with periodic and manual sync triggers</li>
<li><code>internal/sync/merge.go</code>: JSONL merge with deduplication (ULID event_id)</li>
<li><code>internal/sync/push.go</code>: Git push to remote</li>
<li><code>internal/sync/branch.go</code>: Safe orphan branch creation via <code>git commit-tree</code> +
<code>git update-ref</code>, sync worktree with sparse checkout, 4-level health checks</li>
<li><code>internal/sync/dedup.go</code>: Event deduplication by event_id</li>
</ul>
<p><strong>Sync worktree location:</strong> <code>.git/thrum-sync/a-sync/</code> (uses <code>git-common-dir</code> for
nested worktree support).</p>
<p><strong>Sparse checkout patterns:</strong> <code>/events.jsonl</code>, <code>/messages/</code>, <code>/messages.jsonl</code>
(migration compat).</p>
<h2>Worktree Setup</h2>
<p>Thrum supports multiple git worktrees sharing a single daemon and data store via
the <code>.thrum/redirect</code> mechanism. Feature worktrees point to the main worktree&#39;s
<code>.thrum/</code> directory so all worktrees share one daemon, one SQLite database, and
one set of JSONL files.</p>
<h3>Setting Up a Worktree</h3>
<pre><code># Option 1: Use the thrum setup command
thrum setup /path/to/worktree

# Option 2: Use the setup script
./scripts/setup-worktree-thrum.sh /path/to/worktree

# Option 3: Manual setup
mkdir -p /path/to/worktree/.thrum/identities
echo &quot;/path/to/main/repo/.thrum&quot; &gt; /path/to/worktree/.thrum/redirect</code></pre>
<h3>Beads Issue Tracking for Worktrees</h3>
<p>All worktrees should share the same beads issue database:</p>
<pre><code># Use the setup script
./scripts/setup-worktree-beads.sh /path/to/worktree

# Or manual setup
mkdir -p /path/to/worktree/.beads
echo &quot;/path/to/main/repo/.beads&quot; &gt; /path/to/worktree/.beads/redirect

# Verify
cd /path/to/worktree &amp;&amp; bd where</code></pre>
<h2>Testing Best Practices</h2>
<h3>1. Use Table-Driven Tests</h3>
<pre><code>tests := []struct {
    name string
    input string
    want string
}{
    {&quot;case 1&quot;, &quot;input1&quot;, &quot;expected1&quot;},
    {&quot;case 2&quot;, &quot;input2&quot;, &quot;expected2&quot;},
}

for _, tt := range tests {
    t.Run(tt.name, func(t *testing.T) {
        got := MyFunction(tt.input)
        if got != tt.want {
            t.Errorf(&quot;got %v, want %v&quot;, got, tt.want)
        }
    })
}</code></pre>
<h3>2. Clean Up Resources</h3>
<pre><code>// Use t.TempDir() for automatic cleanup
tmpDir := t.TempDir()

// Or defer cleanup
db, _ := schema.OpenDB(dbPath)
defer db.Close()</code></pre>
<h3>3. Test Error Cases</h3>
<pre><code>// Test both happy path and error cases
_, err := MyFunction(invalidInput)
if err == nil {
    t.Error(&quot;expected error, got nil&quot;)
}</code></pre>
<h3>4. Use StartTestDaemon for Integration Tests</h3>
<pre><code>// Automatically cleans up on test completion (even on panic/timeout)
daemon := StartTestDaemon(t, tmpDir)
defer daemon.Stop()</code></pre>
<h2>Code Style</h2>
<ul>
<li><strong>Formatting</strong>: Use <code>go fmt</code> (or <code>gofmt -s</code>)</li>
<li><strong>Imports</strong>: Group stdlib, external, internal</li>
<li><strong>Comments</strong>: Document exported functions and types</li>
<li><strong>Error messages</strong>: Lowercase, no punctuation, wrap with <code>fmt.Errorf</code></li>
<li><strong>Variable names</strong>: Short, descriptive (e.g., <code>db</code>, <code>cfg</code>, <code>msg</code>)</li>
</ul>
<h2>Git Workflow</h2>
<pre><code># Create feature branch
git checkout -b feature/my-feature

# Make changes and test
go test ./...

# Commit
git add .
git commit -m &quot;Add my feature&quot;

# Push
git push origin feature/my-feature

# Create PR
gh pr create</code></pre>
<h2>Troubleshooting</h2>
<h3>&quot;no such table&quot; error</h3>
<p>The SQLite projection database is a rebuild-able cache. Delete it and restart
the daemon to rebuild from JSONL:</p>
<pre><code>rm .thrum/var/messages.db
thrum daemon stop
thrum daemon start</code></pre>
<h3>&quot;cannot open file&quot; error</h3>
<p>Check file permissions and directory existence:</p>
<pre><code>ls -la .thrum/
ls -la .thrum/var/</code></pre>
<h3>Tests fail with &quot;database is locked&quot;</h3>
<p>Close any open SQLite connections or delete WAL files:</p>
<pre><code>rm .thrum/var/*.db-wal
rm .thrum/var/*.db-shm</code></pre>
<h3>Daemon won&#39;t start (duplicate detection)</h3>
<p>The daemon validates no existing instance serves the same repository before
starting. Check for a stale PID file:</p>
<pre><code>cat .thrum/var/thrum.pid | jq .
# If the process is dead, remove the PID file
rm .thrum/var/thrum.pid
thrum daemon start</code></pre>
<h3><code>go build</code> fails with embed error</h3>
<p>If the UI has not been built, <code>internal/web/dist/</code> needs at least a <code>.gitkeep</code>
file:</p>
<pre><code>touch internal/web/dist/.gitkeep</code></pre>
<p>Or build the UI first: <code>make build-ui</code></p>
<h2>Key Dependencies</h2>
<table>
<thead>
<tr>
<th>Dependency</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/spf13/cobra">cobra</a></td>
<td>CLI command framework</td>
</tr>
<tr>
<td><a href="https://pkg.go.dev/modernc.org/sqlite">modernc.org/sqlite</a></td>
<td>Pure Go SQLite driver</td>
</tr>
<tr>
<td><a href="https://github.com/oklog/ulid">oklog/ulid</a></td>
<td>ULID generation for event IDs</td>
</tr>
<tr>
<td><a href="https://github.com/gorilla/websocket">gorilla/websocket</a></td>
<td>WebSocket server</td>
</tr>
<tr>
<td><a href="https://github.com/modelcontextprotocol/go-sdk">go-sdk (MCP)</a></td>
<td>MCP server SDK</td>
</tr>
</tbody></table>
<h2>Resources</h2>
<ul>
<li><strong>Architecture</strong>: <code>docs/architecture.md</code></li>
<li><strong>Daemon Architecture</strong>: <code>docs/daemon.md</code></li>
<li><strong>RPC API Reference</strong>: <code>docs/rpc-api.md</code></li>
<li><strong>Sync Design</strong>: <code>docs/sync.md</code></li>
<li><strong>Quickstart Guide</strong>: <code>docs/quickstart.md</code></li>
<li><strong>CLI Reference</strong>: <code>docs/cli.md</code></li>
<li><strong>Identity System</strong>: <code>docs/identity.md</code></li>
<li><strong>Workflow Templates</strong>: <code>docs/workflow-templates.md</code> (structured feature
development with AI agents)</li>
<li><strong>Agent Reference</strong>: <code>llms.txt</code> (concise) and <code>llms-full.txt</code> (detailed)</li>
</ul>
<pre><code></code></pre>

</main>
<script>if(location.search.indexOf('nospa')===-1){location.replace('../docs.html#development.html')}</script>
</body>
</html>