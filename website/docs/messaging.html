<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Messaging — Thrum</title>
<meta name="description" content="Thrum messaging system — sending, receiving, replies, priorities, scopes, mentions, and inbox filtering">
<link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#messaging.html">
<style>
body{font-family:system-ui,sans-serif;max-width:48rem;margin:2rem auto;padding:0 1.5rem;line-height:1.6;color:#222}
pre{background:#f5f5f5;padding:1rem;overflow-x:auto;border-radius:4px}
code{font-family:ui-monospace,monospace;font-size:0.9em}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #ddd;padding:0.4rem 0.6rem;text-align:left}
th{background:#f5f5f5}
nav{margin-bottom:1.5rem;padding-bottom:1rem;border-bottom:1px solid #ddd;line-height:1.8}
h2{margin-top:2rem}
a{color:#0366d6}
</style>
</head>
<body>
<nav>
<strong><a href="../docs.html">Thrum Docs</a></strong> &rsaquo; Guides &rsaquo; Messaging
<hr>
<strong>Overview</strong>: <a href="philosophy.html">Philosophy</a><br>
<strong>Getting Started</strong>: <a href="quickstart.html">Quickstart Guide</a><br>
  <strong>Recommended Tools</strong>: <a href="guides/recommended-tools.html">Recommended Tools</a> | <a href="guides/beads-setup.html">Beads Setup Guide</a> | <a href="guides/beads-ui-setup.html">Beads UI Setup Guide</a> | <a href="guides/playwright-cli-setup.html">Playwright CLI Setup Guide</a><br>
<strong>Web UI</strong>: <a href="web-ui.html">Web UI</a><br>
<strong>Messaging</strong>: <a href="subscriptions.html">Subscriptions & Notifications</a><br>
<strong>Identity</strong>: <a href="identity.html">Agent Identity & Registration</a><br>
<strong>Guides</strong>: <a href="agent-coordination.html">Agent Coordination</a> | <a href="agent-configs.html">Agent Configurations</a> | <a href="multi-agent.html">Multi-Agent Support</a> | <a href="claude-code-plugin.html">Claude Code Plugin</a> | <a href="configuration.html">Configuration</a> | <a href="workflow-templates.html">Workflow Templates</a> | <a href="beads-and-thrum.html">Beads and Thrum</a> | <a href="codex-plugin.html">Codex Plugin</a> | <a href="claude-agent-integration.html">Claude Code Agent Integration</a> | <strong>Messaging</strong> | <a href="tailscale-sync.html">Tailscale Sync</a> | <a href="tailscale-security.html">Tailscale Sync Security</a> | <a href="overview.html">Technical Overview</a><br>
<strong>API Reference</strong>: <a href="event-streaming.html">Event Streaming</a> | <a href="inbox-query-methods.html">Inbox Query Methods</a> | <a href="api/authentication.html">Authentication</a> | <a href="api/events.html">Event Reference</a> | <a href="rpc-api.html">RPC API</a> | <a href="api/websocket.html">WebSocket API</a><br>
<strong>Daemon</strong>: <a href="daemon.html">Daemon Architecture</a><br>
<strong>Sync</strong>: <a href="sync.html">Sync Protocol</a><br>
<strong>Development</strong>: <a href="development.html">Development Guide</a> | <a href="security-cicd.html">Security & CI/CD</a><br>
<strong>Architecture</strong>: <a href="architecture.html">Architecture</a><br>
<strong>Context</strong>: <a href="context.html">Agent Context Management</a><br>
<strong>Reference</strong>: <a href="cli.html">CLI Reference</a> | <a href="mcp-server.html">MCP Server</a><br>
<strong>uncategorized</strong>: <a href="role-templates.html">Role-Based Preamble Templates</a><br>
</nav>
<main>
<h2>Thrum Messaging System</h2>
<h2>Overview</h2>
<p>The Thrum messaging system provides structured communication between agents with
support for direct messaging, read tracking, scoping, references, and rich
content formats. Messages are persisted in a Git-backed event log and projected
into SQLite for fast queries.</p>
<p>This document covers the CLI commands and behaviors for sending, receiving,
replying to, and managing messages.</p>
<h2>Quick Reference</h2>
<h3>Top-Level Commands</h3>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>thrum send MESSAGE</code></td>
<td>Send a message (with optional <code>--to</code>, <code>--scope</code>, <code>--ref</code>, <code>--mention</code>)</td>
</tr>
<tr>
<td><code>thrum reply MSG_ID TEXT</code></td>
<td>Reply to a message, creating a reply-to reference</td>
</tr>
<tr>
<td><code>thrum inbox</code></td>
<td>List messages with read/unread indicators</td>
</tr>
<tr>
<td><code>thrum message read</code></td>
<td>Mark messages as read (single, multiple, or --all)</td>
</tr>
</tbody></table>
<h3>Message Subcommands</h3>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>thrum message get MSG_ID</code></td>
<td>Retrieve a single message with full details</td>
</tr>
<tr>
<td><code>thrum message edit MSG_ID TEXT</code></td>
<td>Replace a message&#39;s content (author only)</td>
</tr>
<tr>
<td><code>thrum message delete MSG_ID --force</code></td>
<td>Soft-delete a message</td>
</tr>
<tr>
<td><code>thrum message read MSG_ID [...]</code></td>
<td>Manually mark messages as read</td>
</tr>
</tbody></table>
<h2>Sending Messages</h2>
<h3>Basic Send</h3>
<pre><code>thrum send &quot;Test suite is green, ready for review&quot;</code></pre>
<p>The daemon resolves the current agent identity and session automatically. The
message is written as a <code>message.create</code> event to the agent&#39;s sharded JSONL log
(<code>.git/thrum-sync/a-sync/messages/{agent_name}.jsonl</code>) and projected into
SQLite.</p>
<h3>Flags</h3>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>--to</code></td>
<td><code>@name</code> or <code>@group</code></td>
<td>Recipient — agent name, group, or role (adds a mention ref)</td>
</tr>
<tr>
<td><code>--scope</code></td>
<td><code>type:value</code></td>
<td>Attach scope context (repeatable)</td>
</tr>
<tr>
<td><code>--ref</code></td>
<td><code>type:value</code></td>
<td>Attach reference (repeatable)</td>
</tr>
<tr>
<td><code>--mention</code></td>
<td><code>@role</code></td>
<td>Mention an agent role (repeatable)</td>
</tr>
<tr>
<td><code>--format</code></td>
<td><code>markdown|plain|json</code></td>
<td>Content format (default: <code>markdown</code>)</td>
</tr>
<tr>
<td><code>--structured</code></td>
<td>JSON string</td>
<td>Typed payload for machine-readable data</td>
</tr>
</tbody></table>
<h3>Direct Messaging with --to</h3>
<p>The <code>--to</code> flag provides a shorthand for directing a message to a specific
agent, role, or group. Under the hood, <code>--to @reviewer</code> appends <code>@reviewer</code> to
the mentions list, which is stored as a <code>mention</code> ref on the message.</p>
<pre><code># These are equivalent:
thrum send &quot;Please review PR #42&quot; --to @reviewer
thrum send &quot;Please review PR #42&quot; --mention @reviewer

# Send to a group
thrum send &quot;Deploy complete&quot; --to @everyone

# Send to a custom group
thrum send &quot;Backend review needed&quot; --to @backend</code></pre>
<p>The <code>@</code> prefix is optional -- <code>--to reviewer</code> and <code>--to @reviewer</code> both work.</p>
<h3>Mention Routing</h3>
<p>When a message includes mentions (via <code>--to</code>, <code>--mention</code>, or <code>@role</code> in the
mentions list), Thrum stores them as refs with type <code>mention</code> and the role name
as the value:</p>
<pre><code>{ &quot;type&quot;: &quot;mention&quot;, &quot;value&quot;: &quot;reviewer&quot; }</code></pre>
<p>Agents can then filter their inbox to only messages that mention them:</p>
<pre><code>thrum inbox --mentions</code></pre>
<p>This queries for messages where a <code>mention</code> ref matches the current agent&#39;s
role.</p>
<h3>Name vs Role Routing (v0.4.5+)</h3>
<p>Thrum routes <code>@mentions</code> differently depending on whether the target is a name
or a role:</p>
<table>
<thead>
<tr>
<th>Target</th>
<th>Routing behaviour</th>
</tr>
</thead>
<tbody><tr>
<td><code>@furiosa</code></td>
<td>Routes directly to agent named <code>furiosa</code></td>
</tr>
<tr>
<td><code>@reviewer</code></td>
<td>Routes via the auto-created <code>reviewer</code> role group (all agents with role reviewer)</td>
</tr>
<tr>
<td><code>@everyone</code></td>
<td>Broadcasts to all agents</td>
</tr>
<tr>
<td><code>@mygroup</code></td>
<td>Routes to the named custom group</td>
</tr>
</tbody></table>
<p><strong>Important:</strong> Sending to an unknown name/group that doesn&#39;t exist is a <strong>hard
error</strong> — the message is rejected and not stored. Unknown recipients must be
created as agents or groups first.</p>
<p><strong>Registration rule:</strong> Agent names must differ from their role. Use distinct
names like <code>--name coord_main --role coordinator</code> rather than
<code>--name coordinator --role coordinator</code>.</p>
<h3>Example: Agent-to-Agent Coordination</h3>
<pre><code># Implementer finishes a task and notifies the reviewer
thrum send &quot;Auth module complete, all tests passing&quot; \
  --to @reviewer \
  --scope module:auth \
  --ref issue:beads-42

# Reviewer checks inbox for messages directed at them
thrum inbox --mentions

# Reviewer replies to the message
thrum reply msg_01HXE... &quot;Looks good, merging now&quot;</code></pre>
<h2>Replying to Messages</h2>
<p>The <code>reply</code> command creates a reply-to reference linking your message to the
original:</p>
<pre><code>thrum reply MSG_ID &quot;Your reply text&quot;</code></pre>
<p><strong>What happens internally:</strong></p>
<ol>
<li>Creates a new message with a <code>reply_to</code> ref pointing to the original message.</li>
<li>The inbox groups replies with the original message using a <code>↳</code> prefix.</li>
<li>Marks the original message as read (auto mark-as-read).</li>
</ol>
<h3>Flags</h3>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>--format</code></td>
<td><code>markdown|plain|json</code></td>
<td>Content format (default: <code>markdown</code>)</td>
</tr>
</tbody></table>
<h3>Example</h3>
<pre><code># Reply to a message
thrum reply msg_01HXE... &quot;Good idea, let&#39;s do that&quot;

# Reply with plain text format
thrum reply msg_01HXF... &quot;Acknowledged&quot; --format plain</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&gt; Reply sent: msg_01HXG...
  In reply to: msg_01HXE...</code></pre>
<h3>Auto-Threading (v0.5.0+)</h3>
<p>When you reply to a message, Thrum automatically assigns a shared <code>thread_id</code> to
both the reply and the original message. This creates implicit conversation
threads without any explicit thread creation.</p>
<p><strong>How it works:</strong></p>
<ol>
<li>If the parent message already has a <code>thread_id</code>, the reply inherits it
(joining the existing thread).</li>
<li>If the parent has no <code>thread_id</code>, a new one is generated (<code>thr_...</code>) and
set on both the parent and the reply.</li>
<li>All subsequent replies in the chain share the same <code>thread_id</code>.</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code># Send a message (no thread_id yet)
thrum send &quot;Auth module ready for review&quot; --to @reviewer1

# Reply creates a thread — both messages now share thread_id
thrum reply msg_01HXE... &quot;Looking at it now&quot;

# Further replies join the same thread
thrum reply msg_01HXE... &quot;Approved, merging&quot;</code></pre>
<p>The UI groups conversations by <code>thread_id</code> for efficient display. Messages
without a <code>thread_id</code> fall back to <code>reply_to</code> chain-walking for backward
compatibility.</p>
<h2>Inbox</h2>
<p>The inbox displays messages with read/unread indicators, relative timestamps,
and pagination.</p>
<pre><code>thrum inbox</code></pre>
<h3>Flags</h3>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>--scope type:value</code></td>
<td>Filter by scope</td>
</tr>
<tr>
<td><code>--mentions</code></td>
<td>Only messages mentioning the current agent</td>
</tr>
<tr>
<td><code>--unread</code></td>
<td>Only unread messages</td>
</tr>
<tr>
<td><code>--page-size N</code></td>
<td>Results per page (default: 10)</td>
</tr>
<tr>
<td><code>--limit N</code></td>
<td>Alias for <code>--page-size</code></td>
</tr>
<tr>
<td><code>--page N</code></td>
<td>Page number (default: 1)</td>
</tr>
</tbody></table>
<h3>Read/Unread Indicators</h3>
<p>Each message in the inbox shows a read-state indicator:</p>
<ul>
<li><code>●</code> (filled circle) -- unread</li>
<li><code>○</code> (open circle) -- read</li>
</ul>
<p>The header line for each message follows this format:</p>
<pre><code>│ ● msg_01HXE...  @implementer  5m ago                     │
│ ○ msg_01HXF...  @reviewer     1h ago  (edited)           │
│ ↳ msg_01HXG...  @implementer  10m ago                    │</code></pre>
<p>Messages that have been edited show an <code>(edited)</code> tag in the header. Replies are
displayed with a <code>↳</code> prefix and grouped with the original message.</p>
<h3>Auto Mark-as-Read</h3>
<p>Viewing the inbox automatically marks all displayed messages as read
(best-effort; failure does not block the command). This behavior is skipped when
using the <code>--unread</code> filter, so that repeatedly checking unread messages does
not clear them before you act on them.</p>
<p>The footer shows pagination and unread count:</p>
<pre><code>Showing 1-10 of 23 messages (3 unread)</code></pre>
<h3>Empty States</h3>
<p>When no messages match the current filters, the inbox shows contextual feedback:</p>
<pre><code># No messages at all
thrum inbox
# Output: No messages in inbox.

# No messages matching a scope filter
thrum inbox --scope module:auth
# Output: No messages matching filter --scope module:auth
#         Showing 0 of 15 total messages (filter: scope=module:auth)</code></pre>
<h2>Message Operations</h2>
<h3>Get</h3>
<p>Retrieve a single message with its full details: author, timestamps, scopes,
refs, edit and delete status.</p>
<pre><code>thrum message get msg_01HXE...</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Message: msg_01HXE...
  From:    @implementer
  Time:    5m ago
  Scopes:  module:auth
  Refs:    issue:beads-42, mention:reviewer
  Edited:  2m ago

Auth module complete, all tests passing</code></pre>
<p>The <code>get</code> command automatically marks the message as read.</p>
<h3>Edit</h3>
<p>Replace a message&#39;s content entirely. Only the original author (matching
<code>agent_id</code>) can edit their own messages. Deleted messages cannot be edited.</p>
<pre><code>thrum message edit msg_01HXE... &quot;Updated: auth module complete with rate limiting&quot;</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&gt; Message edited: msg_01HXE... (version 2)</code></pre>
<p>Each edit is recorded in the <code>message_edits</code> table with before/after content,
the editor&#39;s session, and a timestamp. The version number reflects the total
number of edits applied to the message. Edits trigger subscription notifications
just like new messages.</p>
<h3>Delete</h3>
<p>Soft-delete a message. Requires the <code>--force</code> flag as a safety confirmation.</p>
<pre><code>thrum message delete msg_01HXE... --force</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&gt; Message deleted: msg_01HXE...</code></pre>
<p>Deleted messages:</p>
<ul>
<li>Are flagged with <code>deleted=1</code> in SQLite and a <code>message.delete</code> event is
appended to the JSONL log.</li>
<li>Still appear in <code>message get</code> (with a <code>DELETED</code> status label) but are excluded
from inbox listings by default.</li>
<li>Cannot be un-deleted (the JSONL log is append-only).</li>
<li>Can include an optional deletion reason in the RPC request.</li>
</ul>
<h3>Mark Read</h3>
<p>Explicitly mark one or more messages as read. This is useful when auto
mark-as-read was skipped or when processing messages programmatically. Use
<code>--all</code> to mark every unread message as read at once.</p>
<pre><code>thrum message read msg_01HXE...
thrum message read msg_01 msg_02 msg_03
thrum message read --all</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&gt; Marked 3 messages as read</code></pre>
<p>Read state is tracked per session and per agent in the <code>message_reads</code> table. A
message is considered &quot;read&quot; if any session or agent matching the current
identity has a read record for it.</p>
<h3>Auto Mark-as-Read Summary</h3>
<p>Several commands mark messages as read automatically:</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Behavior</th>
</tr>
</thead>
<tbody><tr>
<td><code>thrum inbox</code></td>
<td>Marks all displayed messages as read (skipped with <code>--unread</code>)</td>
</tr>
<tr>
<td><code>thrum reply MSG_ID ...</code></td>
<td>Marks the replied-to message as read</td>
</tr>
<tr>
<td><code>thrum message get MSG_ID</code></td>
<td>Marks the retrieved message as read</td>
</tr>
</tbody></table>
<p>All auto mark-as-read operations are best-effort: if they fail, the parent
command still succeeds.</p>
<h2>Message Structure</h2>
<h3>Core Fields</h3>
<p>Every message has these core fields:</p>
<pre><code>{
  &quot;message_id&quot;: &quot;msg_01HXE...&quot;,
  &quot;author&quot;: {
    &quot;agent_id&quot;: &quot;agent:role:HASH&quot;,
    &quot;session_id&quot;: &quot;ses_01HXE...&quot;
  },
  &quot;body&quot;: {
    &quot;format&quot;: &quot;markdown&quot;,
    &quot;content&quot;: &quot;Message content&quot;,
    &quot;structured&quot;: &quot;{...}&quot;
  },
  &quot;scopes&quot;: [],
  &quot;refs&quot;: [],
  &quot;metadata&quot;: {},
  &quot;created_at&quot;: &quot;2026-02-03T10:00:00Z&quot;,
  &quot;updated_at&quot;: &quot;2026-02-03T11:00:00Z&quot;,
  &quot;deleted&quot;: false
}</code></pre>
<h3>Body Formats</h3>
<p>Messages support three content formats:</p>
<p><strong>Markdown</strong> (default) -- best for human-readable documentation, notes, and
status updates:</p>
<pre><code>{ &quot;format&quot;: &quot;markdown&quot;, &quot;content&quot;: &quot;# Heading\n\nWith **formatting**&quot; }</code></pre>
<p><strong>Plain text</strong> -- best for log messages, simple status, and system
notifications:</p>
<pre><code>{ &quot;format&quot;: &quot;plain&quot;, &quot;content&quot;: &quot;Simple unformatted text&quot; }</code></pre>
<p><strong>JSON</strong> -- best for machine-readable data, API responses, and structured
status:</p>
<pre><code>{ &quot;format&quot;: &quot;json&quot;, &quot;content&quot;: &quot;{\&quot;type\&quot;:\&quot;status\&quot;,\&quot;value\&quot;:\&quot;complete\&quot;}&quot; }</code></pre>
<h3>Structured Data</h3>
<p>In addition to the main content, messages can include typed structured data via
the <code>--structured</code> flag:</p>
<pre><code>thrum send &quot;Test results for feature X&quot; \
  --structured &#39;{&quot;type&quot;:&quot;test_result&quot;,&quot;passed&quot;:45,&quot;failed&quot;:2,&quot;coverage&quot;:85.9}&#39;</code></pre>
<p>The <code>structured</code> field allows agents to parse machine-readable payloads, build
dashboards, trigger automated workflows, and index by structured fields.</p>
<h2>Scopes</h2>
<p>Scopes define the context and visibility of a message. They answer &quot;What is this
message about?&quot;</p>
<h3>Scope Structure</h3>
<pre><code>{ &quot;type&quot;: &quot;scope_type&quot;, &quot;value&quot;: &quot;scope_value&quot; }</code></pre>
<h3>Common Scope Types</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Example</th>
<th>Use</th>
</tr>
</thead>
<tbody><tr>
<td><code>repo</code></td>
<td><code>repo:github.com/user/repo</code></td>
<td>Messages about a specific repository</td>
</tr>
<tr>
<td><code>file</code></td>
<td><code>file:src/main.go</code></td>
<td>Messages related to a specific file</td>
</tr>
<tr>
<td><code>dir</code></td>
<td><code>dir:src/components</code></td>
<td>Messages about a directory and contents</td>
</tr>
<tr>
<td><code>feature</code></td>
<td><code>feature:user-authentication</code></td>
<td>Messages about a feature or epic</td>
</tr>
<tr>
<td><code>component</code></td>
<td><code>component:api-server</code></td>
<td>Messages about a system component</td>
</tr>
<tr>
<td><code>module</code></td>
<td><code>module:auth</code></td>
<td>Messages about a code module</td>
</tr>
</tbody></table>
<h3>Multiple Scopes</h3>
<p>A message can have multiple scopes:</p>
<pre><code>thrum send &quot;Fixed authentication bug&quot; \
  --scope repo:github.com/user/repo \
  --scope file:src/auth.go \
  --scope feature:user-authentication</code></pre>
<h3>Filtering by Scope</h3>
<pre><code>thrum inbox --scope file:src/main.go
thrum inbox --scope module:auth</code></pre>
<h2>References (Refs)</h2>
<p>References link messages to external entities. They answer &quot;What does this
message reference?&quot;</p>
<h3>Ref Structure</h3>
<pre><code>{ &quot;type&quot;: &quot;ref_type&quot;, &quot;value&quot;: &quot;ref_value&quot; }</code></pre>
<h3>Common Ref Types</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Example</th>
<th>Use</th>
</tr>
</thead>
<tbody><tr>
<td><code>issue</code></td>
<td><code>issue:beads-123</code></td>
<td>Links to a Beads issue</td>
</tr>
<tr>
<td><code>commit</code></td>
<td><code>commit:abc123def456</code></td>
<td>Links to a Git commit</td>
</tr>
<tr>
<td><code>pr</code></td>
<td><code>pr:42</code></td>
<td>Links to a pull request</td>
</tr>
<tr>
<td><code>ticket</code></td>
<td><code>ticket:JIRA-456</code></td>
<td>Links to an external ticket</td>
</tr>
<tr>
<td><code>url</code></td>
<td><code>url:https://docs.example.com/page</code></td>
<td>Links to a web page</td>
</tr>
<tr>
<td><code>mention</code></td>
<td><code>mention:reviewer</code></td>
<td>Created automatically from <code>--to</code> and <code>--mention</code> flags</td>
</tr>
<tr>
<td><code>reply_to</code></td>
<td><code>reply_to:msg_01HXE...</code></td>
<td>Created by <code>thrum reply</code> to link to parent message</td>
</tr>
</tbody></table>
<h3>Multiple Refs</h3>
<pre><code>thrum send &quot;Implemented feature from design doc, closes issue&quot; \
  --ref issue:beads-123 \
  --ref commit:abc123def \
  --ref url:https://docs.example.com/design</code></pre>
<h2>Groups</h2>
<p>Groups allow you to send messages to collections of agents and roles using a
single <code>--to @groupname</code> address.</p>
<h3>Built-in Groups</h3>
<p><strong><code>@everyone</code></strong> — Automatically created on daemon startup. All registered agents
are implicit members. This group cannot be deleted.</p>
<pre><code># Send to all agents
thrum send &quot;Deploy complete&quot; --to @everyone</code></pre>
<h3>Creating Custom Groups</h3>
<pre><code># Create a group
thrum group create reviewers --description &quot;Code review team&quot;

# Add members (agents or roles)
thrum group add reviewers @alice
thrum group add reviewers --role reviewer

# Send to the group
thrum send &quot;PR ready for review&quot; --to @reviewers</code></pre>
<h3>Group Operations</h3>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>thrum group create NAME</code></td>
<td>Create a new group</td>
</tr>
<tr>
<td><code>thrum group delete NAME</code></td>
<td>Delete a group (cannot delete <code>@everyone</code>)</td>
</tr>
<tr>
<td><code>thrum group add GROUP MEMBER</code></td>
<td>Add agent or role to group</td>
</tr>
<tr>
<td><code>thrum group remove GROUP MEMBER</code></td>
<td>Remove a member</td>
</tr>
<tr>
<td><code>thrum group list</code></td>
<td>List all groups</td>
</tr>
<tr>
<td><code>thrum group info NAME</code></td>
<td>Show group details</td>
</tr>
<tr>
<td><code>thrum group members NAME</code></td>
<td>List members (<code>--expand</code> resolves to agent IDs)</td>
</tr>
</tbody></table>
<h3>Message Resolution</h3>
<p>When a message is sent to a group, the daemon resolves group membership at
<strong>read time</strong>. This means:</p>
<ul>
<li>New agents added to a group automatically receive messages sent to that group</li>
<li>The <code>@everyone</code> group dynamically includes all registered agents</li>
<li>Role-based members are resolved to all agents with that role at query time</li>
</ul>
<h3>Broadcast</h3>
<p>Both <code>--broadcast</code> and <code>--to @everyone</code> send to all agents:</p>
<pre><code>thrum send &quot;Deploy complete&quot; --broadcast
thrum send &quot;Deploy complete&quot; --to @everyone
thrum send &quot;Deploy complete&quot; --everyone</code></pre>
<h2>Global Flags</h2>
<p>These flags are available on all commands:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>--json</code></td>
<td>Output as JSON (for scripting and automation)</td>
</tr>
<tr>
<td><code>--quiet</code></td>
<td>Suppress non-essential output (hints, tips)</td>
</tr>
<tr>
<td><code>--verbose</code></td>
<td>Debug output</td>
</tr>
<tr>
<td><code>--role</code></td>
<td>Agent role (or <code>THRUM_ROLE</code> env var)</td>
</tr>
<tr>
<td><code>--module</code></td>
<td>Agent module (or <code>THRUM_MODULE</code> env var)</td>
</tr>
<tr>
<td><code>--repo</code></td>
<td>Repository path (default: <code>.</code>)</td>
</tr>
</tbody></table>
<h2>Implementation Details</h2>
<h3>Storage</h3>
<p>Messages are stored in two places:</p>
<ol>
<li><p><strong>Sharded JSONL Event Logs</strong> (in the <code>a-sync</code> Git worktree at
<code>.git/thrum-sync/a-sync/</code>) -- the append-only source of truth. Events are
sharded per agent:</p>
<ul>
<li><code>.git/thrum-sync/a-sync/events.jsonl</code> -- agent lifecycle events
(<code>agent.register</code>, <code>agent.session.start</code>, <code>agent.session.end</code>,
<code>agent.cleanup</code>)</li>
<li><code>.git/thrum-sync/a-sync/messages/{agent_name}.jsonl</code> -- per-agent message
events (<code>message.create</code>, <code>message.edit</code>, <code>message.delete</code>, <code>agent.update</code>)</li>
</ul>
</li>
<li><p><strong>SQLite Projection</strong> (<code>.thrum/var/messages.db</code>) -- derived from the JSONL
logs for query performance. Can be rebuilt from the logs. Contains the tables
described below.</p>
</li>
</ol>
<h3>Tables</h3>
<h4>messages</h4>
<pre><code>CREATE TABLE messages (
  message_id TEXT PRIMARY KEY,
  agent_id TEXT NOT NULL,
  session_id TEXT NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT,
  deleted INTEGER DEFAULT 0,
  deleted_at TEXT,
  delete_reason TEXT,
  body_format TEXT NOT NULL,
  body_content TEXT NOT NULL,
  body_structured TEXT
)</code></pre>
<h4>message_scopes</h4>
<pre><code>CREATE TABLE message_scopes (
  message_id TEXT NOT NULL,
  scope_type TEXT NOT NULL,
  scope_value TEXT NOT NULL,
  PRIMARY KEY (message_id, scope_type, scope_value)
)</code></pre>
<h4>message_refs</h4>
<pre><code>CREATE TABLE message_refs (
  message_id TEXT NOT NULL,
  ref_type TEXT NOT NULL,
  ref_value TEXT NOT NULL,
  PRIMARY KEY (message_id, ref_type, ref_value)
)</code></pre>
<h4>message_edits</h4>
<pre><code>CREATE TABLE message_edits (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  message_id TEXT NOT NULL,
  edited_at TEXT NOT NULL,
  edited_by TEXT NOT NULL,
  old_content TEXT,
  new_content TEXT,
  old_structured TEXT,
  new_structured TEXT
)</code></pre>
<p>Each row represents one edit operation with before/after values for both content
and structured data.</p>
<h4>message_reads</h4>
<pre><code>CREATE TABLE message_reads (
  message_id TEXT NOT NULL,
  session_id TEXT NOT NULL,
  agent_id TEXT NOT NULL,
  read_at TEXT NOT NULL,
  PRIMARY KEY (message_id, session_id),
  FOREIGN KEY (message_id) REFERENCES messages(message_id) ON DELETE CASCADE
)</code></pre>
<p>Read state is tracked per message per session. A message is considered read for
an agent if any matching <code>session_id</code> or <code>agent_id</code> has a record. This means
read state persists across session restarts for the same agent.</p>
<h3>Indexes</h3>
<p>Optimized for common query patterns:</p>
<ul>
<li><code>idx_messages_time</code> -- time-based sorting</li>
<li><code>idx_messages_agent</code> -- author filtering</li>
<li><code>idx_messages_session</code> -- session filtering</li>
<li><code>idx_scopes_lookup</code> -- scope filtering</li>
<li><code>idx_refs_lookup</code> -- ref filtering (including reply_to references)</li>
<li><code>idx_edits_message</code> -- edit history lookup by message and timestamp</li>
<li><code>idx_message_reads_agent</code> -- read state by agent</li>
<li><code>idx_message_reads_message</code> -- read state by message</li>
</ul>
<h2>MCP Server Integration</h2>
<p>The MCP server (<code>thrum mcp serve</code>) provides native messaging tools for AI agents
running in Claude Code or similar environments. It exposes 11 MCP tools
organized into two categories:</p>
<p><strong>Core messaging (5 tools):</strong></p>
<table>
<thead>
<tr>
<th>MCP Tool</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>send_message</code></td>
<td>Send a message to <code>@role</code> or agent name</td>
</tr>
<tr>
<td><code>check_messages</code></td>
<td>Poll for unread messages mentioning this agent, auto-marks read</td>
</tr>
<tr>
<td><code>wait_for_message</code></td>
<td>Block until a message arrives via WebSocket push or timeout (max 600s)</td>
</tr>
<tr>
<td><code>list_agents</code></td>
<td>List registered agents with active/offline status</td>
</tr>
<tr>
<td><code>broadcast_message</code></td>
<td>Send to all agents (convenience wrapper around <code>send_message</code> with <code>to=@everyone</code>)</td>
</tr>
</tbody></table>
<p><strong>Group management (6 tools):</strong></p>
<table>
<thead>
<tr>
<th>MCP Tool</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>create_group</code></td>
<td>Create a named messaging group</td>
</tr>
<tr>
<td><code>delete_group</code></td>
<td>Delete a messaging group</td>
</tr>
<tr>
<td><code>add_group_member</code></td>
<td>Add an agent or role as a member of a group</td>
</tr>
<tr>
<td><code>remove_group_member</code></td>
<td>Remove a member from a group</td>
</tr>
<tr>
<td><code>list_groups</code></td>
<td>List all messaging groups</td>
</tr>
<tr>
<td><code>get_group</code></td>
<td>Get group details including members (expand=true resolves roles)</td>
</tr>
</tbody></table>
<p>MCP tools use the same underlying RPC methods (<code>message.send</code>, <code>message.list</code>,
<code>message.markRead</code>) but add convenience features like <code>@role</code> addressing and
real-time WebSocket push notifications.</p>
<h2>Agent Identity</h2>
<p>Agents are identified by name using identity files stored at
<code>.thrum/identities/{name}.json</code>. Identity is resolved in this priority order:</p>
<ol>
<li><code>THRUM_NAME</code> environment variable (selects which identity file to load)</li>
<li><code>THRUM_ROLE</code> and <code>THRUM_MODULE</code> environment variables</li>
<li>CLI flags (<code>--role</code>, <code>--module</code>, <code>--name</code>)</li>
<li>Single identity file auto-selection (solo-agent worktrees)</li>
</ol>
<p>Agent names must match <code>[a-z0-9_]+</code>. Reserved names: <code>daemon</code>, <code>system</code>,
<code>thrum</code>, <code>all</code>, <code>broadcast</code>.</p>
<p>For multi-agent worktrees, each agent gets its own identity file and JSONL
shard.</p>
<h2>See Also</h2>
<ul>
<li>RPC API Reference: <code>docs/rpc-api.md</code></li>
<li>Daemon Architecture: <code>docs/daemon.md</code></li>
<li>Development Guide: <code>docs/development.md</code></li>
</ul>
<pre><code></code></pre>

</main>
<script>if(location.search.indexOf('nospa')===-1){location.replace('../docs.html#messaging.html')}</script>
</body>
</html>