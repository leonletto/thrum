<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Architecture — Thrum</title>
<meta name="description" content="Thrum foundation architecture — packages, storage layer, daemon, sync engine, and event system">
<link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#architecture.html">
<style>
body{font-family:system-ui,sans-serif;max-width:48rem;margin:2rem auto;padding:0 1.5rem;line-height:1.6;color:#222}
pre{background:#f5f5f5;padding:1rem;overflow-x:auto;border-radius:4px}
code{font-family:ui-monospace,monospace;font-size:0.9em}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #ddd;padding:0.4rem 0.6rem;text-align:left}
th{background:#f5f5f5}
nav{margin-bottom:1.5rem;padding-bottom:1rem;border-bottom:1px solid #ddd;line-height:1.8}
h2{margin-top:2rem}
a{color:#0366d6}
</style>
</head>
<body>
<nav>
<strong><a href="../docs.html">Thrum Docs</a></strong> &rsaquo; Architecture &rsaquo; Architecture
<hr>
<strong>Overview</strong>: <a href="philosophy.html">Philosophy</a><br>
<strong>Getting Started</strong>: <a href="quickstart.html">Quickstart Guide</a><br>
  <strong>Recommended Tools</strong>: <a href="guides/recommended-tools.html">Recommended Tools</a> | <a href="guides/beads-setup.html">Beads Setup Guide</a> | <a href="guides/beads-ui-setup.html">Beads UI Setup Guide</a> | <a href="guides/playwright-cli-setup.html">Playwright CLI Setup Guide</a><br>
<strong>Web UI</strong>: <a href="web-ui.html">Web UI</a><br>
<strong>Messaging</strong>: <a href="subscriptions.html">Subscriptions & Notifications</a><br>
<strong>Identity</strong>: <a href="identity.html">Agent Identity & Registration</a><br>
<strong>Guides</strong>: <a href="agent-coordination.html">Agent Coordination</a> | <a href="agent-configs.html">Agent Configurations</a> | <a href="multi-agent.html">Multi-Agent Support</a> | <a href="claude-code-plugin.html">Claude Code Plugin</a> | <a href="configuration.html">Configuration</a> | <a href="workflow-templates.html">Workflow Templates</a> | <a href="beads-and-thrum.html">Beads and Thrum</a> | <a href="codex-plugin.html">Codex Plugin</a> | <a href="claude-agent-integration.html">Claude Code Agent Integration</a> | <a href="messaging.html">Messaging</a> | <a href="tailscale-sync.html">Tailscale Sync</a> | <a href="tailscale-security.html">Tailscale Sync Security</a> | <a href="overview.html">Technical Overview</a><br>
<strong>API Reference</strong>: <a href="event-streaming.html">Event Streaming</a> | <a href="inbox-query-methods.html">Inbox Query Methods</a> | <a href="api/authentication.html">Authentication</a> | <a href="api/events.html">Event Reference</a> | <a href="rpc-api.html">RPC API</a> | <a href="api/websocket.html">WebSocket API</a><br>
<strong>Daemon</strong>: <a href="daemon.html">Daemon Architecture</a><br>
<strong>Sync</strong>: <a href="sync.html">Sync Protocol</a><br>
<strong>Development</strong>: <a href="development.html">Development Guide</a> | <a href="security-cicd.html">Security & CI/CD</a><br>
<strong>Architecture</strong>: <strong>Architecture</strong><br>
<strong>Context</strong>: <a href="context.html">Agent Context Management</a><br>
<strong>Reference</strong>: <a href="cli.html">CLI Reference</a> | <a href="mcp-server.html">MCP Server</a><br>
<strong>uncategorized</strong>: <a href="role-templates.html">Role-Based Preamble Templates</a><br>
</nav>
<main>
<h2>Thrum Foundation Architecture</h2>
<p>This document describes the foundational packages that support the Thrum agent
messaging system.</p>
<h2>Overview</h2>
<p>The foundation provides core functionality that both the daemon and CLI depend
on:</p>
<ul>
<li><strong>Configuration loading</strong> - Environment variables, identity files, CLI flags,
agent naming</li>
<li><strong>ID generation</strong> - Deterministic and unique identifiers (ULID-based)</li>
<li><strong>JSONL handling</strong> - Append-only event log with file locking</li>
<li><strong>SQLite schema</strong> - Database tables, indexes, and migrations (version 7)</li>
<li><strong>Event projection</strong> - Replay sharded JSONL events into SQLite</li>
<li><strong>Path resolution</strong> - <code>.thrum/redirect</code> for multi-worktree, sync worktree path
via <code>git-common-dir</code></li>
<li><strong>Git context</strong> - Extract live git state (branch, commits, files) for agent
work context</li>
</ul>
<h2>Package Structure</h2>
<pre><code>internal/
├── config/      # Configuration loading, identity files, agent naming
├── identity/    # ID generation (repo, agent, session, message, event)
├── jsonl/       # JSONL reader/writer with file locking
├── projection/  # SQLite projection engine (multi-file rebuild)
├── schema/      # SQLite schema, migrations, JSONL sharding migration
├── paths/       # Path resolution, redirect, sync worktree path
├── gitctx/      # Git-derived work context extraction
└── types/       # Shared event types</code></pre>
<h2>Configuration (<code>internal/config</code>)</h2>
<h3>Resolution Order</h3>
<p>Configuration is resolved in priority order:</p>
<ol>
<li><code>THRUM_NAME</code> env var (selects which identity file to load)</li>
<li>Environment variables (<code>THRUM_ROLE</code>, <code>THRUM_MODULE</code>, <code>THRUM_DISPLAY</code>)</li>
<li>CLI flags (<code>--role</code>, <code>--module</code>)</li>
<li>Identity file (<code>.thrum/identities/{name}.json</code>)</li>
<li>Error if required fields missing</li>
</ol>
<h3>Identity File Format</h3>
<p>Identity files are stored at <code>.thrum/identities/{agent_name}.json</code>
(per-worktree):</p>
<pre><code>{
  &quot;version&quot;: 2,
  &quot;repo_id&quot;: &quot;r_7K2Q1X9M3P0B&quot;,
  &quot;agent&quot;: {
    &quot;kind&quot;: &quot;agent&quot;,
    &quot;name&quot;: &quot;furiosa&quot;,
    &quot;role&quot;: &quot;implementer&quot;,
    &quot;module&quot;: &quot;sync-daemon&quot;,
    &quot;display&quot;: &quot;Sync Implementer&quot;
  },
  &quot;worktree&quot;: &quot;daemon&quot;,
  &quot;confirmed_by&quot;: &quot;human:leon&quot;,
  &quot;updated_at&quot;: &quot;2026-02-03T18:02:10.000Z&quot;
}</code></pre>
<h3>Agent Naming</h3>
<p>Agents support human-readable names:</p>
<ul>
<li><code>--name furiosa</code> on <code>quickstart</code> or <code>agent register</code></li>
<li><code>THRUM_NAME</code> env var (highest priority)</li>
<li>Names: <code>[a-z0-9_]+</code> (lowercase alphanumeric + underscores)</li>
<li>Reserved: <code>daemon</code>, <code>system</code>, <code>thrum</code>, <code>all</code>, <code>broadcast</code></li>
<li>When name is provided, it becomes the agent ID directly (e.g., <code>furiosa</code>)</li>
<li>When omitted, falls back to <code>{role}_{hash10}</code> format (e.g.,
<code>coordinator_1B9K33T6RK</code>)</li>
</ul>
<h3>Config Struct</h3>
<pre><code>type Config struct {
    RepoID  string      // Repository ID
    Agent   AgentConfig // Agent identity
    Display string      // Display name
}

type AgentConfig struct {
    Kind    string // &quot;agent&quot; or &quot;human&quot;
    Name    string // Agent name (e.g., &quot;furiosa&quot;)
    Role    string // Agent role (e.g., &quot;implementer&quot;)
    Module  string // Module/component responsibility
    Display string // Display name
}</code></pre>
<h3>Loading</h3>
<pre><code>// Load from current directory
cfg, err := config.Load(flagRole, flagModule)

// Load from specific repo path
cfg, err := config.LoadWithPath(repoPath, flagRole, flagModule)</code></pre>
<h2>Identity (<code>internal/identity</code>)</h2>
<h3>ID Formats</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Format</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Repo ID</strong></td>
<td><code>r_</code> + base32(sha256(url))[:12]</td>
<td><code>r_7K2Q1X9M3P0B</code></td>
</tr>
<tr>
<td><strong>Agent ID (named)</strong></td>
<td>name directly</td>
<td><code>furiosa</code></td>
</tr>
<tr>
<td><strong>Agent ID (unnamed)</strong></td>
<td>role + <code>_</code> + base32(hash)[:10]</td>
<td><code>implementer_9F2K3M1Q8Z</code></td>
</tr>
<tr>
<td><strong>User ID</strong></td>
<td><code>user:</code> + username</td>
<td><code>user:leon</code></td>
</tr>
<tr>
<td><strong>Session ID</strong></td>
<td><code>ses_</code> + ulid()</td>
<td><code>ses_01HXF2A9Y1Q0P8...</code></td>
</tr>
<tr>
<td><strong>Session Token</strong></td>
<td><code>tok_</code> + ulid()</td>
<td><code>tok_01HXF2A9Y1Q0P8...</code></td>
</tr>
<tr>
<td><strong>Message ID</strong></td>
<td><code>msg_</code> + ulid()</td>
<td><code>msg_01HXF2A9Y1Q0P8...</code></td>
</tr>
<tr>
<td><strong>Event ID</strong></td>
<td><code>evt_</code> + ulid()</td>
<td><code>evt_01HXF2A9Y1Q0P8...</code></td>
</tr>
</tbody></table>
<h3>Deterministic IDs</h3>
<ul>
<li><strong>Repo ID</strong>: Derived from Git origin URL (normalized to https, lowercased,
<code>.git</code> suffix stripped)</li>
<li><strong>Agent ID (unnamed)</strong>: Derived from repo_id + role + module (sha256 +
Crockford base32)</li>
<li>Same inputs always produce the same ID</li>
</ul>
<h3>Unique IDs</h3>
<ul>
<li><strong>Session, Message, Event IDs</strong>: Use ULID (time-ordered, unique)</li>
<li>ULID format: 26 characters, sortable by time, 128-bit random</li>
<li>Thread-safe generation with mutex-protected monotonic entropy</li>
</ul>
<p>Agent IDs are generated internally from the role and a hash. See
<a href="development.html">Development Guide</a> for implementation details.</p>
<h2>Paths (<code>internal/paths</code>)</h2>
<h3>Path Resolution</h3>
<p>The <code>paths</code> package handles path resolution for multi-worktree setups and sync
worktree location.</p>
<p><strong>Key functions:</strong></p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Returns</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>ResolveThrumDir(repoPath)</code></td>
<td><code>.thrum/</code> path</td>
<td>Follows <code>.thrum/redirect</code> if present</td>
</tr>
<tr>
<td><code>SyncWorktreePath(repoPath)</code></td>
<td><code>.git/thrum-sync/a-sync/</code> path</td>
<td>Uses <code>git-common-dir</code> for nested worktree support</td>
</tr>
<tr>
<td><code>VarDir(thrumDir)</code></td>
<td><code>.thrum/var/</code> path</td>
<td>Runtime files directory</td>
</tr>
<tr>
<td><code>IdentitiesDir(repoPath)</code></td>
<td><code>.thrum/identities/</code> path</td>
<td>Per-worktree agent identity files</td>
</tr>
</tbody></table>
<h3>Redirect File</h3>
<p>Feature worktrees share the main worktree&#39;s daemon and state via a redirect
file:</p>
<pre><code>.thrum/redirect    -&gt; /path/to/main/worktree/.thrum</code></pre>
<p><strong>Resolution rules:</strong></p>
<ul>
<li>If <code>.thrum/redirect</code> exists, read target path and use it as the effective
<code>.thrum/</code> directory</li>
<li>Target must be an absolute path</li>
<li>Redirect chains (A -&gt; B -&gt; C) are detected and rejected</li>
<li>Self-referencing redirects are rejected</li>
<li>If no redirect file, use local <code>.thrum/</code> (this is the main worktree)</li>
</ul>
<p><strong>Note:</strong> <code>IdentitiesDir()</code> always uses the LOCAL <code>.thrum/identities/</code> (not the
redirect target), because agent identities are per-worktree.</p>
<h3>Sync Worktree Path</h3>
<p>The sync worktree lives at <code>.git/thrum-sync/a-sync/</code>:</p>
<pre><code>syncDir, err := paths.SyncWorktreePath(repoPath)
// Returns: /path/to/repo/.git/thrum-sync/a-sync</code></pre>
<p>Uses <code>git rev-parse --git-common-dir</code> to find the correct <code>.git/</code> directory,
which handles nested worktrees correctly (where <code>.git</code> is a file pointing to the
parent repo&#39;s <code>.git/worktrees/</code> directory).</p>
<h2>Git Context (<code>internal/gitctx</code>)</h2>
<h3>Work Context Extraction</h3>
<p>The <code>gitctx</code> package extracts live Git state for agent work context tracking.
Called during <code>session.heartbeat</code> to provide real-time visibility into what each
agent is working on.</p>
<p><strong>Exported types:</strong></p>
<pre><code>type WorkContext struct {
    Branch           string          `json:&quot;branch&quot;`
    WorktreePath     string          `json:&quot;worktree_path&quot;`
    UnmergedCommits  []CommitSummary `json:&quot;unmerged_commits&quot;`
    UncommittedFiles []string        `json:&quot;uncommitted_files&quot;`
    ChangedFiles     []string        `json:&quot;changed_files&quot;`
    ExtractedAt      time.Time       `json:&quot;extracted_at&quot;`
}

type CommitSummary struct {
    SHA     string   `json:&quot;sha&quot;`
    Message string   `json:&quot;message&quot;` // First line only
    Files   []string `json:&quot;files&quot;`
}</code></pre>
<p><strong><code>ExtractWorkContext(worktreePath)</code>:</strong></p>
<ul>
<li>Returns empty context (not error) if path is not a git repo</li>
<li>Determines base branch automatically (<code>origin/main</code>, <code>origin/master</code>, or
<code>HEAD~10</code>)</li>
<li>Extracts unmerged commits with per-commit file lists</li>
<li>Runs in ~80ms typically</li>
</ul>
<h2>JSONL (<code>internal/jsonl</code>)</h2>
<h3>Append-Only Log</h3>
<pre><code>// Writing
writer, _ := jsonl.NewWriter(&quot;events.jsonl&quot;)
writer.Append(event)
writer.Close()

// Reading all
reader, _ := jsonl.NewReader(&quot;events.jsonl&quot;)
messages, _ := reader.ReadAll()

// Streaming
ctx := context.Background()
ch := reader.Stream(ctx)
for msg := range ch {
    // Process message
}</code></pre>
<h3>Safety Features</h3>
<ul>
<li><strong>File locking</strong>: Uses <code>syscall.Flock()</code> to prevent concurrent writes</li>
<li><strong>Atomic appends</strong>: Write to temp file, then append to main file, fsync</li>
<li><strong>Auto-create</strong>: Creates parent directories and file if needed</li>
<li><strong>In-process mutex</strong>: <code>sync.Mutex</code> for thread safety within the same process</li>
</ul>
<h3>Sharded File Layout</h3>
<p>JSONL files are sharded by type and agent (in the sync worktree at
<code>.git/thrum-sync/a-sync/</code>):</p>
<pre><code>events.jsonl              # Agent lifecycle, sessions, threads
messages/
  furiosa.jsonl           # Messages authored by agent &quot;furiosa&quot;
  coordinator_1B9K.jsonl  # Messages authored by unnamed agent</code></pre>
<p>Event routing is handled by <code>internal/daemon/state/</code> which directs <code>message.*</code>
events to per-agent files and all other events to <code>events.jsonl</code>.</p>
<h2>Schema (<code>internal/schema</code>)</h2>
<h3>Database Tables</h3>
<pre><code>messages            # All messages (create/edit/delete)
message_scopes      # Routing scopes (many-to-many)
message_refs        # References (many-to-many)
message_reads       # Per-session read tracking (local-only, no git sync)
message_edits       # Edit history tracking
agents              # Registered agents (kind: &quot;agent&quot; or &quot;user&quot;)
sessions            # Agent work periods
session_scopes      # Session context scopes
session_refs        # Session context references
subscriptions       # Push notification subscriptions
agent_work_contexts # Live git state per session
groups              # Named collections for targeted messaging
group_members       # Group membership (agents and roles)
schema_version      # Migration tracking</code></pre>
<h3>Schema Version</h3>
<p>Current version: <strong>13</strong></p>
<p>Key migrations:</p>
<ul>
<li>v3 -&gt; v4: Impersonation support (<code>authored_by</code>, <code>disclosed</code> columns)</li>
<li>v5 -&gt; v6: Agent work contexts table, message reads, session scopes/refs</li>
<li>v6 -&gt; v7: Event ID backfill (ULID <code>event_id</code> on all JSONL events), JSONL
sharding migration</li>
<li>v7 -&gt; v8: Groups feature (<code>groups</code> and <code>group_members</code> tables), <code>@everyone</code>
built-in group</li>
</ul>
<h3>Initialization</h3>
<pre><code>db, _ := schema.OpenDB(&quot;thrum.db&quot;)
schema.InitDB(db)  // Create tables and indexes

// Or use migration (checks version first, runs incremental migrations)
schema.Migrate(db)</code></pre>
<h3>JSONL Migrations</h3>
<p>The schema package also handles JSONL structure migrations:</p>
<pre><code>// Migrate monolithic messages.jsonl -&gt; per-agent sharded files
schema.MigrateJSONLSharding(syncDir)

// Backfill event_id (ULID) for events that lack it
schema.BackfillEventID(syncDir)</code></pre>
<h3>Features</h3>
<ul>
<li><strong>Pure Go SQLite</strong>: Uses <code>modernc.org/sqlite</code> (no CGO)</li>
<li><strong>WAL mode</strong>: Better concurrency</li>
<li><strong>Foreign keys</strong>: Enabled with <code>ON DELETE CASCADE</code></li>
<li><strong>Indexes</strong>: Optimized for common queries</li>
</ul>
<h2>Projection (<code>internal/projection</code>)</h2>
<h3>Event Replay</h3>
<p>The projector rebuilds SQLite from sharded JSONL event logs:</p>
<pre><code>db, _ := schema.OpenDB(&quot;thrum.db&quot;)
schema.InitDB(db)

projector := projection.NewProjector(db)

// Rebuild from sync worktree (reads events.jsonl + messages/*.jsonl)
projector.Rebuild(syncDir)

// Or apply a single event
projector.Apply(eventJSON)</code></pre>
<h3>Multi-File Rebuild</h3>
<p><code>Rebuild(syncDir)</code> handles the sharded JSONL structure:</p>
<ol>
<li>Read <code>events.jsonl</code> (agent lifecycle, sessions)</li>
<li>Glob <code>messages/*.jsonl</code> (per-agent message files)</li>
<li>Sort ALL events globally by <code>(timestamp, event_id)</code> for deterministic
ordering</li>
<li>Apply to SQLite in order</li>
</ol>
<p>File boundaries are transparent to the projector -- it only cares about event
ordering.</p>
<h3>Event Types</h3>
<table>
<thead>
<tr>
<th>Event</th>
<th>Action</th>
</tr>
</thead>
<tbody><tr>
<td><code>message.create</code></td>
<td>Insert into messages, scopes, refs</td>
</tr>
<tr>
<td><code>message.edit</code></td>
<td>Update body_content, updated_at, record edit history</td>
</tr>
<tr>
<td><code>message.delete</code></td>
<td>Set deleted=1, deleted_at, delete_reason</td>
</tr>
<tr>
<td><code>group.create</code></td>
<td>Insert into groups</td>
</tr>
<tr>
<td><code>group.delete</code></td>
<td>Delete group and members</td>
</tr>
<tr>
<td><code>agent.register</code></td>
<td>Insert/replace agent</td>
</tr>
<tr>
<td><code>agent.update</code></td>
<td>Merge work contexts for agent</td>
</tr>
<tr>
<td><code>agent.session.start</code></td>
<td>Insert session</td>
</tr>
<tr>
<td><code>agent.session.end</code></td>
<td>Update ended_at, end_reason</td>
</tr>
</tbody></table>
<h3>Forward Compatibility</h3>
<p>Unknown event types are silently ignored, allowing older projectors to process
logs with newer event types.</p>
<h2>Types (<code>internal/types</code>)</h2>
<p>Shared Go structs for all event types:</p>
<ul>
<li><code>BaseEvent</code> - Common fields: <code>type</code>, <code>timestamp</code>, <code>event_id</code>, <code>v</code> (version)</li>
<li><code>MessageCreateEvent</code> - Message creation with body, scopes, refs</li>
<li><code>MessageEditEvent</code> - Message body edit</li>
<li><code>MessageDeleteEvent</code> - Soft delete with reason</li>
<li><code>GroupCreateEvent</code> - Group creation with name and description</li>
<li><code>GroupDeleteEvent</code> - Group deletion</li>
<li><code>AgentRegisterEvent</code> - Agent registration (kind: &quot;agent&quot; or &quot;user&quot;)</li>
<li><code>AgentUpdateEvent</code> - Agent work context updates</li>
<li><code>AgentCleanupEvent</code> - Agent cleanup/deletion</li>
<li><code>AgentSessionStartEvent</code> - Session start</li>
<li><code>AgentSessionEndEvent</code> - Session end with reason</li>
<li><code>SessionWorkContext</code> - Work context data for sync</li>
</ul>
<p>Each event includes:</p>
<ul>
<li><code>type</code>: Event type string (e.g., <code>&quot;message.create&quot;</code>)</li>
<li><code>timestamp</code>: ISO 8601 timestamp</li>
<li><code>event_id</code>: ULID for deduplication (auto-generated by <code>State.WriteEvent()</code>)</li>
<li><code>v</code>: Schema version (currently <code>1</code>)</li>
<li>Event-specific fields</li>
</ul>
<h2>Design Principles</h2>
<h3>1. Append-Only Events</h3>
<p>JSONL is the source of truth. SQLite is a rebuildable projection for fast
queries. The projection can be deleted and rebuilt from JSONL at any time.</p>
<h3>2. Per-Agent Sharding</h3>
<p>Message events are sharded into per-agent JSONL files
(<code>messages/{agent}.jsonl</code>). This reduces merge conflicts, improves sync
performance, and enables per-agent file tracking in Git.</p>
<h3>3. Deterministic Hashing</h3>
<p>Repo and agent IDs are deterministic (SHA256-based), enabling identity
verification across machines without central coordination.</p>
<h3>4. Time-Ordered IDs</h3>
<p>ULID format ensures IDs (messages, sessions, events) are sortable by creation
time and globally unique.</p>
<h3>5. Offline-First</h3>
<p>No network required for local operation. Git handles replication via the sync
loop.</p>
<h3>6. Low-Conflict</h3>
<p>Immutable events + ULID timestamps + per-agent sharding minimize merge conflicts
during Git sync.</p>
<h3>7. Path Indirection</h3>
<p>The <code>.thrum/redirect</code> pattern allows multiple worktrees to share a single daemon
and state directory without hardcoding paths.</p>
<h3>8. Timeout Enforcement (v0.4.3)</h3>
<p>All I/O paths enforce timeouts to prevent indefinite hangs:</p>
<ul>
<li><strong>5s</strong> CLI dial timeout (net.DialTimeout)</li>
<li><strong>10s</strong> RPC call timeout (context.WithTimeout)</li>
<li><strong>10s</strong> server per-request timeout (http.TimeoutHandler)</li>
<li><strong>10s</strong> WebSocket handshake timeout</li>
<li><strong>5s/10s</strong> git command timeouts (via <code>safecmd</code> wrapper)</li>
<li><strong>Context-scoped</strong> SQLite queries (via <code>safedb</code> wrapper)</li>
</ul>
<p>Lock scope has been reduced — no mutex is held during I/O, git, or WebSocket
dispatch operations.</p>
<h2>References</h2>
<ul>
<li>Design document: <code>dev-docs/2026-02-03-thrum-design.md</code></li>
<li>Sharding design: <code>dev-docs/2026-02-06-jsonl-sharding-and-agent-naming.md</code></li>
<li>Daemon architecture: <code>docs/daemon.md</code></li>
<li>Sync protocol: <code>docs/sync.md</code></li>
</ul>
<pre><code></code></pre>

</main>
<script>if(location.search.indexOf('nospa')===-1){location.replace('../docs.html#architecture.html')}</script>
</body>
</html>