<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Event Streaming â€” Thrum</title>
<meta name="description" content="Real-time push notifications via Broadcaster and Dispatcher - subscription matching, delivery, and client registries">
<link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#event-streaming.html">
<style>
body{font-family:system-ui,sans-serif;max-width:48rem;margin:2rem auto;padding:0 1.5rem;line-height:1.6;color:#222}
pre{background:#f5f5f5;padding:1rem;overflow-x:auto;border-radius:4px}
code{font-family:ui-monospace,monospace;font-size:0.9em}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #ddd;padding:0.4rem 0.6rem;text-align:left}
th{background:#f5f5f5}
nav{margin-bottom:1.5rem;padding-bottom:1rem;border-bottom:1px solid #ddd;line-height:1.8}
h2{margin-top:2rem}
a{color:#0366d6}
</style>
</head>
<body>
<nav>
<strong><a href="../docs.html">Thrum Docs</a></strong> &rsaquo; API Reference &rsaquo; Event Streaming
<hr>
<strong>Overview</strong>: <a href="philosophy.html">Philosophy</a><br>
<strong>Getting Started</strong>: <a href="quickstart.html">Quickstart Guide</a><br>
  <strong>Recommended Tools</strong>: <a href="guides/recommended-tools.html">Recommended Tools</a> | <a href="guides/beads-setup.html">Beads Setup Guide</a> | <a href="guides/beads-ui-setup.html">Beads UI Setup Guide</a> | <a href="guides/playwright-cli-setup.html">Playwright CLI Setup Guide</a><br>
<strong>Web UI</strong>: <a href="web-ui.html">Web UI</a><br>
<strong>Messaging</strong>: <a href="subscriptions.html">Subscriptions & Notifications</a><br>
<strong>Identity</strong>: <a href="identity.html">Agent Identity & Registration</a><br>
<strong>Guides</strong>: <a href="agent-coordination.html">Agent Coordination</a> | <a href="agent-configs.html">Agent Configurations</a> | <a href="multi-agent.html">Multi-Agent Support</a> | <a href="claude-code-plugin.html">Claude Code Plugin</a> | <a href="configuration.html">Configuration</a> | <a href="workflow-templates.html">Workflow Templates</a> | <a href="beads-and-thrum.html">Beads and Thrum</a> | <a href="codex-plugin.html">Codex Plugin</a> | <a href="claude-agent-integration.html">Claude Code Agent Integration</a> | <a href="messaging.html">Messaging</a> | <a href="tailscale-sync.html">Tailscale Sync</a> | <a href="tailscale-security.html">Tailscale Sync Security</a> | <a href="overview.html">Technical Overview</a><br>
<strong>API Reference</strong>: <strong>Event Streaming</strong> | <a href="inbox-query-methods.html">Inbox Query Methods</a> | <a href="api/authentication.html">Authentication</a> | <a href="api/events.html">Event Reference</a> | <a href="rpc-api.html">RPC API</a> | <a href="api/websocket.html">WebSocket API</a><br>
<strong>Daemon</strong>: <a href="daemon.html">Daemon Architecture</a><br>
<strong>Sync</strong>: <a href="sync.html">Sync Protocol</a><br>
<strong>Development</strong>: <a href="development.html">Development Guide</a> | <a href="security-cicd.html">Security & CI/CD</a><br>
<strong>Architecture</strong>: <a href="architecture.html">Architecture</a><br>
<strong>Context</strong>: <a href="context.html">Agent Context Management</a><br>
<strong>Reference</strong>: <a href="cli.html">CLI Reference</a> | <a href="mcp-server.html">MCP Server</a><br>
<strong>uncategorized</strong>: <a href="role-templates.html">Role-Based Preamble Templates</a><br>
</nav>
<main>
<h2>Event Streaming</h2>
<h2>Overview</h2>
<p>Event streaming enables real-time push notifications to connected WebSocket and
Unix socket clients. When significant events occur (new messages), the daemon
automatically pushes notifications to subscribed clients.</p>
<p>The WebSocket server and embedded SPA are served on the same port (default 9999,
configurable via <code>THRUM_WS_PORT</code>). WebSocket connections use the <code>/ws</code> endpoint
when the UI is active, or <code>/</code> when running without UI.</p>
<h2>Architecture</h2>
<h3>Components</h3>
<ol>
<li><p><strong>Broadcaster</strong> (<code>internal/daemon/broadcaster.go</code>)</p>
<ul>
<li>Unified notification sender for both Unix socket and WebSocket clients</li>
<li>Implements the <code>ClientNotifier</code> interface expected by the subscription
dispatcher</li>
<li>Tries Unix socket transport first, then WebSocket as fallback</li>
<li>Handles client disconnections gracefully</li>
<li>Thread-safe with <code>sync.RWMutex</code></li>
</ul>
</li>
<li><p><strong>Subscription Dispatcher</strong> (<code>internal/subscriptions/dispatcher.go</code>)</p>
<ul>
<li>Matches events against active subscriptions</li>
<li>Filters events based on scopes, mentions (role-based and name-based), and
subscription types</li>
<li>Pushes notifications to matched subscribers via the Broadcaster</li>
</ul>
</li>
<li><p><strong>Event Streaming Setup</strong> (<code>internal/daemon/event_streaming.go</code>)</p>
<ul>
<li>Factory for wiring together Broadcaster and Dispatcher</li>
<li>Two convenience constructors:<ul>
<li><code>NewEventStreamingSetup(unixClients, wsServer, db)</code> - from raw components</li>
<li><code>NewEventStreamingSetupFromState(state, unixClients, wsServer)</code> - from
daemon state</li>
</ul>
</li>
<li>Returns <code>EventStreamingSetup</code> struct with <code>Broadcaster</code> and <code>Dispatcher</code>
fields</li>
</ul>
</li>
</ol>
<h3>Data Flow</h3>
<pre><code>Event Source (message.send, message.edit)
  |
  v
Subscription Dispatcher
  | (query subscriptions, match against message scopes/mentions)
  v
Broadcaster
  |         |
  v         v
Unix Socket    WebSocket
Clients        Clients (port 9999, /ws endpoint)</code></pre>
<blockquote>
<p><strong>Note:</strong> All WebSocket connections enforce a 10s handshake timeout.
Server-side requests have a 10s per-request timeout (v0.4.3).</p>
</blockquote>
<h2>Implementation Details</h2>
<h3>Supported Notifications</h3>
<p>Currently implemented:</p>
<ul>
<li><strong><code>notification.message</code></strong> - Pushed when a new message is created or edited,
matching a subscription</li>
</ul>
<h3>Notification Format</h3>
<p>Notifications use JSON-RPC 2.0 notification format (no <code>id</code> field, no response
expected):</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;notification.message&quot;,
  &quot;params&quot;: {
    &quot;message_id&quot;: &quot;msg_...&quot;,
    &quot;author&quot;: {
      &quot;agent_id&quot;: &quot;furiosa&quot;,
      &quot;name&quot;: &quot;furiosa&quot;,
      &quot;role&quot;: &quot;implementer&quot;,
      &quot;module&quot;: &quot;&quot;
    },
    &quot;preview&quot;: &quot;First 100 characters of content...&quot;,
    &quot;scopes&quot;: [{ &quot;type&quot;: &quot;task&quot;, &quot;value&quot;: &quot;thrum-ukr&quot; }],
    &quot;matched_subscription&quot;: {
      &quot;subscription_id&quot;: 1,
      &quot;match_type&quot;: &quot;scope&quot;
    },
    &quot;timestamp&quot;: &quot;2026-02-03T10:00:00Z&quot;
  }
}</code></pre>
<h3>Subscription Filtering</h3>
<p>The dispatcher automatically filters events based on subscriptions:</p>
<ul>
<li><strong>Scope subscriptions</strong>: Only notify if message has matching scope</li>
<li><strong>Mention subscriptions</strong>: Only notify if message mentions the agent&#39;s role or
name (supports both <code>@reviewer</code> and <code>@furiosa</code>)</li>
<li><strong>All subscriptions</strong>: Notify for every message</li>
<li><strong>No subscription</strong>: No notifications (client must poll inbox)</li>
</ul>
<h3>Client Buffer Management</h3>
<p>Both Unix socket and WebSocket connections use buffered I/O:</p>
<ul>
<li><strong>WebSocket</strong>: 256-message buffered channel per connection (<code>sendCh</code> in
<code>internal/websocket/connection.go</code>)</li>
<li><strong>Unix socket</strong>: Direct write to <code>net.Conn</code> with newline framing</li>
<li><strong>Slow client handling</strong>: If WebSocket buffer is full, the send fails and the
client is auto-unregistered</li>
</ul>
<h2>Usage</h2>
<h3>Daemon Initialization</h3>
<p>When starting the daemon, create the event streaming infrastructure:</p>
<pre><code>// Create daemon state
st, _ := state.NewState(thrumDir, syncDir, repoID)

// Create client registries
unixClients := daemon.NewClientRegistry()

// Create WebSocket server with handler registry and optional UI filesystem
wsServer := websocket.NewServer(wsAddr, wsRegistry, uiFS)

// Set up event streaming (wires Broadcaster + Dispatcher)
eventSetup := daemon.NewEventStreamingSetupFromState(st, unixClients, wsServer)

// Create message handler with the dispatcher for push notifications
messageHandler := rpc.NewMessageHandlerWithDispatcher(st, eventSetup.Dispatcher)

// Register handlers on both Unix socket and WebSocket registries...</code></pre>
<h3>Client Subscription</h3>
<p>Clients subscribe via the <code>subscribe</code> RPC method:</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;subscribe&quot;,
  &quot;params&quot;: {
    &quot;scope&quot;: { &quot;type&quot;: &quot;task&quot;, &quot;value&quot;: &quot;thrum-ukr&quot; }
  },
  &quot;id&quot;: 1
}</code></pre>
<p>Or subscribe to mentions:</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;subscribe&quot;,
  &quot;params&quot;: {
    &quot;mention_role&quot;: &quot;reviewer&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<p>Or subscribe to all messages (firehose):</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;subscribe&quot;,
  &quot;params&quot;: {
    &quot;all&quot;: true
  },
  &quot;id&quot;: 1
}</code></pre>
<h3>Receiving Notifications</h3>
<p>WebSocket clients receive notifications as JSON-RPC notifications (no response
required):</p>
<pre><code>// WebSocket client example
const ws = new WebSocket(&quot;ws://localhost:9999/ws&quot;);

ws.onmessage = (event) =&gt; {
  const notification = JSON.parse(event.data);
  if (notification.method === &quot;notification.message&quot;) {
    console.log(&quot;New message:&quot;, notification.params.preview);
  }
};</code></pre>
<h3>MCP Server Integration</h3>
<p>The MCP server (<code>thrum mcp serve</code>) uses WebSocket notifications for its
<code>wait_for_message</code> tool. It connects to the daemon&#39;s WebSocket endpoint and
subscribes to notifications, enabling blocking message waits for agent
sub-agents (like the message-listener pattern).</p>
<h2>Testing</h2>
<p>Comprehensive test coverage includes:</p>
<ol>
<li><p><strong>Unit Tests</strong> (<code>internal/daemon/broadcaster_test.go</code>)</p>
<ul>
<li>Broadcaster notification routing (WebSocket path)</li>
<li>Client not connected handling</li>
<li>Notification format conversion</li>
</ul>
</li>
<li><p><strong>Integration Tests</strong> (<code>internal/daemon/event_streaming_test.go</code>)</p>
<ul>
<li>End-to-end message notification flow with subscriptions</li>
<li>Subscription filtering (scope matching vs. non-matching)</li>
<li>Event streaming setup wiring</li>
<li>Mock notification receiver pattern</li>
</ul>
</li>
<li><p><strong>Dispatcher Tests</strong> (<code>internal/subscriptions/dispatcher_test.go</code>)</p>
<ul>
<li>Scope, mention, and &quot;all&quot; subscription matching</li>
<li>Name-based mention matching (@furiosa)</li>
<li>Multiple subscriptions per message</li>
<li>No subscriptions scenario</li>
</ul>
</li>
</ol>
<p>Run tests:</p>
<pre><code>go test ./internal/daemon/...
go test ./internal/subscriptions/...
go test ./internal/websocket/...</code></pre>
<h2>Performance Characteristics</h2>
<ul>
<li><strong>Latency</strong>: Sub-millisecond notification dispatch (synchronous in
message.send path)</li>
<li><strong>Throughput</strong>: Limited by subscription query (loads all subscriptions per
message)</li>
<li><strong>Memory</strong>: O(clients) for WebSocket send buffers (256 messages each),
O(subscriptions) for filtering</li>
<li><strong>Concurrency</strong>: Thread-safe Broadcaster, client registries, and dispatcher</li>
</ul>
<h2>Troubleshooting</h2>
<h3>Notifications Not Received</h3>
<ol>
<li>Check subscription exists: <code>thrum subscriptions</code> CLI or <code>subscriptions.list</code>
RPC</li>
<li>Verify client is connected: Check WebSocket client registry via daemon logs</li>
<li>Confirm event matches subscription: Check scope/mention filters match message
scopes/refs</li>
<li>Look for slow client disconnections: WebSocket buffer full (256-message
limit)</li>
<li>Verify WebSocket endpoint: Use <code>ws://localhost:9999/ws</code> (not
<code>ws://localhost:9999/</code>)</li>
</ol>
<h3>High Memory Usage</h3>
<ul>
<li>Too many buffered messages: Check for slow WebSocket consumers</li>
<li>Too many subscriptions: Review per-session subscription counts</li>
</ul>
<h3>Notification Lag</h3>
<ul>
<li>Subscription query is synchronous in message.send path</li>
<li>Check SQLite database performance</li>
<li>Monitor WebSocket connection health</li>
</ul>
<h2>References</h2>
<ul>
<li>Subscription Details: <code>docs/subscriptions.md</code></li>
<li>WebSocket API: <code>docs/api/websocket.md</code></li>
<li>Daemon Architecture: <code>docs/daemon.md</code></li>
<li>RPC API: <code>docs/rpc-api.md</code></li>
<li>Broadcaster: <code>internal/daemon/broadcaster.go</code></li>
<li>Dispatcher: <code>internal/subscriptions/dispatcher.go</code></li>
<li>Event Streaming Setup: <code>internal/daemon/event_streaming.go</code></li>
<li>WebSocket Server: <code>internal/websocket/server.go</code></li>
<li>WebSocket Client Registry: <code>internal/websocket/registry.go</code></li>
<li>Unix Socket Client Registry: <code>internal/daemon/notify.go</code></li>
</ul>
<pre><code></code></pre>

</main>
<script>if(location.search.indexOf('nospa')===-1){location.replace('../docs.html#event-streaming.html')}</script>
</body>
</html>