<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event Streaming — Thrum</title>
  <meta name="description" content="Real-time push notifications via Broadcaster and Dispatcher - subscription matching, delivery, and client registries">
  <!-- Open Graph -->
  <meta property="og:type" content="article">
  <meta property="og:title" content="Event Streaming — Thrum">
  <meta property="og:description" content="Real-time push notifications via Broadcaster and Dispatcher - subscription matching, delivery, and client registries">
  <meta property="og:url" content="https://leonletto.github.io/thrum/docs/event-streaming.html">
  <meta property="og:site_name" content="Thrum">
  <meta property="og:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Event Streaming — Thrum">
  <meta name="twitter:description" content="Real-time push notifications via Broadcaster and Dispatcher - subscription matching, delivery, and client registries">
  <meta name="twitter:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <!-- Canonical: SPA is the primary URL -->
  <link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#event-streaming.html">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x26A1;</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/theme.css">
  <link rel="stylesheet" href="../css/docs.css">
  <script>
    (function(){var t=localStorage.getItem('thrum-theme');if(t){document.documentElement.setAttribute('data-theme',t)}else if(window.matchMedia&&window.matchMedia('(prefers-color-scheme:light)').matches){document.documentElement.setAttribute('data-theme','light')}else{document.documentElement.setAttribute('data-theme','dark')}})();
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <nav class="header-nav">
        <a href="../index.html" class="logo">
          <span class="logo-glyph">&gt;_</span>
          <span class="logo-text">thrum</span>
        </a>
        <div class="nav-links">
          <a href="../index.html" class="nav-link">Home</a>
          <a href="../docs.html" class="nav-link nav-link-active">Docs</a>
          <a href="../about.html" class="nav-link">About</a>
          <a href="https://github.com/leonletto/thrum" class="nav-link nav-link-external" target="_blank" rel="noopener">GitHub</a>
        </div>
      </nav>
    </div>
  </header>
  <main class="docs-content" style="max-width:48rem;margin:2rem auto;padding:0 1.5rem">
    <div class="docs-content-inner">
<h2>Event Streaming</h2>
<h2>Overview</h2>
<p>Event streaming enables real-time push notifications to connected WebSocket and<br>Unix socket clients. When significant events occur (new messages), the daemon<br>automatically pushes notifications to subscribed clients.</p>
<p>The WebSocket server and embedded SPA are served on the same port (default 9999,<br>configurable via <code>THRUM_WS_PORT</code>). WebSocket connections use the <code>/ws</code> endpoint<br>when the UI is active, or <code>/</code> when running without UI.</p>
<h2>Architecture</h2>
<h3>Components</h3>
<ol>
<li><p><strong>Broadcaster</strong> (<code>internal/daemon/broadcaster.go</code>)</p>
<ul>
<li>Unified notification sender for both Unix socket and WebSocket clients</li>
<li>Implements the <code>ClientNotifier</code> interface expected by the subscription<br>dispatcher</li>
<li>Tries Unix socket transport first, then WebSocket as fallback</li>
<li>Handles client disconnections gracefully</li>
<li>Thread-safe with <code>sync.RWMutex</code></li>
</ul>
</li>
<li><p><strong>Subscription Dispatcher</strong> (<code>internal/subscriptions/dispatcher.go</code>)</p>
<ul>
<li>Matches events against active subscriptions</li>
<li>Filters events based on scopes, mentions (role-based and name-based), and<br>subscription types</li>
<li>Pushes notifications to matched subscribers via the Broadcaster</li>
</ul>
</li>
<li><p><strong>Event Streaming Setup</strong> (<code>internal/daemon/event_streaming.go</code>)</p>
<ul>
<li>Factory for wiring together Broadcaster and Dispatcher</li>
<li>Two convenience constructors:<ul>
<li><code>NewEventStreamingSetup(unixClients, wsServer, db)</code> - from raw components</li>
<li><code>NewEventStreamingSetupFromState(state, unixClients, wsServer)</code> - from<br>daemon state</li>
</ul>
</li>
<li>Returns <code>EventStreamingSetup</code> struct with <code>Broadcaster</code> and <code>Dispatcher</code><br>fields</li>
</ul>
</li>
</ol>
<h3>Data Flow</h3>
<pre><code class="language-text hljs">Event Source (message.send, message.edit)
  |
  v
Subscription Dispatcher
  | (query subscriptions, match against message scopes/mentions)
  v
Broadcaster
  |         |
  v         v
Unix Socket    WebSocket
Clients        Clients (port 9999, /ws endpoint)
```go

&gt; **Note:** All WebSocket connections enforce a 10s handshake timeout.
&gt; Server-side requests have a 10s per-request timeout (v0.4.3).

## Implementation Details

### Supported Notifications

Currently implemented:

- **`notification.message`** - Pushed when a new message is created or edited,
  matching a subscription

### Notification Format

Notifications use JSON-RPC 2.0 notification format (no `id` field, no response
expected):

```json
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;notification.message&quot;,
  &quot;params&quot;: {
    &quot;message_id&quot;: &quot;msg_...&quot;,
    &quot;author&quot;: {
      &quot;agent_id&quot;: &quot;furiosa&quot;,
      &quot;name&quot;: &quot;furiosa&quot;,
      &quot;role&quot;: &quot;implementer&quot;,
      &quot;module&quot;: &quot;&quot;
    },
    &quot;preview&quot;: &quot;First 100 characters of content...&quot;,
    &quot;scopes&quot;: [{ &quot;type&quot;: &quot;task&quot;, &quot;value&quot;: &quot;thrum-ukr&quot; }],
    &quot;matched_subscription&quot;: {
      &quot;subscription_id&quot;: 1,
      &quot;match_type&quot;: &quot;scope&quot;
    },
    &quot;timestamp&quot;: &quot;2026-02-03T10:00:00Z&quot;
  }
}
```text

### Subscription Filtering

The dispatcher automatically filters events based on subscriptions:

- **Scope subscriptions**: Only notify if message has matching scope
- **Mention subscriptions**: Only notify if message mentions the agent&#x27;s role or
  name (supports both `@reviewer` and `@furiosa`)
- **All subscriptions**: Notify for every message
- **No subscription**: No notifications (client must poll inbox)

### Client Buffer Management

Both Unix socket and WebSocket connections use buffered I/O:

- **WebSocket**: 256-message buffered channel per connection (`sendCh` in
  `internal/websocket/connection.go`)
- **Unix socket**: Direct write to `net.Conn` with newline framing
- **Slow client handling**: If WebSocket buffer is full, the send fails and the
  client is auto-unregistered

## Usage

### Daemon Initialization

When starting the daemon, create the event streaming infrastructure:

```go
// Create daemon state
st, _ := state.NewState(thrumDir, syncDir, repoID)

// Create client registries
unixClients := daemon.NewClientRegistry()

// Create WebSocket server with handler registry and optional UI filesystem
wsServer := websocket.NewServer(wsAddr, wsRegistry, uiFS)

// Set up event streaming (wires Broadcaster + Dispatcher)
eventSetup := daemon.NewEventStreamingSetupFromState(st, unixClients, wsServer)

// Create message handler with the dispatcher for push notifications
messageHandler := rpc.NewMessageHandlerWithDispatcher(st, eventSetup.Dispatcher)

// Register handlers on both Unix socket and WebSocket registries...
```go

### Client Subscription

Clients subscribe via the `subscribe` RPC method:

```json
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;subscribe&quot;,
  &quot;params&quot;: {
    &quot;scope&quot;: { &quot;type&quot;: &quot;task&quot;, &quot;value&quot;: &quot;thrum-ukr&quot; }
  },
  &quot;id&quot;: 1
}
```text

Or subscribe to mentions:

```json
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;subscribe&quot;,
  &quot;params&quot;: {
    &quot;mention_role&quot;: &quot;reviewer&quot;
  },
  &quot;id&quot;: 1
}
```text

Or subscribe to all messages (firehose):

```json
{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;subscribe&quot;,
  &quot;params&quot;: {
    &quot;all&quot;: true
  },
  &quot;id&quot;: 1
}
```text

### Receiving Notifications

WebSocket clients receive notifications as JSON-RPC notifications (no response
required):

```javascript
// WebSocket client example
const ws = new WebSocket(&quot;ws://localhost:9999/ws&quot;);

ws.onmessage = (event) =&gt; {
  const notification = JSON.parse(event.data);
  if (notification.method === &quot;notification.message&quot;) {
    console.log(&quot;New message:&quot;, notification.params.preview);
  }
};
```text

### MCP Server Integration

The MCP server (`thrum mcp serve`) uses WebSocket notifications for its
`wait_for_message` tool. It connects to the daemon&#x27;s WebSocket endpoint and
subscribes to notifications, enabling blocking message waits for agent
sub-agents (like the message-listener pattern).

## Testing

Comprehensive test coverage includes:

1. **Unit Tests** (`internal/daemon/broadcaster_test.go`)
   - Broadcaster notification routing (WebSocket path)
   - Client not connected handling
   - Notification format conversion

2. **Integration Tests** (`internal/daemon/event_streaming_test.go`)
   - End-to-end message notification flow with subscriptions
   - Subscription filtering (scope matching vs. non-matching)
   - Event streaming setup wiring
   - Mock notification receiver pattern

3. **Dispatcher Tests** (`internal/subscriptions/dispatcher_test.go`)
   - Scope, mention, and &quot;all&quot; subscription matching
   - Name-based mention matching (@furiosa)
   - Multiple subscriptions per message
   - No subscriptions scenario

Run tests:

```bash
go test ./internal/daemon/...
go test ./internal/subscriptions/...
go test ./internal/websocket/...
```text

## Performance Characteristics

- **Latency**: Sub-millisecond notification dispatch (synchronous in
  message.send path)
- **Throughput**: Limited by subscription query (loads all subscriptions per
  message)
- **Memory**: O(clients) for WebSocket send buffers (256 messages each),
  O(subscriptions) for filtering
- **Concurrency**: Thread-safe Broadcaster, client registries, and dispatcher

## Troubleshooting

### Notifications Not Received

1. Check subscription exists: `thrum subscriptions` CLI or `subscriptions.list`
   RPC
2. Verify client is connected: Check WebSocket client registry via daemon logs
3. Confirm event matches subscription: Check scope/mention filters match message
   scopes/refs
4. Look for slow client disconnections: WebSocket buffer full (256-message
   limit)
5. Verify WebSocket endpoint: Use `ws://localhost:9999/ws` (not
   `ws://localhost:9999/`)

### High Memory Usage

- Too many buffered messages: Check for slow WebSocket consumers
- Too many subscriptions: Review per-session subscription counts

### Notification Lag

- Subscription query is synchronous in message.send path
- Check SQLite database performance
- Monitor WebSocket connection health

## References

- Subscription Details: `docs/subscriptions.md`
- WebSocket API: `docs/api/websocket.md`
- Daemon Architecture: `docs/daemon.md`
- RPC API: `docs/rpc-api.md`
- Broadcaster: `internal/daemon/broadcaster.go`
- Dispatcher: `internal/subscriptions/dispatcher.go`
- Event Streaming Setup: `internal/daemon/event_streaming.go`
- WebSocket Server: `internal/websocket/server.go`
- WebSocket Client Registry: `internal/websocket/registry.go`
- Unix Socket Client Registry: `internal/daemon/notify.go`</code></pre>

    </div>
    <p style="margin-top:2rem"><a href="../docs.html#event-streaming.html">&larr; View in documentation</a></p>
  </main>
  <script>
    // Redirect browsers to the SPA for full navigation experience.
    // Crawlers (which don't execute JS) will index the static content above.
    if (window.location.search.indexOf('nospa') === -1) {
      window.location.replace('../docs.html#event-streaming.html');
    }
  </script>
</body>
</html>