<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multi-Agent Support — Thrum</title>
  <meta name="description" content="Agent groups, runtime presets, context prime, and coordination patterns for running multiple AI agents across worktrees and platforms">
  <!-- Open Graph -->
  <meta property="og:type" content="article">
  <meta property="og:title" content="Multi-Agent Support — Thrum">
  <meta property="og:description" content="Agent groups, runtime presets, context prime, and coordination patterns for running multiple AI agents across worktrees and platforms">
  <meta property="og:url" content="https://leonletto.github.io/thrum/docs/multi-agent.html">
  <meta property="og:site_name" content="Thrum">
  <meta property="og:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Multi-Agent Support — Thrum">
  <meta name="twitter:description" content="Agent groups, runtime presets, context prime, and coordination patterns for running multiple AI agents across worktrees and platforms">
  <meta name="twitter:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <!-- Canonical: SPA is the primary URL -->
  <link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#multi-agent.html">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x26A1;</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/theme.css">
  <link rel="stylesheet" href="../css/docs.css">
  <script>
    (function(){var t=localStorage.getItem('thrum-theme');if(t){document.documentElement.setAttribute('data-theme',t)}else if(window.matchMedia&&window.matchMedia('(prefers-color-scheme:light)').matches){document.documentElement.setAttribute('data-theme','light')}else{document.documentElement.setAttribute('data-theme','dark')}})();
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <nav class="header-nav">
        <a href="../index.html" class="logo">
          <span class="logo-glyph">&gt;_</span>
          <span class="logo-text">thrum</span>
        </a>
        <div class="nav-links">
          <a href="../index.html" class="nav-link">Home</a>
          <a href="../docs.html" class="nav-link nav-link-active">Docs</a>
          <a href="../about.html" class="nav-link">About</a>
          <a href="https://github.com/leonletto/thrum" class="nav-link nav-link-external" target="_blank" rel="noopener">GitHub</a>
        </div>
      </nav>
    </div>
  </header>
  <main class="docs-content" style="max-width:48rem;margin:2rem auto;padding:0 1.5rem">
    <div class="docs-content-inner">
<h2>Multi-Agent Support</h2>
<blockquote>
<p>See also: <a href="philosophy.html">Why Thrum Exists</a> for the philosophy behind<br>human-directed coordination, <a href="agent-coordination.html">Agent Coordination</a> for<br>workflow patterns and Beads integration,<br><a href="workflow-templates.html">Workflow Templates</a> for structured planning and<br>implementation workflows, <a href="identity.html">Identity System</a> for agent naming and<br>registration.</p>
</blockquote>
<h2>Overview</h2>
<p>Thrum helps you coordinate multiple AI agents from the ground up. You can run<br>agents in different terminals, worktrees, or on different machines — they share<br>a single daemon and message store. Each agent gets a unique identity, and you<br>get tools to organize agents into teams, detect and configure any AI coding<br>platform, and recover full session context after compaction.</p>
<p><strong>Key multi-agent capabilities:</strong></p>
<ul>
<li><strong>Agent Groups</strong> -- Named collections of agents and roles for targeted<br>messaging</li>
<li><strong>Runtime Presets</strong> -- Auto-detect and configure Claude Code, Codex, Cursor,<br>Gemini, and other AI platforms</li>
<li><strong>Context Prime</strong> -- Single command to gather full agent state for session<br>initialization or recovery</li>
<li><strong>Coordination Tools</strong> -- File ownership tracking, agent presence, and<br>efficient message waiting</li>
</ul>
<h2>Agent Groups</h2>
<p>Groups let you send messages to collections of agents without addressing each<br>one individually. Groups can contain specific agents or all agents with a role.</p>
<h3>Quick Reference</h3>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>thrum group create NAME</code></td>
<td>Create a new group</td>
</tr>
<tr>
<td><code>thrum group delete NAME</code></td>
<td>Delete a group (cannot delete <code>@everyone</code>)</td>
</tr>
<tr>
<td><code>thrum group add GROUP MEMBER</code></td>
<td>Add agent or role</td>
</tr>
<tr>
<td><code>thrum group remove GROUP MEMBER</code></td>
<td>Remove a member</td>
</tr>
<tr>
<td><code>thrum group list</code></td>
<td>List all groups</td>
</tr>
<tr>
<td><code>thrum group info NAME</code></td>
<td>Show group details</td>
</tr>
<tr>
<td><code>thrum group members NAME</code></td>
<td>List members (<code>--expand</code> resolves to agent IDs)</td>
</tr>
</tbody></table>
<h3>Auto-Created Groups</h3>
<p>Thrum automatically creates two types of system groups:</p>
<ul>
<li><strong><code>@everyone</code></strong> — Created on daemon startup. Includes all registered agents via
a <code>role:*</code> wildcard. New agents are automatically reachable through it. Cannot
be deleted or modified.</li>
<li><strong>Role groups</strong> — Created automatically when an agent registers with a new role
(e.g., registering with <code>--role reviewer</code> creates a <code>@reviewer</code> group containing
all agents with that role). Role groups have IDs like <code>grp_role_reviewer</code> and
are managed by the system.</li>
</ul>
<p>This means <code>@reviewer</code> always routes to all agents with the <code>reviewer</code> role,
even without manually creating or managing a group.</p>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Send to all agents</span>
thrum send <span class="hljs-string">&quot;Deploy complete, all clear&quot;</span> --to @everyone
```text

All three forms are equivalent:

```bash
thrum send <span class="hljs-string">&quot;Deploy complete&quot;</span> --broadcast
thrum send <span class="hljs-string">&quot;Deploy complete&quot;</span> --to @everyone
thrum send <span class="hljs-string">&quot;Deploy complete&quot;</span> --everyone
```text

<span class="hljs-comment">### Creating and Managing Groups</span>

```bash
<span class="hljs-comment"># Create a group with a description</span>
thrum group create reviewers --description <span class="hljs-string">&quot;Code review team&quot;</span>

<span class="hljs-comment"># Add individual agents</span>
thrum group add reviewers @alice
thrum group add reviewers @bob

<span class="hljs-comment"># Add all agents with a specific role</span>
thrum group add reviewers --role reviewer

<span class="hljs-comment"># Remove a member</span>
thrum group remove reviewers @bob

<span class="hljs-comment"># List all groups</span>
thrum group list

<span class="hljs-comment"># Show group details</span>
thrum group info reviewers
```text

<span class="hljs-comment">### Member Types</span>

Groups support two member types:

| Type  | Syntax            | Resolves To                          |
| ----- | ----------------- | ------------------------------------ |
| Agent | `@alice`          | A specific agent by name             |
| Role  | `--role reviewer` | All agents registered with that role |

<span class="hljs-comment">### Sending to Groups</span>

Use `--to @groupname` just like sending to an individual agent:

```bash
<span class="hljs-comment"># Send to the review team</span>
thrum send <span class="hljs-string">&quot;PR #42 ready for review&quot;</span> --to @reviewers

<span class="hljs-comment"># Send to all developers</span>
thrum send <span class="hljs-string">&quot;Code freeze starts now&quot;</span> --to @all-devs
```text

The daemon resolves group membership at **<span class="hljs-built_in">read</span> <span class="hljs-keyword">time</span>** using a SQL query. This
means agents added to a group after a message was sent still receive it.

<span class="hljs-comment">### Expanding Group Membership</span>

Use `--<span class="hljs-built_in">expand</span>` to see <span class="hljs-built_in">which</span> individual agents a group resolves to:

```bash
thrum group members reviewers --<span class="hljs-built_in">expand</span> --json
```go

Output:

```json
{
  <span class="hljs-string">&quot;members&quot;</span>: [
    { <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;agent&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;alice&quot;</span> },
    { <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;role&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;reviewer&quot;</span> }
  ],
  <span class="hljs-string">&quot;expanded&quot;</span>: [<span class="hljs-string">&quot;alice&quot;</span>, <span class="hljs-string">&quot;bob&quot;</span>, <span class="hljs-string">&quot;carol&quot;</span>]
}
```text

<span class="hljs-comment">### MCP Group Tools</span>

When using the MCP server (`thrum mcp serve`), <span class="hljs-built_in">groups</span> are managed via native MCP
tools:

| MCP Tool              | Parameters                             | Description                         |
| --------------------- | -------------------------------------- | ----------------------------------- |
| `create_group`        | `name`, `description?`                 | Create a named group                |
| `delete_group`        | `name`                                 | Delete a group                      |
| `add_group_member`    | `group`, `member_type`, `member_value` | Add member to group                 |
| `remove_group_member` | `group`, `member_type`, `member_value` | Remove member from group            |
| `list_groups`         | --                                     | List all <span class="hljs-built_in">groups</span>                     |
| `get_group`           | `name`, `<span class="hljs-built_in">expand</span>?`                      | Get details with optional expansion |

Example MCP usage:

```text
mcp__thrum__create_group(name=<span class="hljs-string">&quot;backend&quot;</span>, description=<span class="hljs-string">&quot;Backend team&quot;</span>)
mcp__thrum__add_group_member(group=<span class="hljs-string">&quot;backend&quot;</span>, member_type=<span class="hljs-string">&quot;role&quot;</span>, member_value=<span class="hljs-string">&quot;implementer&quot;</span>)
mcp__thrum__send_message(to=<span class="hljs-string">&quot;@backend&quot;</span>, content=<span class="hljs-string">&quot;API changes merged&quot;</span>)
```text

---

<span class="hljs-comment">## Runtime Presets</span>

Thrum supports multiple AI coding platforms through a runtime preset system.
Each preset knows how to configure MCP servers, instruction files, and hooks <span class="hljs-keyword">for</span>
a specific platform.

<span class="hljs-comment">### Built-in Presets</span>

| Preset   | Display Name    | MCP | Hooks | Instructions File           |
| -------- | --------------- | --- | ----- | --------------------------- |
| `claude` | Claude Code     | Yes | Yes   | `CLAUDE.md`                 |
| `codex`  | OpenAI Codex    | Yes | No    | `AGENTS.md`                 |
| `cursor` | Cursor          | Yes | No    | `.cursorrules`              |
| `gemini` | Google Gemini   | Yes | No    | `~/.gemini/instructions.md` |
| `auggie` | Augment         | No  | No    | `CLAUDE.md`                 |
| `amp`    | Sourcegraph Amp | No  | No    | `CLAUDE.md`                 |

<span class="hljs-comment">### CLI Commands</span>

```bash
<span class="hljs-comment"># List all available presets (built-in + user-defined)</span>
thrum runtime list

<span class="hljs-comment"># Show details for a specific preset</span>
thrum runtime show claude

<span class="hljs-comment"># Set a default runtime for this machine</span>
thrum runtime set-default claude
```text

<span class="hljs-comment">### Auto-Detection</span>

Thrum can auto-detect <span class="hljs-built_in">which</span> AI platform is running by checking <span class="hljs-keyword">for</span> file markers
and environment variables:

**File markers:**

| Marker File             | Detected Runtime |
| ----------------------- | ---------------- |
| `.claude/settings.json` | `claude`         |
| `.codex`                | `codex`          |
| `.cursorrules`          | `cursor`         |
| `.augment`              | `auggie`         |

**Environment variables:**

| Variable            | Detected Runtime |
| ------------------- | ---------------- |
| `CLAUDE_SESSION_ID` | `claude`         |
| `CURSOR_SESSION`    | `cursor`         |
| `GEMINI_CLI`        | `gemini`         |
| `AUGMENT_AGENT`     | `auggie`         |

If no runtime is detected, Thrum falls back to CLI-only mode (no MCP
configuration generated).

<span class="hljs-comment">### Integration with init and quickstart</span>

Use `--runtime` to specify or auto-detect the platform:

```bash
<span class="hljs-comment"># Auto-detect and generate config</span>
thrum init --runtime auto

<span class="hljs-comment"># Explicit runtime selection</span>
thrum init --runtime claude
<span class="hljs-comment"># Generates .claude/settings.json with thrum MCP server config</span>

thrum init --runtime cursor
<span class="hljs-comment"># Generates .cursorrules with thrum instructions</span>

<span class="hljs-comment"># Quickstart with runtime detection</span>
thrum quickstart --name furiosa --role implementer --module auth \
  --runtime claude --intent <span class="hljs-string">&quot;JWT auth&quot;</span>
```text

<span class="hljs-comment">### Dry-Run Mode</span>

Preview what configuration files would be generated without connecting to the
daemon or writing files:

```bash
thrum quickstart --runtime cursor --dry-run
<span class="hljs-comment"># Shows .cursorrules content and MCP config that would be created</span>
```text

<span class="hljs-comment">### Custom Runtimes</span>

Add custom runtime presets via `~/.config/thrum/runtimes.json` (XDG-aware):

```json
{
  <span class="hljs-string">&quot;default_runtime&quot;</span>: <span class="hljs-string">&quot;claude&quot;</span>,
  <span class="hljs-string">&quot;custom_runtimes&quot;</span>: {
    <span class="hljs-string">&quot;my-agent&quot;</span>: {
      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;my-agent&quot;</span>,
      <span class="hljs-string">&quot;display_name&quot;</span>: <span class="hljs-string">&quot;My Custom Agent&quot;</span>,
      <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;my-agent&quot;</span>,
      <span class="hljs-string">&quot;mcp_supported&quot;</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-string">&quot;hooks_supported&quot;</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-string">&quot;instructions_file&quot;</span>: <span class="hljs-string">&quot;AGENTS.md&quot;</span>,
      <span class="hljs-string">&quot;mcp_config_path&quot;</span>: <span class="hljs-string">&quot;~/.my-agent/settings.json&quot;</span>,
      <span class="hljs-string">&quot;setup_notes&quot;</span>: <span class="hljs-string">&quot;Custom setup instructions&quot;</span>
    }
  }
}
```text

Custom runtimes appear alongside built-in presets <span class="hljs-keyword">in</span> `thrum runtime list`.

---

<span class="hljs-comment">## Context Prime</span>

After compaction or starting a new session, you want to quickly answer: what was
I working on? Context prime gathers all agent state into a single output so an
agent can pick up <span class="hljs-built_in">where</span> it left off.

<span class="hljs-comment">### Usage</span>

```bash
<span class="hljs-comment"># Human-readable summary</span>
thrum context prime

<span class="hljs-comment"># Structured JSON for LLM consumption</span>
thrum context prime --json
```text

<span class="hljs-comment">### What It Gathers</span>

Context prime collects information from multiple sources <span class="hljs-keyword">in</span> one call:

| Section  | Source          | Content                                         |
| -------- | --------------- | ----------------------------------------------- |
| Identity | Identity file   | Agent ID, role, module, display name            |
| Session  | Daemon RPC      | Session ID, intent, task, <span class="hljs-built_in">uptime</span>                |
| Agents   | Daemon RPC      | List of registered agents with status and roles |
| Inbox    | Daemon RPC      | Unread message count, total messages            |
| Git      | Local git state | Current branch, recent commits, changed files   |
| Context  | Context file    | Saved context from previous session (<span class="hljs-keyword">if</span> exists) |

<span class="hljs-comment">### Example Output</span>

```text
=== Context Prime <span class="hljs-keyword">for</span> furiosa ===

Identity: furiosa (implementer @ auth)
Session:  ses_01HXF2A9... (active 2h15m)
Intent:   JWT authentication implementation

Agents Online:
  planner    coordinator @ main    (active 5m ago)
  reviewer   reviewer @ all        (active 12m ago)

Inbox: 3 unread / 12 total

Git:
  Branch: feature/auth
  Ahead:  3 commits
  Files:  src/auth.go, src/auth_test.go (modified)

Saved Context:
  <span class="hljs-comment"># Next Steps</span>
  - Finish JWT implementation
  - Add rate limiting tests
```text

<span class="hljs-comment">### Graceful Degradation</span>

Context prime handles missing components gracefully:

- **No daemon running** -- skips session, agents, and inbox sections
- **No active session** -- shows identity only
- **No git repo** -- skips git section
- **No saved context** -- skips context section
- **No remote** -- skips upstream comparison

This makes it safe to run at any point, even before the daemon is started.

<span class="hljs-comment">### Use Cases</span>

- **Session startup** -- run at the beginning of every session to understand
  current state
- **After compaction** -- recover full context when the LLM<span class="hljs-string">&#x27;s context window
  resets
- **Handoff between agents** -- incoming agent runs context prime to understand
  the project state
- **Debugging** -- quickly see what the agent knows and what it&#x27;</span>s working on

---

<span class="hljs-comment">## Multi-Worktree Coordination</span>

Multiple agents can operate across git worktrees <span class="hljs-keyword">while</span> sharing a single daemon
and message store.

<span class="hljs-comment">### How It Works</span>

```text
┌──────────────────────────────────────────────────────────────┐
│                     Main Worktree                             │
│  /path/to/repo                                                │
│  ├── .thrum/                    ← Daemon socket, SQLite, IDs  │
│  ├── .git/thrum-sync/a-sync/   ← JSONL event <span class="hljs-built_in">log</span>             │
│  └── Daemon process (shared)                                  │
├──────────────────────────────────────────────────────────────┤
│                     Feature Worktrees                         │
│  ~/.workspaces/repo/auth/                                     │
│  ├── .thrum/redirect → /path/to/repo/.thrum/                 │
│  └── Uses same daemon, same messages                          │
│                                                               │
│  ~/.workspaces/repo/sync/                                     │
│  ├── .thrum/redirect → /path/to/repo/.thrum/                 │
│  └── Uses same daemon, same messages                          │
└──────────────────────────────────────────────────────────────┘
```text

- **One daemon per repository** -- not per worktree
- Feature worktrees use `.thrum/redirect` to point to the main `.thrum/`
  directory
- All agents connect via the same Unix socket
- Each agent has its own identity file and message shard

<span class="hljs-comment">### Setting Up Feature Worktrees</span>

```bash
<span class="hljs-comment"># Create the worktree</span>
git worktree add ~/.workspaces/repo/auth -b feature/auth

<span class="hljs-comment"># Set up thrum redirect (shares daemon with main repo)</span>
thrum setup --main-repo /path/to/repo

<span class="hljs-comment"># Or use the setup script</span>
scripts/setup-worktree-thrum.sh ~/.workspaces/repo/auth
```text

<span class="hljs-comment">### Running Multiple Agents</span>

Each agent <span class="hljs-keyword">in</span> a worktree gets its own identity:

```bash
<span class="hljs-comment"># Main worktree: coordinator (name must differ from role)</span>
<span class="hljs-built_in">cd</span> /path/to/repo
thrum quickstart --name coord_main --role coordinator --module main

<span class="hljs-comment"># Auth worktree: implementer</span>
<span class="hljs-built_in">cd</span> ~/.workspaces/repo/auth
<span class="hljs-built_in">export</span> THRUM_NAME=furiosa
thrum quickstart --name furiosa --role implementer --module auth

<span class="hljs-comment"># Sync worktree: another implementer</span>
<span class="hljs-built_in">cd</span> ~/.workspaces/repo/sync
<span class="hljs-built_in">export</span> THRUM_NAME=nux
thrum quickstart --name nux --role implementer --module <span class="hljs-built_in">sync</span>
```text

All three agents share the same daemon and can message each other:

```bash
<span class="hljs-comment"># furiosa sends to coordinator</span>
thrum send <span class="hljs-string">&quot;Auth module complete, tests passing&quot;</span> --to @coordinator

<span class="hljs-comment"># coordinator sends to the whole team</span>
thrum send <span class="hljs-string">&quot;Both features ready, starting integration&quot;</span> --to @everyone
```text

<span class="hljs-comment">### Multiple Agents in the Same Worktree</span>

Multiple agents can coexist <span class="hljs-keyword">in</span> a single worktree. Each gets a separate identity
file <span class="hljs-keyword">in</span> `.thrum/identities/`:

```text
.thrum/identities/
├── furiosa.json     <span class="hljs-comment"># implementation agent</span>
├── reviewer.json    <span class="hljs-comment"># review agent</span>
```text

Use `THRUM_NAME` to <span class="hljs-keyword">select</span> <span class="hljs-built_in">which</span> identity to use:

```bash
THRUM_NAME=furiosa thrum send <span class="hljs-string">&quot;Implementation complete&quot;</span>
THRUM_NAME=reviewer thrum send <span class="hljs-string">&quot;LGTM, approved&quot;</span>
```text

---

<span class="hljs-comment">## Coordination Tools</span>

<span class="hljs-comment">### who-has: File Ownership</span>

Check <span class="hljs-built_in">which</span> agents are currently working on a file:

```bash
thrum who-has auth.go
<span class="hljs-comment"># Output: @furiosa is editing auth.go (feature/auth, 3 unmerged commits)</span>

thrum who-has internal/cli/agent.go
<span class="hljs-comment"># Output: No agent is currently editing internal/cli/agent.go</span>
```text

This queries agent work contexts (tracked via `thrum agent list --context`) to
prevent two agents from editing the same file simultaneously.

<span class="hljs-comment">### ping: Agent Presence</span>

Check <span class="hljs-keyword">if</span> an agent is online and what they are working on:

```bash
thrum ping @reviewer
<span class="hljs-comment"># Output:</span>
<span class="hljs-comment">#   reviewer: active (last seen 2m ago)</span>
<span class="hljs-comment">#   Intent: Reviewing PR #42</span>

thrum ping @furiosa
<span class="hljs-comment"># Output:</span>
<span class="hljs-comment">#   furiosa: offline (last seen 3h ago)</span>
```text

Agents are considered `active` <span class="hljs-keyword">if</span> seen within the last 2 minutes, `offline`
otherwise.

<span class="hljs-comment">### wait: Efficient Message Blocking</span>

Block <span class="hljs-keyword">until</span> a matching message arrives or a <span class="hljs-built_in">timeout</span> expires. This is the
foundation of the message-listener pattern <span class="hljs-keyword">for</span> async agent coordination.

`thrum <span class="hljs-built_in">wait</span>` always filters by the calling agent<span class="hljs-string">&#x27;s identity — it only returns
messages directed to this agent (by name or role group). There is no `--all`
flag; use subscriptions if you need a firehose.

```bash
# Wait for any message addressed to this agent
thrum wait --timeout 5m

# Wait for messages since a time offset (skip old messages)
thrum wait --after -30s --timeout 5m --json

# Wait for mentions of your role
thrum wait --mention @reviewer --timeout 5m
```text

| Flag        | Format                       | Description                     |
| ----------- | ---------------------------- | ------------------------------- |
| `--timeout` | Duration (e.g., `5m`)        | Max wait time (default: `30s`)  |
| `--mention` | `@role`                      | Wait for mentions of a role     |
| `--after`   | Relative time (e.g., `-30s`) | Only messages after this offset |
| `--json`    | Boolean                      | Output messages as JSON         |

**Exit codes:**

- `0` -- message received
- `1` -- timeout (no messages)
- `2` -- error

---

## Complete Workflows

### Workflow 1: Setting Up a Review Team

```bash
# 1. Create a review team group
thrum group create reviewers --description &quot;Code review team&quot;
thrum group add reviewers --role reviewer
thrum group add reviewers @alice

# 2. Implementer finishes work and notifies the team
thrum send &quot;PR #42 ready for review: JWT auth implementation&quot; \
  --to @reviewers --ref pr:42

# 3. Reviewers check their inbox
thrum inbox --mentions

# 4. Reviewer responds
thrum reply msg_01HXE... &quot;Reviewed. LGTM with minor comments on error handling.&quot;
```text

### Workflow 2: Cross-Platform Agent Setup

```bash
# Claude Code agent
thrum init --runtime claude
thrum quickstart --name claude_agent --role implementer --module auth \
  --runtime claude --intent &quot;Implementing auth&quot;
# Generates .claude/settings.json with MCP config

# Cursor agent (same repo, different terminal)
thrum init --runtime cursor
thrum quickstart --name cursor_agent --role reviewer --module auth \
  --runtime cursor --intent &quot;Reviewing auth&quot;
# Generates .cursorrules with thrum instructions

# Both agents share the same daemon and can message each other
```text

### Workflow 3: Session Recovery After Compaction

```bash
# Agent&#x27;</span>s context window was compacted -- recover state
thrum context prime
<span class="hljs-comment"># Shows: identity, session, team, inbox, git state, saved context</span>

<span class="hljs-comment"># Check for urgent messages</span>
thrum inbox --unread

<span class="hljs-comment"># Resume work based on recovered context</span>
thrum agent set-intent <span class="hljs-string">&quot;Resuming JWT implementation after compaction&quot;</span>
```text

<span class="hljs-comment">### Workflow 4: Multi-Worktree Team Coordination</span>

```bash
<span class="hljs-comment"># === Coordinator (main worktree) ===</span>
thrum quickstart --name coord_main --role coordinator --module main
thrum group create backend --description <span class="hljs-string">&quot;Backend team&quot;</span>
thrum group add backend @furiosa
thrum group add backend @nux

<span class="hljs-comment"># Assign work</span>
thrum send <span class="hljs-string">&quot;furiosa: implement auth (feature/auth worktree)&quot;</span> --to @furiosa
thrum send <span class="hljs-string">&quot;nux: implement sync (feature/sync worktree)&quot;</span> --to @nux

<span class="hljs-comment"># Check team status</span>
thrum agent list --context
<span class="hljs-comment"># AGENT        ROLE          MODULE  BRANCH         FILES</span>
<span class="hljs-comment"># coord_main   coordinator   main    main           -</span>
<span class="hljs-comment"># furiosa      implementer   auth    feature/auth   src/auth.go</span>
<span class="hljs-comment"># nux          implementer   sync    feature/sync   internal/sync/loop.go</span>

<span class="hljs-comment"># Send update to the whole backend team</span>
thrum send <span class="hljs-string">&quot;Both features shipping in v0.4&quot;</span> --to @backend

<span class="hljs-comment"># === Implementer (auth worktree) ===</span>
<span class="hljs-built_in">cd</span> ~/.workspaces/repo/auth
<span class="hljs-built_in">export</span> THRUM_NAME=furiosa
thrum inbox --unread
thrum send <span class="hljs-string">&quot;Auth complete, 15 tests passing&quot;</span> --to @coordinator
```text

---

<span class="hljs-comment">## Best Practices</span>

<span class="hljs-comment">### Group Organization</span>

- **Start simple** -- create <span class="hljs-built_in">groups</span> as coordination needs emerge, not upfront
- **Use role-based membership** when possible (`--role reviewer`) so new agents
  with that role are automatically included
- **Use `@everyone` sparingly** -- prefer targeted <span class="hljs-built_in">groups</span> to reduce noise

<span class="hljs-comment">### Runtime Configuration</span>

- **Let Thrum auto-detect** when possible (`--runtime auto` or omit the flag)
- **Set a default runtime** on your machine <span class="hljs-keyword">if</span> you always use the same platform:
  `thrum runtime set-default claude`
- **Use `--dry-run`** to preview generated configs before committing to them

<span class="hljs-comment">### Context Recovery</span>

- **Run `thrum context prime`** at the start of every session
- **Save context** at the end of every session:
  `<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# Next steps\n- ...&quot;</span> | thrum context save`
- **After compaction**, context prime provides everything needed to resume work

<span class="hljs-comment">### Coordination</span>

- **Check `who-has`** before editing files another agent might be working on
- **Use `thrum <span class="hljs-built_in">wait</span>`** instead of polling loops <span class="hljs-keyword">for</span> efficient message delivery
- **Set clear intents** so other agents can see what you are working on via
  `thrum agent list --context`

<span class="hljs-comment">## See Also</span>

- [Tailscale Sync](tailscale-sync.md) -- Cross-machine <span class="hljs-built_in">sync</span> via Tailscale with
  Ed25519 signing and peer discovery
- [Agent Coordination](agent-coordination.md) -- Workflow patterns and Beads
  integration
- [Identity System](identity.md) -- Agent naming, registration, and conflict
  resolution
- [Messaging System](messaging.md) -- Message structure, threads, scopes, and
  refs
- [MCP Server](mcp-server.md) -- MCP tools <span class="hljs-keyword">for</span> AI agent integration
- [Context Management](context.md) -- Per-agent context storage and preambles
- [CLI Reference](cli.md) -- Complete <span class="hljs-built_in">command</span> documentation</code></pre>

    </div>
    <p style="margin-top:2rem"><a href="../docs.html#multi-agent.html">&larr; View in documentation</a></p>
  </main>
  <script>
    // Redirect browsers to the SPA for full navigation experience.
    // Crawlers (which don't execute JS) will index the static content above.
    if (window.location.search.indexOf('nospa') === -1) {
      window.location.replace('../docs.html#multi-agent.html');
    }
  </script>
</body>
</html>