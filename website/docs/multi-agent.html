<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Multi-Agent Support — Thrum</title>
<meta name="description" content="Agent groups, runtime presets, context prime, and coordination patterns for running multiple AI agents across worktrees and platforms">
<link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#multi-agent.html">
<style>
body{font-family:system-ui,sans-serif;max-width:48rem;margin:2rem auto;padding:0 1.5rem;line-height:1.6;color:#222}
pre{background:#f5f5f5;padding:1rem;overflow-x:auto;border-radius:4px}
code{font-family:ui-monospace,monospace;font-size:0.9em}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #ddd;padding:0.4rem 0.6rem;text-align:left}
th{background:#f5f5f5}
nav{margin-bottom:1.5rem;padding-bottom:1rem;border-bottom:1px solid #ddd;line-height:1.8}
h2{margin-top:2rem}
a{color:#0366d6}
</style>
</head>
<body>
<nav>
<strong><a href="../docs.html">Thrum Docs</a></strong> &rsaquo; Guides &rsaquo; Multi-Agent Support
<hr>
<strong>Overview</strong>: <a href="philosophy.html">Philosophy</a><br>
<strong>Getting Started</strong>: <a href="quickstart.html">Quickstart Guide</a><br>
  <strong>Recommended Tools</strong>: <a href="guides/recommended-tools.html">Recommended Tools</a> | <a href="guides/beads-setup.html">Beads Setup Guide</a> | <a href="guides/beads-ui-setup.html">Beads UI Setup Guide</a> | <a href="guides/playwright-cli-setup.html">Playwright CLI Setup Guide</a><br>
<strong>Web UI</strong>: <a href="web-ui.html">Web UI</a><br>
<strong>Messaging</strong>: <a href="subscriptions.html">Subscriptions & Notifications</a><br>
<strong>Identity</strong>: <a href="identity.html">Agent Identity & Registration</a><br>
<strong>Guides</strong>: <a href="agent-coordination.html">Agent Coordination</a> | <a href="agent-configs.html">Agent Configurations</a> | <strong>Multi-Agent Support</strong> | <a href="claude-code-plugin.html">Claude Code Plugin</a> | <a href="configuration.html">Configuration</a> | <a href="workflow-templates.html">Workflow Templates</a> | <a href="beads-and-thrum.html">Beads and Thrum</a> | <a href="codex-plugin.html">Codex Plugin</a> | <a href="claude-agent-integration.html">Claude Code Agent Integration</a> | <a href="messaging.html">Messaging</a> | <a href="tailscale-sync.html">Tailscale Sync</a> | <a href="tailscale-security.html">Tailscale Sync Security</a> | <a href="overview.html">Technical Overview</a><br>
<strong>API Reference</strong>: <a href="event-streaming.html">Event Streaming</a> | <a href="inbox-query-methods.html">Inbox Query Methods</a> | <a href="api/authentication.html">Authentication</a> | <a href="api/events.html">Event Reference</a> | <a href="rpc-api.html">RPC API</a> | <a href="api/websocket.html">WebSocket API</a><br>
<strong>Daemon</strong>: <a href="daemon.html">Daemon Architecture</a><br>
<strong>Sync</strong>: <a href="sync.html">Sync Protocol</a><br>
<strong>Development</strong>: <a href="development.html">Development Guide</a> | <a href="security-cicd.html">Security & CI/CD</a><br>
<strong>Architecture</strong>: <a href="architecture.html">Architecture</a><br>
<strong>Context</strong>: <a href="context.html">Agent Context Management</a><br>
<strong>Reference</strong>: <a href="cli.html">CLI Reference</a> | <a href="mcp-server.html">MCP Server</a><br>
<strong>uncategorized</strong>: <a href="role-templates.html">Role-Based Preamble Templates</a><br>
</nav>
<main>
<h2>Multi-Agent Support</h2>
<blockquote>
<p>See also: <a href="philosophy.html">Why Thrum Exists</a> for the philosophy behind
human-directed coordination, <a href="agent-coordination.html">Agent Coordination</a> for
workflow patterns and Beads integration,
<a href="workflow-templates.html">Workflow Templates</a> for structured planning and
implementation workflows, <a href="identity.html">Identity System</a> for agent naming and
registration.</p>
</blockquote>
<h2>Overview</h2>
<p>Thrum helps you coordinate multiple AI agents from the ground up. You can run
agents in different terminals, worktrees, or on different machines — they share
a single daemon and message store. Each agent gets a unique identity, and you
get tools to organize agents into teams, detect and configure any AI coding
platform, and recover full session context after compaction.</p>
<p><strong>Key multi-agent capabilities:</strong></p>
<ul>
<li><strong>Agent Groups</strong> -- Named collections of agents and roles for targeted
messaging</li>
<li><strong>Runtime Presets</strong> -- Auto-detect and configure Claude Code, Codex, Cursor,
Gemini, and other AI platforms</li>
<li><strong>Context Prime</strong> -- Single command to gather full agent state for session
initialization or recovery</li>
<li><strong>Coordination Tools</strong> -- File ownership tracking, agent presence, and
efficient message waiting</li>
</ul>
<h2>Agent Groups</h2>
<p>Groups let you send messages to collections of agents without addressing each
one individually. Groups can contain specific agents or all agents with a role.</p>
<h3>Quick Reference</h3>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>thrum group create NAME</code></td>
<td>Create a new group</td>
</tr>
<tr>
<td><code>thrum group delete NAME</code></td>
<td>Delete a group (cannot delete <code>@everyone</code>)</td>
</tr>
<tr>
<td><code>thrum group add GROUP MEMBER</code></td>
<td>Add agent or role</td>
</tr>
<tr>
<td><code>thrum group remove GROUP MEMBER</code></td>
<td>Remove a member</td>
</tr>
<tr>
<td><code>thrum group list</code></td>
<td>List all groups</td>
</tr>
<tr>
<td><code>thrum group info NAME</code></td>
<td>Show group details</td>
</tr>
<tr>
<td><code>thrum group members NAME</code></td>
<td>List members (<code>--expand</code> resolves to agent IDs)</td>
</tr>
</tbody></table>
<h3>Auto-Created Groups</h3>
<p>Thrum automatically creates two types of system groups:</p>
<ul>
<li><strong><code>@everyone</code></strong> — Created on daemon startup. Includes all registered agents via
a <code>role:*</code> wildcard. New agents are automatically reachable through it. Cannot
be deleted or modified.</li>
<li><strong>Role groups</strong> — Created automatically when an agent registers with a new role
(e.g., registering with <code>--role reviewer</code> creates a <code>@reviewer</code> group containing
all agents with that role). Role groups have IDs like <code>grp_role_reviewer</code> and
are managed by the system.</li>
</ul>
<p>This means <code>@reviewer</code> always routes to all agents with the <code>reviewer</code> role,
even without manually creating or managing a group.</p>
<pre><code># Send to all agents
thrum send &quot;Deploy complete, all clear&quot; --to @everyone</code></pre>
<p>All three forms are equivalent:</p>
<pre><code>thrum send &quot;Deploy complete&quot; --broadcast
thrum send &quot;Deploy complete&quot; --to @everyone
thrum send &quot;Deploy complete&quot; --everyone</code></pre>
<h3>Creating and Managing Groups</h3>
<pre><code># Create a group with a description
thrum group create reviewers --description &quot;Code review team&quot;

# Add individual agents
thrum group add reviewers @alice
thrum group add reviewers @bob

# Add all agents with a specific role
thrum group add reviewers --role reviewer

# Remove a member
thrum group remove reviewers @bob

# List all groups
thrum group list

# Show group details
thrum group info reviewers</code></pre>
<h3>Member Types</h3>
<p>Groups support two member types:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Syntax</th>
<th>Resolves To</th>
</tr>
</thead>
<tbody><tr>
<td>Agent</td>
<td><code>@alice</code></td>
<td>A specific agent by name</td>
</tr>
<tr>
<td>Role</td>
<td><code>--role reviewer</code></td>
<td>All agents registered with that role</td>
</tr>
</tbody></table>
<h3>Sending to Groups</h3>
<p>Use <code>--to @groupname</code> just like sending to an individual agent:</p>
<pre><code># Send to the review team
thrum send &quot;PR #42 ready for review&quot; --to @reviewers

# Send to all developers
thrum send &quot;Code freeze starts now&quot; --to @all-devs</code></pre>
<p>The daemon resolves group membership at <strong>read time</strong> using a SQL query. This
means agents added to a group after a message was sent still receive it.</p>
<h3>Expanding Group Membership</h3>
<p>Use <code>--expand</code> to see which individual agents a group resolves to:</p>
<pre><code>thrum group members reviewers --expand --json</code></pre>
<p>Output:</p>
<pre><code>{
  &quot;members&quot;: [
    { &quot;type&quot;: &quot;agent&quot;, &quot;value&quot;: &quot;alice&quot; },
    { &quot;type&quot;: &quot;role&quot;, &quot;value&quot;: &quot;reviewer&quot; }
  ],
  &quot;expanded&quot;: [&quot;alice&quot;, &quot;bob&quot;, &quot;carol&quot;]
}</code></pre>
<h3>MCP Group Tools</h3>
<p>When using the MCP server (<code>thrum mcp serve</code>), groups are managed via native MCP
tools:</p>
<table>
<thead>
<tr>
<th>MCP Tool</th>
<th>Parameters</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>create_group</code></td>
<td><code>name</code>, <code>description?</code></td>
<td>Create a named group</td>
</tr>
<tr>
<td><code>delete_group</code></td>
<td><code>name</code></td>
<td>Delete a group</td>
</tr>
<tr>
<td><code>add_group_member</code></td>
<td><code>group</code>, <code>member_type</code>, <code>member_value</code></td>
<td>Add member to group</td>
</tr>
<tr>
<td><code>remove_group_member</code></td>
<td><code>group</code>, <code>member_type</code>, <code>member_value</code></td>
<td>Remove member from group</td>
</tr>
<tr>
<td><code>list_groups</code></td>
<td>--</td>
<td>List all groups</td>
</tr>
<tr>
<td><code>get_group</code></td>
<td><code>name</code>, <code>expand?</code></td>
<td>Get details with optional expansion</td>
</tr>
</tbody></table>
<p>Example MCP usage:</p>
<pre><code>mcp__thrum__create_group(name=&quot;backend&quot;, description=&quot;Backend team&quot;)
mcp__thrum__add_group_member(group=&quot;backend&quot;, member_type=&quot;role&quot;, member_value=&quot;implementer&quot;)
mcp__thrum__send_message(to=&quot;@backend&quot;, content=&quot;API changes merged&quot;)</code></pre>
<hr>
<h2>Runtime Presets</h2>
<p>Thrum supports multiple AI coding platforms through a runtime preset system.
Each preset knows how to configure MCP servers, instruction files, and hooks for
a specific platform.</p>
<h3>Built-in Presets</h3>
<table>
<thead>
<tr>
<th>Preset</th>
<th>Display Name</th>
<th>MCP</th>
<th>Hooks</th>
<th>Instructions File</th>
</tr>
</thead>
<tbody><tr>
<td><code>claude</code></td>
<td>Claude Code</td>
<td>Yes</td>
<td>Yes</td>
<td><code>CLAUDE.md</code></td>
</tr>
<tr>
<td><code>codex</code></td>
<td>OpenAI Codex</td>
<td>Yes</td>
<td>No</td>
<td><code>AGENTS.md</code></td>
</tr>
<tr>
<td><code>cursor</code></td>
<td>Cursor</td>
<td>Yes</td>
<td>No</td>
<td><code>.cursorrules</code></td>
</tr>
<tr>
<td><code>gemini</code></td>
<td>Google Gemini</td>
<td>Yes</td>
<td>No</td>
<td><code>~/.gemini/instructions.md</code></td>
</tr>
<tr>
<td><code>auggie</code></td>
<td>Augment</td>
<td>No</td>
<td>No</td>
<td><code>CLAUDE.md</code></td>
</tr>
<tr>
<td><code>amp</code></td>
<td>Sourcegraph Amp</td>
<td>No</td>
<td>No</td>
<td><code>CLAUDE.md</code></td>
</tr>
</tbody></table>
<h3>CLI Commands</h3>
<pre><code># List all available presets (built-in + user-defined)
thrum runtime list

# Show details for a specific preset
thrum runtime show claude

# Set a default runtime for this machine
thrum runtime set-default claude</code></pre>
<h3>Auto-Detection</h3>
<p>Thrum can auto-detect which AI platform is running by checking for file markers
and environment variables:</p>
<p><strong>File markers:</strong></p>
<table>
<thead>
<tr>
<th>Marker File</th>
<th>Detected Runtime</th>
</tr>
</thead>
<tbody><tr>
<td><code>.claude/settings.json</code></td>
<td><code>claude</code></td>
</tr>
<tr>
<td><code>.codex</code></td>
<td><code>codex</code></td>
</tr>
<tr>
<td><code>.cursorrules</code></td>
<td><code>cursor</code></td>
</tr>
<tr>
<td><code>.augment</code></td>
<td><code>auggie</code></td>
</tr>
</tbody></table>
<p><strong>Environment variables:</strong></p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Detected Runtime</th>
</tr>
</thead>
<tbody><tr>
<td><code>CLAUDE_SESSION_ID</code></td>
<td><code>claude</code></td>
</tr>
<tr>
<td><code>CURSOR_SESSION</code></td>
<td><code>cursor</code></td>
</tr>
<tr>
<td><code>GEMINI_CLI</code></td>
<td><code>gemini</code></td>
</tr>
<tr>
<td><code>AUGMENT_AGENT</code></td>
<td><code>auggie</code></td>
</tr>
</tbody></table>
<p>If no runtime is detected, Thrum falls back to CLI-only mode (no MCP
configuration generated).</p>
<h3>Integration with init and quickstart</h3>
<p>Use <code>--runtime</code> to specify or auto-detect the platform:</p>
<pre><code># Auto-detect and generate config
thrum init --runtime auto

# Explicit runtime selection
thrum init --runtime claude
# Generates .claude/settings.json with thrum MCP server config

thrum init --runtime cursor
# Generates .cursorrules with thrum instructions

# Quickstart with runtime detection
thrum quickstart --name furiosa --role implementer --module auth \
  --runtime claude --intent &quot;JWT auth&quot;</code></pre>
<h3>Dry-Run Mode</h3>
<p>Preview what configuration files would be generated without connecting to the
daemon or writing files:</p>
<pre><code>thrum quickstart --runtime cursor --dry-run
# Shows .cursorrules content and MCP config that would be created</code></pre>
<h3>Custom Runtimes</h3>
<p>Add custom runtime presets via <code>~/.config/thrum/runtimes.json</code> (XDG-aware):</p>
<pre><code>{
  &quot;default_runtime&quot;: &quot;claude&quot;,
  &quot;custom_runtimes&quot;: {
    &quot;my-agent&quot;: {
      &quot;name&quot;: &quot;my-agent&quot;,
      &quot;display_name&quot;: &quot;My Custom Agent&quot;,
      &quot;command&quot;: &quot;my-agent&quot;,
      &quot;mcp_supported&quot;: true,
      &quot;hooks_supported&quot;: false,
      &quot;instructions_file&quot;: &quot;AGENTS.md&quot;,
      &quot;mcp_config_path&quot;: &quot;~/.my-agent/settings.json&quot;,
      &quot;setup_notes&quot;: &quot;Custom setup instructions&quot;
    }
  }
}</code></pre>
<p>Custom runtimes appear alongside built-in presets in <code>thrum runtime list</code>.</p>
<hr>
<h2>Context Prime</h2>
<p>After compaction or starting a new session, you want to quickly answer: what was
I working on? Context prime gathers all agent state into a single output so an
agent can pick up where it left off.</p>
<h3>Usage</h3>
<pre><code># Human-readable summary
thrum context prime

# Structured JSON for LLM consumption
thrum context prime --json</code></pre>
<h3>What It Gathers</h3>
<p>Context prime collects information from multiple sources in one call:</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>Source</th>
<th>Content</th>
</tr>
</thead>
<tbody><tr>
<td>Identity</td>
<td>Identity file</td>
<td>Agent ID, role, module, display name</td>
</tr>
<tr>
<td>Session</td>
<td>Daemon RPC</td>
<td>Session ID, intent, task, uptime</td>
</tr>
<tr>
<td>Agents</td>
<td>Daemon RPC</td>
<td>List of registered agents with status and roles</td>
</tr>
<tr>
<td>Inbox</td>
<td>Daemon RPC</td>
<td>Unread message count, total messages</td>
</tr>
<tr>
<td>Git</td>
<td>Local git state</td>
<td>Current branch, recent commits, changed files</td>
</tr>
<tr>
<td>Context</td>
<td>Context file</td>
<td>Saved context from previous session (if exists)</td>
</tr>
</tbody></table>
<h3>Example Output</h3>
<pre><code>=== Context Prime for furiosa ===

Identity: furiosa (implementer @ auth)
Session:  ses_01HXF2A9... (active 2h15m)
Intent:   JWT authentication implementation

Agents Online:
  planner    coordinator @ main    (active 5m ago)
  reviewer   reviewer @ all        (active 12m ago)

Inbox: 3 unread / 12 total

Git:
  Branch: feature/auth
  Ahead:  3 commits
  Files:  src/auth.go, src/auth_test.go (modified)

Saved Context:
  # Next Steps
  - Finish JWT implementation
  - Add rate limiting tests</code></pre>
<h3>Graceful Degradation</h3>
<p>Context prime handles missing components gracefully:</p>
<ul>
<li><strong>No daemon running</strong> -- skips session, agents, and inbox sections</li>
<li><strong>No active session</strong> -- shows identity only</li>
<li><strong>No git repo</strong> -- skips git section</li>
<li><strong>No saved context</strong> -- skips context section</li>
<li><strong>No remote</strong> -- skips upstream comparison</li>
</ul>
<p>This makes it safe to run at any point, even before the daemon is started.</p>
<h3>Use Cases</h3>
<ul>
<li><strong>Session startup</strong> -- run at the beginning of every session to understand
current state</li>
<li><strong>After compaction</strong> -- recover full context when the LLM&#39;s context window
resets</li>
<li><strong>Handoff between agents</strong> -- incoming agent runs context prime to understand
the project state</li>
<li><strong>Debugging</strong> -- quickly see what the agent knows and what it&#39;s working on</li>
</ul>
<hr>
<h2>Multi-Worktree Coordination</h2>
<p>Multiple agents can operate across git worktrees while sharing a single daemon
and message store.</p>
<h3>How It Works</h3>
<pre><code>┌──────────────────────────────────────────────────────────────┐
│                     Main Worktree                             │
│  /path/to/repo                                                │
│  ├── .thrum/                    ← Daemon socket, SQLite, IDs  │
│  ├── .git/thrum-sync/a-sync/   ← JSONL event log             │
│  └── Daemon process (shared)                                  │
├──────────────────────────────────────────────────────────────┤
│                     Feature Worktrees                         │
│  ~/.workspaces/repo/auth/                                     │
│  ├── .thrum/redirect → /path/to/repo/.thrum/                 │
│  └── Uses same daemon, same messages                          │
│                                                               │
│  ~/.workspaces/repo/sync/                                     │
│  ├── .thrum/redirect → /path/to/repo/.thrum/                 │
│  └── Uses same daemon, same messages                          │
└──────────────────────────────────────────────────────────────┘</code></pre>
<ul>
<li><strong>One daemon per repository</strong> -- not per worktree</li>
<li>Feature worktrees use <code>.thrum/redirect</code> to point to the main <code>.thrum/</code>
directory</li>
<li>All agents connect via the same Unix socket</li>
<li>Each agent has its own identity file and message shard</li>
</ul>
<h3>Setting Up Feature Worktrees</h3>
<pre><code># Create the worktree
git worktree add ~/.workspaces/repo/auth -b feature/auth

# Set up thrum redirect (shares daemon with main repo)
thrum setup --main-repo /path/to/repo

# Or use the setup script
scripts/setup-worktree-thrum.sh ~/.workspaces/repo/auth</code></pre>
<h3>Running Multiple Agents</h3>
<p>Each agent in a worktree gets its own identity:</p>
<pre><code># Main worktree: coordinator (name must differ from role)
cd /path/to/repo
thrum quickstart --name coord_main --role coordinator --module main

# Auth worktree: implementer
cd ~/.workspaces/repo/auth
export THRUM_NAME=furiosa
thrum quickstart --name furiosa --role implementer --module auth

# Sync worktree: another implementer
cd ~/.workspaces/repo/sync
export THRUM_NAME=nux
thrum quickstart --name nux --role implementer --module sync</code></pre>
<p>All three agents share the same daemon and can message each other:</p>
<pre><code># furiosa sends to coordinator
thrum send &quot;Auth module complete, tests passing&quot; --to @coordinator

# coordinator sends to the whole team
thrum send &quot;Both features ready, starting integration&quot; --to @everyone</code></pre>
<h3>Multiple Agents in the Same Worktree</h3>
<p>Multiple agents can coexist in a single worktree. Each gets a separate identity
file in <code>.thrum/identities/</code>:</p>
<pre><code>.thrum/identities/
├── furiosa.json     # implementation agent
├── reviewer.json    # review agent</code></pre>
<p>Use <code>THRUM_NAME</code> to select which identity to use:</p>
<pre><code>THRUM_NAME=furiosa thrum send &quot;Implementation complete&quot;
THRUM_NAME=reviewer thrum send &quot;LGTM, approved&quot;</code></pre>
<hr>
<h2>Coordination Tools</h2>
<h3>who-has: File Ownership</h3>
<p>Check which agents are currently working on a file:</p>
<pre><code>thrum who-has auth.go
# Output: @furiosa is editing auth.go (feature/auth, 3 unmerged commits)

thrum who-has internal/cli/agent.go
# Output: No agent is currently editing internal/cli/agent.go</code></pre>
<p>This queries agent work contexts (tracked via <code>thrum agent list --context</code>) to
prevent two agents from editing the same file simultaneously.</p>
<h3>ping: Agent Presence</h3>
<p>Check if an agent is online and what they are working on:</p>
<pre><code>thrum ping @reviewer
# Output:
#   reviewer: active (last seen 2m ago)
#   Intent: Reviewing PR #42

thrum ping @furiosa
# Output:
#   furiosa: offline (last seen 3h ago)</code></pre>
<p>Agents are considered <code>active</code> if seen within the last 2 minutes, <code>offline</code>
otherwise.</p>
<h3>wait: Efficient Message Blocking</h3>
<p>Block until a matching message arrives or a timeout expires. This is the
foundation of the message-listener pattern for async agent coordination.</p>
<p><code>thrum wait</code> always filters by the calling agent&#39;s identity — it only returns
messages directed to this agent (by name or role group). There is no <code>--all</code>
flag; use subscriptions if you need a firehose.</p>
<pre><code># Wait for any message addressed to this agent
thrum wait --timeout 5m

# Wait for messages since a time offset (skip old messages)
thrum wait --after -30s --timeout 5m --json

# Wait for mentions of your role
thrum wait --mention @reviewer --timeout 5m</code></pre>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Format</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>--timeout</code></td>
<td>Duration (e.g., <code>5m</code>)</td>
<td>Max wait time (default: <code>30s</code>)</td>
</tr>
<tr>
<td><code>--mention</code></td>
<td><code>@role</code></td>
<td>Wait for mentions of a role</td>
</tr>
<tr>
<td><code>--after</code></td>
<td>Relative time (e.g., <code>-30s</code>)</td>
<td>Only messages after this offset</td>
</tr>
<tr>
<td><code>--json</code></td>
<td>Boolean</td>
<td>Output messages as JSON</td>
</tr>
</tbody></table>
<p><strong>Exit codes:</strong></p>
<ul>
<li><code>0</code> -- message received</li>
<li><code>1</code> -- timeout (no messages)</li>
<li><code>2</code> -- error</li>
</ul>
<hr>
<h2>Complete Workflows</h2>
<h3>Workflow 1: Setting Up a Review Team</h3>
<pre><code># 1. Create a review team group
thrum group create reviewers --description &quot;Code review team&quot;
thrum group add reviewers --role reviewer
thrum group add reviewers @alice

# 2. Implementer finishes work and notifies the team
thrum send &quot;PR #42 ready for review: JWT auth implementation&quot; \
  --to @reviewers --ref pr:42

# 3. Reviewers check their inbox
thrum inbox --mentions

# 4. Reviewer responds
thrum reply msg_01HXE... &quot;Reviewed. LGTM with minor comments on error handling.&quot;</code></pre>
<h3>Workflow 2: Cross-Platform Agent Setup</h3>
<pre><code># Claude Code agent
thrum init --runtime claude
thrum quickstart --name claude_agent --role implementer --module auth \
  --runtime claude --intent &quot;Implementing auth&quot;
# Generates .claude/settings.json with MCP config

# Cursor agent (same repo, different terminal)
thrum init --runtime cursor
thrum quickstart --name cursor_agent --role reviewer --module auth \
  --runtime cursor --intent &quot;Reviewing auth&quot;
# Generates .cursorrules with thrum instructions

# Both agents share the same daemon and can message each other</code></pre>
<h3>Workflow 3: Session Recovery After Compaction</h3>
<pre><code># Agent&#39;s context window was compacted -- recover state
thrum context prime
# Shows: identity, session, team, inbox, git state, saved context

# Check for urgent messages
thrum inbox --unread

# Resume work based on recovered context
thrum agent set-intent &quot;Resuming JWT implementation after compaction&quot;</code></pre>
<h3>Workflow 4: Multi-Worktree Team Coordination</h3>
<pre><code># === Coordinator (main worktree) ===
thrum quickstart --name coord_main --role coordinator --module main
thrum group create backend --description &quot;Backend team&quot;
thrum group add backend @furiosa
thrum group add backend @nux

# Assign work
thrum send &quot;furiosa: implement auth (feature/auth worktree)&quot; --to @furiosa
thrum send &quot;nux: implement sync (feature/sync worktree)&quot; --to @nux

# Check team status
thrum agent list --context
# AGENT        ROLE          MODULE  BRANCH         FILES
# coord_main   coordinator   main    main           -
# furiosa      implementer   auth    feature/auth   src/auth.go
# nux          implementer   sync    feature/sync   internal/sync/loop.go

# Send update to the whole backend team
thrum send &quot;Both features shipping in v0.4&quot; --to @backend

# === Implementer (auth worktree) ===
cd ~/.workspaces/repo/auth
export THRUM_NAME=furiosa
thrum inbox --unread
thrum send &quot;Auth complete, 15 tests passing&quot; --to @coordinator</code></pre>
<hr>
<h2>Best Practices</h2>
<h3>Group Organization</h3>
<ul>
<li><strong>Start simple</strong> -- create groups as coordination needs emerge, not upfront</li>
<li><strong>Use role-based membership</strong> when possible (<code>--role reviewer</code>) so new agents
with that role are automatically included</li>
<li><strong>Use <code>@everyone</code> sparingly</strong> -- prefer targeted groups to reduce noise</li>
</ul>
<h3>Runtime Configuration</h3>
<ul>
<li><strong>Let Thrum auto-detect</strong> when possible (<code>--runtime auto</code> or omit the flag)</li>
<li><strong>Set a default runtime</strong> on your machine if you always use the same platform:
<code>thrum runtime set-default claude</code></li>
<li><strong>Use <code>--dry-run</code></strong> to preview generated configs before committing to them</li>
</ul>
<h3>Context Recovery</h3>
<ul>
<li><strong>Run <code>thrum context prime</code></strong> at the start of every session</li>
<li><strong>Save context</strong> at the end of every session:
<code>echo &quot;# Next steps\n- ...&quot; | thrum context save</code></li>
<li><strong>After compaction</strong>, context prime provides everything needed to resume work</li>
</ul>
<h3>Coordination</h3>
<ul>
<li><strong>Check <code>who-has</code></strong> before editing files another agent might be working on</li>
<li><strong>Use <code>thrum wait</code></strong> instead of polling loops for efficient message delivery</li>
<li><strong>Set clear intents</strong> so other agents can see what you are working on via
<code>thrum agent list --context</code></li>
</ul>
<h2>See Also</h2>
<ul>
<li><a href="tailscale-sync.html">Tailscale Sync</a> -- Cross-machine sync via Tailscale with
Ed25519 signing and peer discovery</li>
<li><a href="agent-coordination.html">Agent Coordination</a> -- Workflow patterns and Beads
integration</li>
<li><a href="identity.html">Identity System</a> -- Agent naming, registration, and conflict
resolution</li>
<li><a href="messaging.html">Messaging System</a> -- Message structure, threads, scopes, and
refs</li>
<li><a href="mcp-server.html">MCP Server</a> -- MCP tools for AI agent integration</li>
<li><a href="context.html">Context Management</a> -- Per-agent context storage and preambles</li>
<li><a href="cli.html">CLI Reference</a> -- Complete command documentation</li>
</ul>
<pre><code></code></pre>

</main>
<script>if(location.search.indexOf('nospa')===-1){location.replace('../docs.html#multi-agent.html')}</script>
</body>
</html>