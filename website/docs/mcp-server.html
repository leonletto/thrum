<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>mcp-server — Thrum</title>
  <meta name="description" content="">
  <!-- Open Graph -->
  <meta property="og:type" content="article">
  <meta property="og:title" content="mcp-server — Thrum">
  <meta property="og:description" content="">
  <meta property="og:url" content="https://leonletto.github.io/thrum/docs/mcp-server.html">
  <meta property="og:site_name" content="Thrum">
  <meta property="og:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="mcp-server — Thrum">
  <meta name="twitter:description" content="">
  <meta name="twitter:image" content="https://leonletto.github.io/thrum/img/social-card.png">
  <!-- Canonical: SPA is the primary URL -->
  <link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#mcp-server.html">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x26A1;</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/theme.css">
  <link rel="stylesheet" href="../css/docs.css">
  <script>
    (function(){var t=localStorage.getItem('thrum-theme');if(t){document.documentElement.setAttribute('data-theme',t)}else if(window.matchMedia&&window.matchMedia('(prefers-color-scheme:light)').matches){document.documentElement.setAttribute('data-theme','light')}else{document.documentElement.setAttribute('data-theme','dark')}})();
  </script>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <nav class="header-nav">
        <a href="../index.html" class="logo">
          <span class="logo-glyph">&gt;_</span>
          <span class="logo-text">thrum</span>
        </a>
        <div class="nav-links">
          <a href="../index.html" class="nav-link">Home</a>
          <a href="../docs.html" class="nav-link nav-link-active">Docs</a>
          <a href="../about.html" class="nav-link">About</a>
          <a href="https://github.com/leonletto/thrum" class="nav-link nav-link-external" target="_blank" rel="noopener">GitHub</a>
        </div>
      </nav>
    </div>
  </header>
  <main class="docs-content" style="max-width:48rem;margin:2rem auto;padding:0 1.5rem">
    <div class="docs-content-inner">
<h1>MCP Server</h1>
<blockquote>
<p><strong>See also:</strong> <a href="daemon.html">Daemon Architecture</a> for the underlying daemon the<br>MCP server connects to, <a href="identity.html">Identity</a> for agent identity resolution.</p>
</blockquote>
<h2>Overview</h2>
<p>The MCP (Model Context Protocol) server enables Claude Code agents to send and<br>receive messages using native MCP tools instead of shelling out to CLI commands.<br>It runs as a long-lived child process (<code>thrum mcp serve</code>) communicating over<br>stdio with JSON-RPC, and connects to the Thrum daemon via Unix socket for<br>message operations and via WebSocket for real-time push notifications.</p>
<p>The primary motivation is eliminating polling overhead. Without MCP, agents must<br>periodically call <code>thrum inbox</code> (burning tokens and context). With MCP, a cheap<br>background sub-agent blocks on <code>wait_for_message</code> and wakes the main agent<br>instantly when a message arrives.</p>
<h2>Architecture</h2>
<pre><code>Claude Code (Opus/Sonnet)
  |
  +-- long-lived child: thrum mcp serve (stdio JSON-RPC)
  |     |
  |     +-- Daemon Client (Unix socket, per-call)
  |     |   +-- message.send     -&gt; send_message tool
  |     |   +-- message.list     -&gt; check_messages tool
  |     |   +-- message.markRead -&gt; check_messages tool (auto-mark consumed)
  |     |   +-- agent.list       -&gt; list_agents tool
  |     |   +-- message.send x N -&gt; broadcast_message tool
  |     |
  |     +-- WebSocket Client (ws://localhost:{port}/ws)
  |     |   +-- user.identify + user.register -&gt; session setup
  |     |   +-- subscribe (mention_role=@{role}) -&gt; notification stream
  |     |   +-- notification.message -&gt; unblocks wait_for_message
  |     |
  |     +-- Internal Notification Queue (max 1000, FIFO, drops oldest)
  |     |
  |     +-- Identity: .thrum/identities/{name}.json
  |
  +-- background sub-agent: message-listener (Haiku)
        +-- calls wait_for_message(timeout=300) -&gt; blocks until message or timeout</code></pre>
<h3>Package Structure</h3>
<pre><code>internal/mcp/
  server.go    -- NewServer(), tool registration, Run(), InitWaiter()
  tools.go     -- send_message, check_messages, list_agents, broadcast_message handlers
  waiter.go    -- WebSocket client, notification routing, wait_for_message handler
  types.go     -- MCP-specific input/output structs

cmd/thrum/mcp.go  -- thrum mcp serve cobra command</code></pre>
<h3>Startup Sequence</h3>
<ol>
<li>Resolve repo path (respects <code>--repo</code> flag, defaults to <code>.</code>)</li>
<li>If <code>--agent-id</code> is provided, set <code>THRUM_NAME</code> env var before config load</li>
<li>Verify daemon is running (connect to Unix socket, call <code>health</code> RPC)</li>
<li>Load agent identity from <code>.thrum/identities/{name}.json</code> via<br><code>config.LoadWithPath</code></li>
<li>Resolve daemon socket path (follows <code>.thrum/redirect</code> in feature worktrees)</li>
<li>Generate composite agent ID via<br><code>identity.GenerateAgentID(repoID, role, module, name)</code></li>
<li>Create MCP server with the official Go SDK<br>(<code>github.com/modelcontextprotocol/go-sdk/mcp</code>)</li>
<li>Register all 5 tool handlers</li>
<li>Initialize WebSocket waiter (best-effort -- reads port from<br><code>.thrum/var/ws.port</code>)<ul>
<li>Connect to <code>ws://localhost:{port}/ws</code></li>
<li>Send <code>user.identify</code> to get git username</li>
<li>Send <code>user.register</code> with the username</li>
<li>Send <code>subscribe</code> with <code>mention_role</code> for this agent&#39;s role</li>
<li>Start background <code>readLoop</code> goroutine for incoming notifications</li>
</ul>
</li>
<li>Start MCP stdio server (blocks until client disconnects or context<br>cancelled)</li>
</ol>
<h3>Shutdown</h3>
<p>When Claude Code terminates the process (closes stdin) or a signal is received<br>(SIGINT/SIGTERM):</p>
<ul>
<li>Context is cancelled</li>
<li>Waiter closes WebSocket connection (daemon auto-unregisters)</li>
<li>Waiter&#39;s <code>readLoop</code> exits, unblocking any active <code>wait_for_message</code> call</li>
<li>Unix socket connections are closed (per-call, so nothing to clean up)</li>
<li>Process exits</li>
</ul>
<h3>Key Design Decisions</h3>
<ul>
<li><strong>Per-call <code>cli.Client</code> creation</strong>: <code>cli.Client</code> is not concurrent-safe. Each<br>tool handler creates a fresh Unix socket connection. This is cheap (local<br>socket) and avoids concurrency issues.</li>
<li><strong>Atomic WebSocket request IDs</strong>: The waiter uses <code>atomic.Int64</code> for<br>incrementing JSON-RPC request IDs, ensuring uniqueness across concurrent<br>calls.</li>
<li><strong>Single-waiter enforcement</strong>: Only one <code>wait_for_message</code> can be active at a<br>time per server instance. A second call returns an error. Enforced with a<br>mutex.</li>
<li><strong>Best-effort WebSocket</strong>: If the WebSocket connection fails at startup, the<br>MCP server still operates -- only <code>wait_for_message</code> returns errors. The other<br>4 tools work via Unix socket RPC.</li>
</ul>
<h2>Usage</h2>
<h3>Command</h3>
<pre><code class="language-bash hljs">thrum mcp serve [--agent-id NAME]</code></pre>
<p><strong>Prerequisites:</strong></p>
<ul>
<li>Thrum daemon must be running (<code>thrum daemon start</code>)</li>
<li>Agent must be registered<br>(<code>thrum quickstart --name NAME --role ROLE --module MODULE</code>)</li>
</ul>
<p><strong>Flags:</strong></p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>--agent-id</code></td>
<td>(from identity file)</td>
<td>Override agent name; selects <code>.thrum/identities/{name}.json</code></td>
</tr>
<tr>
<td><code>--repo</code></td>
<td><code>.</code></td>
<td>Repository path</td>
</tr>
</tbody></table>
<h3>Claude Code Configuration</h3>
<p>Add to <code>.claude/settings.json</code> (project or user level):</p>
<pre><code class="language-json hljs"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;mcpServers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;thrum&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;stdio&quot;</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;thrum&quot;</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;mcp&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;serve&quot;</span><span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span></code></pre>
<p>Once configured, Claude Code starts <code>thrum mcp serve</code> as a child process and<br>exposes its tools as <code>mcp__thrum__&lt;tool_name&gt;</code>.</p>
<h2>API Reference</h2>
<h3>send_message</h3>
<p>Send a message to another agent, role, or group.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>to</code></td>
<td>string</td>
<td>yes</td>
<td>Recipient: <code>@role</code>, agent name, <code>@groupname</code>, or composite <code>agent:role:hash</code></td>
</tr>
<tr>
<td><code>content</code></td>
<td>string</td>
<td>yes</td>
<td>Message text (markdown)</td>
</tr>
<tr>
<td><code>priority</code></td>
<td>string</td>
<td>no</td>
<td><code>critical</code>, <code>high</code>, <code>normal</code> (default), or <code>low</code></td>
</tr>
<tr>
<td><code>metadata</code></td>
<td>object</td>
<td>no</td>
<td>Key-value metadata (passed as structured data)</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>delivered</code></td>
</tr>
<tr>
<td><code>message_id</code></td>
<td>string</td>
<td>ID of the sent message</td>
</tr>
<tr>
<td><code>recipient_status</code></td>
<td>string</td>
<td><code>unknown</code> (recipient lookup not implemented)</td>
</tr>
</tbody></table>
<p><strong>Addressing:</strong> The <code>to</code> field is parsed to extract a mention role:</p>
<ul>
<li><code>@ops</code> becomes mention for role <code>ops</code></li>
<li><code>agent:ops:abc123</code> extracts role <code>ops</code></li>
<li><code>ops</code> is used as-is</li>
</ul>
<p><strong>Daemon RPC:</strong> <code>message.send</code></p>
<h3>check_messages</h3>
<p>Poll for unread messages mentioning this agent. Messages are automatically<br>marked as read after retrieval.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>limit</code></td>
<td>integer</td>
<td>no</td>
<td>Max messages to return (default 50)</td>
</tr>
</tbody></table>
<p>Agent identity is resolved at server startup; the client does not pass an agent<br>ID.</p>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>messages</code> or <code>empty</code></td>
</tr>
<tr>
<td><code>messages</code></td>
<td>array</td>
<td>List of <code>MessageInfo</code> objects</td>
</tr>
<tr>
<td><code>remaining</code></td>
<td>integer</td>
<td>Count of remaining unread messages (clamped to &gt;= 0)</td>
</tr>
</tbody></table>
<p><strong>MessageInfo:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>message_id</code></td>
<td>string</td>
<td>Message identifier</td>
</tr>
<tr>
<td><code>from</code></td>
<td>string</td>
<td>Sender agent ID</td>
</tr>
<tr>
<td><code>content</code></td>
<td>string</td>
<td>Message content</td>
</tr>
<tr>
<td><code>priority</code></td>
<td>string</td>
<td>Message priority</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>string</td>
<td>Creation timestamp</td>
</tr>
</tbody></table>
<p><strong>Behavior:</strong></p>
<ol>
<li>Lists unread messages mentioning this agent&#39;s role via <code>message.list</code> RPC</li>
<li>Marks all returned messages as read via <code>message.markRead</code> RPC (best-effort)</li>
<li>Returns consumed messages (they will not appear on the next <code>check_messages</code><br>call)</li>
</ol>
<p><strong>Daemon RPC:</strong> <code>message.list</code> + <code>message.markRead</code></p>
<h3>wait_for_message</h3>
<p>Block until a message arrives or timeout expires. Designed for background<br>listener sub-agents running on Haiku.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>timeout</code></td>
<td>integer</td>
<td>no</td>
<td>Max seconds to wait (default 300, max 600)</td>
</tr>
<tr>
<td><code>priority_filter</code></td>
<td>string</td>
<td>no</td>
<td><code>all</code> (default), <code>critical</code>, <code>high_and_above</code>, or <code>normal_and_above</code></td>
</tr>
</tbody></table>
<p><strong>Note:</strong> <code>priority_filter</code> is accepted but not yet implemented. All messages<br>pass through regardless of filter value.</p>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>message_received</code> or <code>timeout</code></td>
</tr>
<tr>
<td><code>message</code></td>
<td>MessageInfo</td>
<td>The received message (null on timeout)</td>
</tr>
<tr>
<td><code>waited_seconds</code></td>
<td>integer</td>
<td>How long the wait lasted</td>
</tr>
</tbody></table>
<p><strong>Behavior:</strong></p>
<ol>
<li>Check the internal notification queue (messages that arrived while no waiter<br>was active)</li>
<li>If a queued message exists, pop it and return immediately</li>
<li>If queue is empty, block on a channel with the specified timeout</li>
<li>When a WebSocket <code>notification.message</code> arrives, the <code>readLoop</code> pushes it to<br>the queue and closes the waiter channel</li>
<li>Fetch the full message via <code>message.get</code> RPC</li>
<li>Mark as read via <code>message.markRead</code> RPC (best-effort)</li>
<li>Return the message</li>
</ol>
<p><strong>Concurrency:</strong> Only one <code>wait_for_message</code> can be active at a time. A second<br>concurrent call returns an error.</p>
<p><strong>Requires:</strong> WebSocket waiter initialized at startup. If the waiter failed to<br>connect, this tool returns an error.</p>
<p><strong>Daemon RPC:</strong> WebSocket notifications + <code>message.get</code> + <code>message.markRead</code></p>
<h3>list_agents</h3>
<p>List all registered agents and their status.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>include_offline</code></td>
<td>boolean</td>
<td>no</td>
<td>Include inactive agents (default <code>true</code>; uses pointer semantics)</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>agents</code></td>
<td>array</td>
<td>List of <code>AgentInfo</code> objects</td>
</tr>
<tr>
<td><code>count</code></td>
<td>integer</td>
<td>Number of agents returned</td>
</tr>
</tbody></table>
<p><strong>AgentInfo:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>string</td>
<td>Agent display name</td>
</tr>
<tr>
<td><code>role</code></td>
<td>string</td>
<td>Agent role</td>
</tr>
<tr>
<td><code>module</code></td>
<td>string</td>
<td>Agent module</td>
</tr>
<tr>
<td><code>status</code></td>
<td>string</td>
<td><code>active</code> or <code>offline</code></td>
</tr>
<tr>
<td><code>last_seen_at</code></td>
<td>string</td>
<td>Last heartbeat timestamp</td>
</tr>
</tbody></table>
<p><strong>Status derivation:</strong> Based on <code>last_seen_at</code> relative to current time:</p>
<ul>
<li>Less than 2 minutes ago: <code>active</code></li>
<li>2+ minutes ago or missing: <code>offline</code></li>
</ul>
<p><strong>Daemon RPC:</strong> <code>agent.list</code></p>
<h3>broadcast_message</h3>
<p>Send a message to all agents via the <code>@everyone</code> group, with optional filtering. The sender is automatically excluded. This is a simplified wrapper around sending to <code>@everyone</code>.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>content</code></td>
<td>string</td>
<td>yes</td>
<td>Message text to broadcast</td>
</tr>
<tr>
<td><code>priority</code></td>
<td>string</td>
<td>no</td>
<td><code>critical</code>, <code>high</code>, <code>normal</code> (default), or <code>low</code></td>
</tr>
<tr>
<td><code>filter</code></td>
<td>object</td>
<td>no</td>
<td>Optional recipient filters</td>
</tr>
</tbody></table>
<p><strong>BroadcastFilter:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>all</code> (default) or <code>active</code> (only agents seen in last 2 min)</td>
</tr>
<tr>
<td><code>exclude</code></td>
<td>array</td>
<td>Agent names or roles to exclude</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>sent</code>, <code>partial</code> (some failures), or <code>no_recipients</code></td>
</tr>
<tr>
<td><code>sent_to</code></td>
<td>array</td>
<td>Roles of agents that received the message</td>
</tr>
<tr>
<td><code>failed_to</code></td>
<td>array</td>
<td>Roles of agents where send failed</td>
</tr>
<tr>
<td><code>total_sent</code></td>
<td>integer</td>
<td>Count of successful sends</td>
</tr>
<tr>
<td><code>message_ids</code></td>
<td>array</td>
<td>IDs of sent messages</td>
</tr>
</tbody></table>
<p><strong>Behavior:</strong></p>
<ol>
<li>Fetch agent list via <code>agent.list</code> RPC</li>
<li>Filter out self (by agent ID, not role -- so other agents with the same role<br>still receive the message)</li>
<li>Apply exclude filter (matches against both role and display name)</li>
<li>Apply status filter (if <code>active</code>, skip agents with <code>offline</code> status)</li>
<li>Send individual messages to each remaining agent via <code>message.send</code> RPC</li>
</ol>
<p><strong>Daemon RPC:</strong> <code>agent.list</code> + <code>message.send</code> (one per recipient)</p>
<h3>create_group</h3>
<p>Create a named group for targeted messaging.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>string</td>
<td>yes</td>
<td>Group name (e.g., <code>reviewers</code>)</td>
</tr>
<tr>
<td><code>description</code></td>
<td>string</td>
<td>no</td>
<td>Human-readable group description</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>created</code></td>
</tr>
<tr>
<td><code>name</code></td>
<td>string</td>
<td>Name of the created group</td>
</tr>
</tbody></table>
<p><strong>Daemon RPC:</strong> <code>group.create</code></p>
<h3>delete_group</h3>
<p>Delete a group by name. The <code>@everyone</code> group is protected and cannot be deleted.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>string</td>
<td>yes</td>
<td>Group name to delete</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>deleted</code></td>
</tr>
<tr>
<td><code>name</code></td>
<td>string</td>
<td>Name of the deleted group</td>
</tr>
</tbody></table>
<p><strong>Daemon RPC:</strong> <code>group.delete</code></p>
<h3>add_group_member</h3>
<p>Add a member (agent or role) to a group.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>group</code></td>
<td>string</td>
<td>yes</td>
<td>Group name to add member to</td>
</tr>
<tr>
<td><code>member_type</code></td>
<td>string</td>
<td>yes</td>
<td><code>agent</code> or <code>role</code></td>
</tr>
<tr>
<td><code>member_id</code></td>
<td>string</td>
<td>yes</td>
<td>Agent name or role name</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>added</code></td>
</tr>
<tr>
<td><code>group</code></td>
<td>string</td>
<td>Group name</td>
</tr>
<tr>
<td><code>member_type</code></td>
<td>string</td>
<td>Type of member added</td>
</tr>
<tr>
<td><code>member_id</code></td>
<td>string</td>
<td>ID of member added</td>
</tr>
</tbody></table>
<p><strong>Daemon RPC:</strong> <code>group.member.add</code></p>
<h3>remove_group_member</h3>
<p>Remove a member from a group.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>group</code></td>
<td>string</td>
<td>yes</td>
<td>Group name to remove member from</td>
</tr>
<tr>
<td><code>member_type</code></td>
<td>string</td>
<td>yes</td>
<td><code>agent</code> or <code>role</code></td>
</tr>
<tr>
<td><code>member_id</code></td>
<td>string</td>
<td>yes</td>
<td>Agent name or role name</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>removed</code></td>
</tr>
<tr>
<td><code>group</code></td>
<td>string</td>
<td>Group name</td>
</tr>
<tr>
<td><code>member_type</code></td>
<td>string</td>
<td>Type of member removed</td>
</tr>
<tr>
<td><code>member_id</code></td>
<td>string</td>
<td>ID of member removed</td>
</tr>
</tbody></table>
<p><strong>Daemon RPC:</strong> <code>group.member.remove</code></p>
<h3>list_groups</h3>
<p>List all groups in the system.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><em>(none)</em></td>
<td></td>
<td></td>
<td>Empty object or omit params</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>groups</code></td>
<td>array</td>
<td>List of <code>GroupInfo</code> objects</td>
</tr>
<tr>
<td><code>groups[].name</code></td>
<td>string</td>
<td>Group name</td>
</tr>
<tr>
<td><code>groups[].description</code></td>
<td>string</td>
<td>Group description (may be empty)</td>
</tr>
<tr>
<td><code>groups[].created_at</code></td>
<td>string</td>
<td>ISO 8601 creation timestamp</td>
</tr>
<tr>
<td><code>groups[].created_by</code></td>
<td>string</td>
<td>Agent ID of creator</td>
</tr>
<tr>
<td><code>groups[].member_count</code></td>
<td>integer</td>
<td>Number of direct members</td>
</tr>
</tbody></table>
<p><strong>Daemon RPC:</strong> <code>group.list</code></p>
<h3>get_group</h3>
<p>Get detailed information about a specific group. Supports expansion to resolve roles to individual agent IDs.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>string</td>
<td>yes</td>
<td>Group name</td>
</tr>
<tr>
<td><code>expand</code></td>
<td>boolean</td>
<td>no</td>
<td>Resolve roles to agent IDs</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>string</td>
<td>Group name</td>
</tr>
<tr>
<td><code>description</code></td>
<td>string</td>
<td>Group description (may be empty)</td>
</tr>
<tr>
<td><code>created_at</code></td>
<td>string</td>
<td>ISO 8601 creation timestamp</td>
</tr>
<tr>
<td><code>created_by</code></td>
<td>string</td>
<td>Agent ID of creator</td>
</tr>
<tr>
<td><code>members</code></td>
<td>array</td>
<td>List of member objects</td>
</tr>
<tr>
<td><code>members[].type</code></td>
<td>string</td>
<td><code>agent</code> or <code>role</code></td>
</tr>
<tr>
<td><code>members[].id</code></td>
<td>string</td>
<td>Agent name or role name</td>
</tr>
<tr>
<td><code>expanded_agents</code></td>
<td>array</td>
<td>(Only if <code>expand=true</code>) List of agent IDs</td>
</tr>
<tr>
<td><code>expanded_agents_count</code></td>
<td>integer</td>
<td>(Only if <code>expand=true</code>) Count of agent IDs</td>
</tr>
</tbody></table>
<p><strong>Daemon RPC:</strong> <code>group.info</code> (without expand) or <code>group.members</code> (with expand)</p>
<h2>Identity Resolution</h2>
<p>The MCP server resolves agent identity once at startup. The client never passes<br>agent IDs in tool calls.</p>
<p><strong>Resolution order:</strong></p>
<ol>
<li><code>--agent-id</code> flag on <code>thrum mcp serve</code> (sets <code>THRUM_NAME</code> env var)</li>
<li><code>THRUM_NAME</code> environment variable</li>
<li>Auto-select single identity file in <code>.thrum/identities/</code></li>
<li>Error if no identity found or multiple identities exist without<br>disambiguation</li>
</ol>
<p><strong>Identity file:</strong> <code>.thrum/identities/{name}.json</code> contains name, role, module,<br>and repo ID. The server generates a composite agent ID (<code>agent:{role}:{hash}</code>)<br>using <code>identity.GenerateAgentID()</code>, consistent with daemon RPC handlers.</p>
<p><strong>Multi-agent worktrees:</strong> When multiple agents operate in the same worktree,<br>each must have a distinct identity file. Use <code>THRUM_NAME</code> env var or<br><code>--agent-id</code> flag to select.</p>
<h2>WebSocket Waiter</h2>
<p>The <code>Waiter</code> struct (<code>internal/mcp/waiter.go</code>) manages the WebSocket connection<br>for real-time message notifications.</p>
<h3>Connection Setup</h3>
<p>On initialization, the waiter:</p>
<ol>
<li>Connects to the daemon WebSocket at <code>ws://localhost:{port}/ws</code></li>
<li>Sends <code>user.identify</code> to get the git username</li>
<li>Sends <code>user.register</code> with that username</li>
<li>Sends <code>subscribe</code> with <code>mention_role</code> set to the agent&#39;s role</li>
<li>Starts a background <code>readLoop</code> goroutine</li>
</ol>
<h3>Notification Flow</h3>
<pre><code>Daemon WebSocket -&gt; readLoop -&gt; queue ([]MessageNotification) -&gt; waiterCh -&gt; WaitForMessage</code></pre>
<p>The <code>readLoop</code> goroutine:</p>
<ul>
<li>Reads WebSocket messages continuously</li>
<li>Filters for <code>notification.message</code> method</li>
<li>Parses the notification into a <code>MessageNotification</code> (message_id, preview,<br>agent_id, timestamp)</li>
<li>Appends to the internal queue (max 1000 items; drops oldest on overflow)</li>
<li>Closes the <code>waiterCh</code> channel to wake any blocked <code>WaitForMessage</code> call</li>
</ul>
<p>On connection loss, <code>readLoop</code> closes <code>waiterCh</code> (if set) before exiting, which<br>unblocks any active waiter with a timeout-like response rather than hanging<br>forever.</p>
<h3>JSON-RPC over WebSocket</h3>
<p>The waiter uses JSON-RPC 2.0 for setup RPCs. Request IDs are atomically<br>incremented (<code>atomic.Int64</code>). During <code>wsRPC</code> calls, incoming notifications are<br>skipped (they have no <code>id</code> field and a non-empty <code>method</code> field).</p>
<h2>Integration</h2>
<h3>Message-Listener Sub-Agent</h3>
<p>The recommended pattern for receiving messages in Claude Code is a background<br>Haiku sub-agent that blocks on <code>wait_for_message</code>. This is defined in<br><code>.claude/agents/message-listener.md</code>.</p>
<p><strong>How it works:</strong></p>
<ol>
<li>The main agent spawns the message-listener as a background <code>Task</code> sub-agent</li>
<li>The listener calls <code>check_messages</code> to drain any backlog</li>
<li>If messages are found, it returns them immediately</li>
<li>If none, it calls <code>wait_for_message(timeout=300)</code> and blocks</li>
<li>When a message arrives or timeout occurs, the listener returns to the main<br>agent</li>
<li>The main agent processes the result and re-arms the listener</li>
</ol>
<p><strong>Return format:</strong></p>
<p>When messages are received:</p>
<pre><code>MESSAGES_RECEIVED
FROM: [sender]
PRIORITY: [priority]
CONTENT: [message content]
TIMESTAMP: [timestamp]</code></pre>
<p>When timeout occurs:</p>
<pre><code>NO_MESSAGES_TIMEOUT</code></pre>
<p><strong>Cost:</strong> Approximately $0.00003 per cycle (Haiku-class model).</p>
<h3>Priority Handling Protocol</h3>
<p>When the main agent receives messages from the listener, it should handle<br>priorities as follows:</p>
<table>
<thead>
<tr>
<th>Priority</th>
<th>Action</th>
</tr>
</thead>
<tbody><tr>
<td><code>critical</code></td>
<td>Stop current work immediately</td>
</tr>
<tr>
<td><code>high</code></td>
<td>Process at next breakpoint</td>
</tr>
<tr>
<td><code>normal</code></td>
<td>Process when current sub-task completes</td>
</tr>
<tr>
<td><code>low</code></td>
<td>Queue, process when convenient</td>
</tr>
</tbody></table>
<h3>Context Management</h3>
<ul>
<li>Compact after 10+ message cycles to prevent context overflow</li>
<li>After 5 consecutive timeouts with no pending work, send status to the<br>coordinator and stop the listener</li>
</ul>
<h3>CLAUDE.md Protocol</h3>
<p>The project <code>CLAUDE.md</code> includes instructions for agents to use MCP tools:</p>
<pre><code>mcp__thrum__send_message(to=&quot;@reviewer&quot;, content=&quot;...&quot;, priority=&quot;normal&quot;)
mcp__thrum__check_messages()
mcp__thrum__list_agents()
mcp__thrum__broadcast_message(content=&quot;...&quot;)</code></pre>
<h2>Development</h2>
<h3>Source Files</h3>
<table>
<thead>
<tr>
<th>File</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><code>internal/mcp/server.go</code></td>
<td>Server struct, NewServer(), Run(), InitWaiter(), tool registration</td>
</tr>
<tr>
<td><code>internal/mcp/tools.go</code></td>
<td>Tool handlers, address parsing, status derivation, priority validation</td>
</tr>
<tr>
<td><code>internal/mcp/waiter.go</code></td>
<td>WebSocket connection, readLoop, WaitForMessage, notification queue</td>
</tr>
<tr>
<td><code>internal/mcp/types.go</code></td>
<td>Input/output structs for all 5 tools</td>
</tr>
<tr>
<td><code>cmd/thrum/mcp.go</code></td>
<td>Cobra command, daemon health check, waiter init, signal handling</td>
</tr>
<tr>
<td><code>.claude/agents/message-listener.md</code></td>
<td>Haiku sub-agent definition</td>
</tr>
</tbody></table>
<h3>Testing</h3>
<pre><code class="language-bash hljs"><span class="hljs-comment"># Unit + sequential integration tests (no daemon needed)</span>
go <span class="hljs-built_in">test</span> ./internal/mcp/...

<span class="hljs-comment"># With verbose output</span>
go <span class="hljs-built_in">test</span> -v ./internal/mcp/...</code></pre>
<p>Test coverage includes:</p>
<ul>
<li>Tool handler input validation</li>
<li>Message queue push/pop semantics</li>
<li>Waiter timeout and cancellation logic</li>
<li>Identity resolution</li>
<li>18 tests passing (unit + sequential integration)</li>
</ul>
<p>WebSocket integration tests (requiring a running daemon WebSocket) are currently<br>deferred.</p>
<h3>Debugging</h3>
<p>The MCP server logs warnings to stderr. Check for:</p>
<ul>
<li><code>Warning: WebSocket waiter not available</code> -- daemon WebSocket port not found<br>or connection failed; <code>wait_for_message</code> will not work but other tools<br>function normally</li>
<li><code>agent name not configured</code> / <code>agent role not configured</code> -- agent identity<br>not registered; run <code>thrum quickstart</code> first</li>
<li><code>Thrum daemon is not running</code> -- start the daemon with <code>thrum daemon start</code></li>
</ul>
<h3>Dependencies</h3>
<ul>
<li><strong>Runtime:</strong> Thrum daemon (<code>thrum daemon start</code>)</li>
<li><strong>Go SDK:</strong> <code>github.com/modelcontextprotocol/go-sdk/mcp</code> (official MCP Go SDK)</li>
<li><strong>WebSocket:</strong> <code>github.com/gorilla/websocket</code></li>
<li><strong>Identity:</strong> Agent registered with <code>.thrum/identities/{name}.json</code></li>
</ul>
<h2>References</h2>
<ul>
<li>Design document: <code>docs/plans/2026-02-06-mcp-server-design.md</code></li>
<li>Daemon architecture: <code>docs/daemon.md</code></li>
<li>RPC API reference: <code>docs/rpc-api.md</code></li>
<li>Identity system: <code>docs/identity.md</code></li>
<li>Agent reference: <code>llms.txt</code></li>
</ul>

    </div>
    <p style="margin-top:2rem"><a href="../docs.html#mcp-server.html">&larr; View in documentation</a></p>
  </main>
  <script>
    // Redirect browsers to the SPA for full navigation experience.
    // Crawlers (which don't execute JS) will index the static content above.
    if (window.location.search.indexOf('nospa') === -1) {
      window.location.replace('../docs.html#mcp-server.html');
    }
  </script>
</body>
</html>