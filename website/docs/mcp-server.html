<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MCP Server — Thrum</title>
<meta name="description" content="Thrum MCP server for native AI agent integration — tools, identity, message handling, and Claude Code setup">
<link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#mcp-server.html">
<style>
body{font-family:system-ui,sans-serif;max-width:48rem;margin:2rem auto;padding:0 1.5rem;line-height:1.6;color:#222}
pre{background:#f5f5f5;padding:1rem;overflow-x:auto;border-radius:4px}
code{font-family:ui-monospace,monospace;font-size:0.9em}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #ddd;padding:0.4rem 0.6rem;text-align:left}
th{background:#f5f5f5}
nav{margin-bottom:1.5rem;padding-bottom:1rem;border-bottom:1px solid #ddd;line-height:1.8}
h2{margin-top:2rem}
a{color:#0366d6}
</style>
</head>
<body>
<nav>
<strong><a href="../docs.html">Thrum Docs</a></strong> &rsaquo; Reference &rsaquo; MCP Server
<hr>
<strong>Overview</strong>: <a href="philosophy.html">Philosophy</a><br>
<strong>Getting Started</strong>: <a href="quickstart.html">Quickstart Guide</a><br>
  <strong>Recommended Tools</strong>: <a href="guides/recommended-tools.html">Recommended Tools</a> | <a href="guides/beads-setup.html">Beads Setup Guide</a> | <a href="guides/beads-ui-setup.html">Beads UI Setup Guide</a> | <a href="guides/playwright-cli-setup.html">Playwright CLI Setup Guide</a><br>
<strong>Web UI</strong>: <a href="web-ui.html">Web UI</a><br>
<strong>Messaging</strong>: <a href="subscriptions.html">Subscriptions & Notifications</a><br>
<strong>Identity</strong>: <a href="identity.html">Agent Identity & Registration</a><br>
<strong>Guides</strong>: <a href="agent-coordination.html">Agent Coordination</a> | <a href="agent-configs.html">Agent Configurations</a> | <a href="multi-agent.html">Multi-Agent Support</a> | <a href="claude-code-plugin.html">Claude Code Plugin</a> | <a href="configuration.html">Configuration</a> | <a href="workflow-templates.html">Workflow Templates</a> | <a href="beads-and-thrum.html">Beads and Thrum</a> | <a href="codex-plugin.html">Codex Plugin</a> | <a href="claude-agent-integration.html">Claude Code Agent Integration</a> | <a href="messaging.html">Messaging</a> | <a href="tailscale-sync.html">Tailscale Sync</a> | <a href="tailscale-security.html">Tailscale Sync Security</a> | <a href="overview.html">Technical Overview</a><br>
<strong>API Reference</strong>: <a href="event-streaming.html">Event Streaming</a> | <a href="inbox-query-methods.html">Inbox Query Methods</a> | <a href="api/authentication.html">Authentication</a> | <a href="api/events.html">Event Reference</a> | <a href="rpc-api.html">RPC API</a> | <a href="api/websocket.html">WebSocket API</a><br>
<strong>Daemon</strong>: <a href="daemon.html">Daemon Architecture</a><br>
<strong>Sync</strong>: <a href="sync.html">Sync Protocol</a><br>
<strong>Development</strong>: <a href="development.html">Development Guide</a> | <a href="security-cicd.html">Security & CI/CD</a><br>
<strong>Architecture</strong>: <a href="architecture.html">Architecture</a><br>
<strong>Context</strong>: <a href="context.html">Agent Context Management</a><br>
<strong>Reference</strong>: <a href="cli.html">CLI Reference</a> | <strong>MCP Server</strong><br>
<strong>uncategorized</strong>: <a href="role-templates.html">Role-Based Preamble Templates</a><br>
</nav>
<main>
<h2>MCP Server</h2>
<blockquote>
<p><strong>See also:</strong> <a href="daemon.html">Daemon Architecture</a> for the underlying daemon the
MCP server connects to, <a href="identity.html">Identity</a> for agent identity resolution.</p>
</blockquote>
<h2>Overview</h2>
<p>The MCP (Model Context Protocol) server enables Claude Code agents to send and
receive messages using native MCP tools instead of shelling out to CLI commands.
It runs as a long-lived child process (<code>thrum mcp serve</code>) communicating over
stdio with JSON-RPC, and connects to the Thrum daemon via Unix socket for
message operations and via WebSocket for real-time push notifications.</p>
<p>The server provides 11 MCP tools: 5 for core messaging operations and 6 for
group management.</p>
<p>The primary motivation is eliminating polling overhead. Without MCP, agents must
periodically call <code>thrum inbox</code> (burning tokens and context). With MCP, a cheap
background sub-agent blocks on <code>wait_for_message</code> and wakes the main agent
instantly when a message arrives.</p>
<h2>Architecture</h2>
<pre><code>Claude Code (Opus/Sonnet)
  |
  +-- long-lived child: thrum mcp serve (stdio JSON-RPC)
  |     |
  |     +-- Daemon Client (Unix socket, per-call)
  |     |   +-- message.send     -&gt; send_message tool
  |     |   +-- message.list     -&gt; check_messages tool
  |     |   +-- message.markRead -&gt; check_messages tool (auto-mark consumed)
  |     |   +-- agent.list       -&gt; list_agents tool
  |     |   +-- message.send x N -&gt; broadcast_message tool
  |     |
  |     +-- WebSocket Client (ws://localhost:{port}/ws)
  |     |   +-- user.identify + user.register -&gt; session setup
  |     |   +-- subscribe (mention_role=@{role}) -&gt; notification stream
  |     |   +-- notification.message -&gt; unblocks wait_for_message
  |     |
  |     +-- Internal Notification Queue (max 1000, FIFO, drops oldest)
  |     |
  |     +-- Identity: .thrum/identities/{name}.json
  |
  +-- background sub-agent: message-listener (Haiku)
        +-- calls wait_for_message(timeout=300) -&gt; blocks until message or timeout</code></pre>
<h3>Package Structure</h3>
<pre><code>internal/mcp/
  server.go    -- NewServer(), tool registration, Run(), InitWaiter()
  tools.go     -- send_message, check_messages, list_agents, broadcast_message handlers
  waiter.go    -- WebSocket client, notification routing, wait_for_message handler
  types.go     -- MCP-specific input/output structs

cmd/thrum/mcp.go  -- thrum mcp serve cobra command</code></pre>
<h3>Startup Sequence</h3>
<ol>
<li>Resolve repo path (respects <code>--repo</code> flag, defaults to <code>.</code>)</li>
<li>If <code>--agent-id</code> is provided, set <code>THRUM_NAME</code> env var before config load</li>
<li>Verify daemon is running (connect to Unix socket, call <code>health</code> RPC)</li>
<li>Load agent identity from <code>.thrum/identities/{name}.json</code> via
<code>config.LoadWithPath</code></li>
<li>Resolve daemon socket path (follows <code>.thrum/redirect</code> in feature worktrees)</li>
<li>Generate composite agent ID via
<code>identity.GenerateAgentID(repoID, role, module, name)</code></li>
<li>Create MCP server with the official Go SDK
(<code>github.com/modelcontextprotocol/go-sdk/mcp</code>)</li>
<li>Register all 11 tool handlers (5 core messaging + 6 group management)</li>
<li>Initialize WebSocket waiter (best-effort -- reads port from
<code>.thrum/var/ws.port</code>)<ul>
<li>Connect to <code>ws://localhost:{port}/ws</code></li>
<li>Send <code>user.identify</code> to get git username</li>
<li>Send <code>user.register</code> with the username</li>
<li>Send <code>subscribe</code> with <code>mention_role</code> for this agent&#39;s role</li>
<li>Start background <code>readLoop</code> goroutine for incoming notifications</li>
</ul>
</li>
<li>Start MCP stdio server (blocks until client disconnects or context
cancelled)</li>
</ol>
<h3>Shutdown</h3>
<p>When Claude Code terminates the process (closes stdin) or a signal is received
(SIGINT/SIGTERM):</p>
<ul>
<li>Context is cancelled</li>
<li>Waiter closes WebSocket connection (daemon auto-unregisters)</li>
<li>Waiter&#39;s <code>readLoop</code> exits, unblocking any active <code>wait_for_message</code> call</li>
<li>Unix socket connections are closed (per-call, so nothing to clean up)</li>
<li>Process exits</li>
</ul>
<h3>Key Design Decisions</h3>
<ul>
<li><strong>Per-call <code>cli.Client</code> creation</strong>: <code>cli.Client</code> is not concurrent-safe. Each
tool handler creates a fresh Unix socket connection. This is cheap (local
socket) and avoids concurrency issues.</li>
<li><strong>Atomic WebSocket request IDs</strong>: The waiter uses <code>atomic.Int64</code> for
incrementing JSON-RPC request IDs, ensuring uniqueness across concurrent
calls.</li>
<li><strong>Single-waiter enforcement</strong>: Only one <code>wait_for_message</code> can be active at a
time per server instance. A second call returns an error. Enforced with a
mutex.</li>
<li><strong>Best-effort WebSocket</strong>: If the WebSocket connection fails at startup, the
MCP server still operates -- only <code>wait_for_message</code> returns errors. The other
10 tools work via Unix socket RPC.</li>
</ul>
<h2>Usage</h2>
<h3>Command</h3>
<pre><code>thrum mcp serve [--agent-id NAME]</code></pre>
<p><strong>Prerequisites:</strong></p>
<ul>
<li>Thrum daemon must be running (<code>thrum daemon start</code>)</li>
<li>Agent must be registered
(<code>thrum quickstart --name NAME --role ROLE --module MODULE</code>)</li>
</ul>
<p><strong>Flags:</strong></p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>--agent-id</code></td>
<td>(from identity file)</td>
<td>Override agent name; selects <code>.thrum/identities/{name}.json</code></td>
</tr>
<tr>
<td><code>--repo</code></td>
<td><code>.</code></td>
<td>Repository path</td>
</tr>
</tbody></table>
<h3>Claude Code Configuration</h3>
<p>Add to <code>.claude/settings.json</code> (project or user level):</p>
<pre><code>{
  &quot;mcpServers&quot;: {
    &quot;thrum&quot;: {
      &quot;type&quot;: &quot;stdio&quot;,
      &quot;command&quot;: &quot;thrum&quot;,
      &quot;args&quot;: [&quot;mcp&quot;, &quot;serve&quot;]
    }
  }
}</code></pre>
<p>Once configured, Claude Code starts <code>thrum mcp serve</code> as a child process and
exposes its tools as <code>mcp__thrum__&lt;tool_name&gt;</code>.</p>
<h2>API Reference</h2>
<h3>send_message</h3>
<p>Send a message to another agent, role, or group.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>to</code></td>
<td>string</td>
<td>yes</td>
<td>Recipient: <code>@role</code>, agent name, <code>@groupname</code>, or composite <code>agent:role:hash</code></td>
</tr>
<tr>
<td><code>content</code></td>
<td>string</td>
<td>yes</td>
<td>Message text (markdown)</td>
</tr>
<tr>
<td><code>reply_to</code></td>
<td>string</td>
<td>no</td>
<td>Message ID to reply to (creates a reply chain)</td>
</tr>
<tr>
<td><code>metadata</code></td>
<td>object</td>
<td>no</td>
<td>Key-value metadata (passed as structured data)</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>delivered</code></td>
</tr>
<tr>
<td><code>message_id</code></td>
<td>string</td>
<td>ID of the sent message</td>
</tr>
<tr>
<td><code>resolved_to</code></td>
<td>string</td>
<td>How the recipient was resolved (<code>name</code>, <code>role</code>, <code>group</code>)</td>
</tr>
<tr>
<td><code>warnings</code></td>
<td>array</td>
<td>Any routing warnings (e.g., <code>@name</code> matched a role group)</td>
</tr>
</tbody></table>
<p><strong>Addressing:</strong> The <code>to</code> field is parsed to extract a mention role:</p>
<ul>
<li><code>@ops</code> becomes mention for role <code>ops</code></li>
<li><code>agent:ops:abc123</code> extracts role <code>ops</code></li>
<li><code>ops</code> is used as-is</li>
</ul>
<p><strong>Daemon RPC:</strong> <code>message.send</code></p>
<h3>check_messages</h3>
<p>Poll for unread messages mentioning this agent. Messages are automatically
marked as read after retrieval.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>limit</code></td>
<td>integer</td>
<td>no</td>
<td>Max messages to return (default 50)</td>
</tr>
</tbody></table>
<p>Agent identity is resolved at server startup; the client does not pass an agent
ID.</p>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>messages</code> or <code>empty</code></td>
</tr>
<tr>
<td><code>messages</code></td>
<td>array</td>
<td>List of <code>MessageInfo</code> objects</td>
</tr>
<tr>
<td><code>remaining</code></td>
<td>integer</td>
<td>Count of remaining unread messages (clamped to &gt;= 0)</td>
</tr>
</tbody></table>
<p><strong>MessageInfo:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>message_id</code></td>
<td>string</td>
<td>Message identifier</td>
</tr>
<tr>
<td><code>from</code></td>
<td>string</td>
<td>Sender agent ID</td>
</tr>
<tr>
<td><code>content</code></td>
<td>string</td>
<td>Message content</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>string</td>
<td>Creation timestamp</td>
</tr>
</tbody></table>
<p><strong>Behavior:</strong></p>
<ol>
<li>Lists unread messages mentioning this agent&#39;s role via <code>message.list</code> RPC</li>
<li>Marks all returned messages as read via <code>message.markRead</code> RPC (best-effort)</li>
<li>Returns consumed messages (they will not appear on the next <code>check_messages</code>
call)</li>
</ol>
<p><strong>Daemon RPC:</strong> <code>message.list</code> + <code>message.markRead</code></p>
<h3>wait_for_message</h3>
<p>Block until a message arrives or timeout expires. Designed for background
listener sub-agents running on Haiku.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>timeout</code></td>
<td>integer</td>
<td>no</td>
<td>Max seconds to wait (default 300, max 600)</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>message_received</code> or <code>timeout</code></td>
</tr>
<tr>
<td><code>message</code></td>
<td>MessageInfo</td>
<td>The received message (null on timeout)</td>
</tr>
<tr>
<td><code>waited_seconds</code></td>
<td>integer</td>
<td>How long the wait lasted</td>
</tr>
</tbody></table>
<p><strong>Behavior:</strong></p>
<ol>
<li>Check the internal notification queue (messages that arrived while no waiter
was active)</li>
<li>If a queued message exists, pop it and return immediately</li>
<li>If queue is empty, block on a channel with the specified timeout</li>
<li>When a WebSocket <code>notification.message</code> arrives, the <code>readLoop</code> pushes it to
the queue and closes the waiter channel</li>
<li>Fetch the full message via <code>message.get</code> RPC</li>
<li>Mark as read via <code>message.markRead</code> RPC (best-effort)</li>
<li>Return the message</li>
</ol>
<p><strong>Concurrency:</strong> Only one <code>wait_for_message</code> can be active at a time. A second
concurrent call returns an error.</p>
<p><strong>Requires:</strong> WebSocket waiter initialized at startup. If the waiter failed to
connect, this tool returns an error.</p>
<p><strong>Daemon RPC:</strong> WebSocket notifications + <code>message.get</code> + <code>message.markRead</code></p>
<h3>list_agents</h3>
<p>List all registered agents and their status.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>include_offline</code></td>
<td>boolean</td>
<td>no</td>
<td>Include inactive agents (default <code>true</code>; uses pointer semantics)</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>agents</code></td>
<td>array</td>
<td>List of <code>AgentInfo</code> objects</td>
</tr>
<tr>
<td><code>count</code></td>
<td>integer</td>
<td>Number of agents returned</td>
</tr>
</tbody></table>
<p><strong>AgentInfo:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>string</td>
<td>Agent display name</td>
</tr>
<tr>
<td><code>role</code></td>
<td>string</td>
<td>Agent role</td>
</tr>
<tr>
<td><code>module</code></td>
<td>string</td>
<td>Agent module</td>
</tr>
<tr>
<td><code>status</code></td>
<td>string</td>
<td><code>active</code> or <code>offline</code></td>
</tr>
<tr>
<td><code>last_seen_at</code></td>
<td>string</td>
<td>Last heartbeat timestamp</td>
</tr>
</tbody></table>
<p><strong>Status derivation:</strong> Based on <code>last_seen_at</code> relative to current time:</p>
<ul>
<li>Less than 2 minutes ago: <code>active</code></li>
<li>2+ minutes ago or missing: <code>offline</code></li>
</ul>
<p><strong>Daemon RPC:</strong> <code>agent.list</code></p>
<h3>broadcast_message</h3>
<p>Send a message to all agents via the <code>@everyone</code> group, with optional filtering.
The sender is automatically excluded. This is a convenience wrapper around
sending to <code>@everyone</code>.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>content</code></td>
<td>string</td>
<td>yes</td>
<td>Message text to broadcast</td>
</tr>
<tr>
<td><code>filter</code></td>
<td>object</td>
<td>no</td>
<td>Optional recipient filters</td>
</tr>
</tbody></table>
<p><strong>BroadcastFilter:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>all</code> (default) or <code>active</code> (only agents seen in last 2 min)</td>
</tr>
<tr>
<td><code>exclude</code></td>
<td>array</td>
<td>Agent names or roles to exclude</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>sent</code>, <code>partial</code> (some failures), or <code>no_recipients</code></td>
</tr>
<tr>
<td><code>sent_to</code></td>
<td>array</td>
<td>Roles of agents that received the message</td>
</tr>
<tr>
<td><code>failed_to</code></td>
<td>array</td>
<td>Roles of agents where send failed</td>
</tr>
<tr>
<td><code>total_sent</code></td>
<td>integer</td>
<td>Count of successful sends</td>
</tr>
<tr>
<td><code>message_ids</code></td>
<td>array</td>
<td>IDs of sent messages</td>
</tr>
</tbody></table>
<p><strong>Behavior:</strong></p>
<ol>
<li>Fetch agent list via <code>agent.list</code> RPC</li>
<li>Filter out self (by agent ID, not role -- so other agents with the same role
still receive the message)</li>
<li>Apply exclude filter (matches against both role and display name)</li>
<li>Apply status filter (if <code>active</code>, skip agents with <code>offline</code> status)</li>
<li>Send individual messages to each remaining agent via <code>message.send</code> RPC</li>
</ol>
<p><strong>Daemon RPC:</strong> <code>agent.list</code> + <code>message.send</code> (one per recipient)</p>
<h3>create_group</h3>
<p>Create a named group for targeted messaging.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>string</td>
<td>yes</td>
<td>Group name (e.g., <code>reviewers</code>)</td>
</tr>
<tr>
<td><code>description</code></td>
<td>string</td>
<td>no</td>
<td>Human-readable group description</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>created</code></td>
</tr>
<tr>
<td><code>name</code></td>
<td>string</td>
<td>Name of the created group</td>
</tr>
</tbody></table>
<p><strong>Daemon RPC:</strong> <code>group.create</code></p>
<h3>delete_group</h3>
<p>Delete a group by name. The <code>@everyone</code> group is protected and cannot be
deleted.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>string</td>
<td>yes</td>
<td>Group name to delete</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>deleted</code></td>
</tr>
<tr>
<td><code>name</code></td>
<td>string</td>
<td>Name of the deleted group</td>
</tr>
</tbody></table>
<p><strong>Daemon RPC:</strong> <code>group.delete</code></p>
<h3>add_group_member</h3>
<p>Add a member (agent or role) to a group.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>group</code></td>
<td>string</td>
<td>yes</td>
<td>Group name to add member to</td>
</tr>
<tr>
<td><code>member_type</code></td>
<td>string</td>
<td>yes</td>
<td><code>agent</code> or <code>role</code></td>
</tr>
<tr>
<td><code>member_value</code></td>
<td>string</td>
<td>yes</td>
<td>Agent name or role name</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>added</code></td>
</tr>
<tr>
<td><code>group</code></td>
<td>string</td>
<td>Group name</td>
</tr>
<tr>
<td><code>member_type</code></td>
<td>string</td>
<td>Type of member added</td>
</tr>
<tr>
<td><code>member_value</code></td>
<td>string</td>
<td>Value of member added</td>
</tr>
</tbody></table>
<p><strong>Daemon RPC:</strong> <code>group.member.add</code></p>
<h3>remove_group_member</h3>
<p>Remove a member from a group.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>group</code></td>
<td>string</td>
<td>yes</td>
<td>Group name to remove member from</td>
</tr>
<tr>
<td><code>member_type</code></td>
<td>string</td>
<td>yes</td>
<td><code>agent</code> or <code>role</code></td>
</tr>
<tr>
<td><code>member_value</code></td>
<td>string</td>
<td>yes</td>
<td>Agent name or role name</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>status</code></td>
<td>string</td>
<td><code>removed</code></td>
</tr>
<tr>
<td><code>group</code></td>
<td>string</td>
<td>Group name</td>
</tr>
<tr>
<td><code>member_type</code></td>
<td>string</td>
<td>Type of member removed</td>
</tr>
<tr>
<td><code>member_value</code></td>
<td>string</td>
<td>Value of member removed</td>
</tr>
</tbody></table>
<p><strong>Daemon RPC:</strong> <code>group.member.remove</code></p>
<h3>list_groups</h3>
<p>List all groups in the system.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><em>(none)</em></td>
<td></td>
<td></td>
<td>Empty object or omit params</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>groups</code></td>
<td>array</td>
<td>List of <code>GroupInfo</code> objects</td>
</tr>
<tr>
<td><code>groups[].name</code></td>
<td>string</td>
<td>Group name</td>
</tr>
<tr>
<td><code>groups[].description</code></td>
<td>string</td>
<td>Group description (may be empty)</td>
</tr>
<tr>
<td><code>groups[].created_at</code></td>
<td>string</td>
<td>ISO 8601 creation timestamp</td>
</tr>
<tr>
<td><code>groups[].created_by</code></td>
<td>string</td>
<td>Agent ID of creator</td>
</tr>
<tr>
<td><code>groups[].member_count</code></td>
<td>integer</td>
<td>Number of direct members</td>
</tr>
</tbody></table>
<p><strong>Daemon RPC:</strong> <code>group.list</code></p>
<h3>get_group</h3>
<p>Get detailed information about a specific group. Supports expansion to resolve
roles to individual agent IDs.</p>
<p><strong>Input:</strong></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>string</td>
<td>yes</td>
<td>Group name</td>
</tr>
<tr>
<td><code>expand</code></td>
<td>boolean</td>
<td>no</td>
<td>Resolve roles to agent IDs</td>
</tr>
</tbody></table>
<p><strong>Output:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>string</td>
<td>Group name</td>
</tr>
<tr>
<td><code>description</code></td>
<td>string</td>
<td>Group description (may be empty)</td>
</tr>
<tr>
<td><code>created_at</code></td>
<td>string</td>
<td>ISO 8601 creation timestamp</td>
</tr>
<tr>
<td><code>created_by</code></td>
<td>string</td>
<td>Agent ID of creator</td>
</tr>
<tr>
<td><code>members</code></td>
<td>array</td>
<td>List of member objects</td>
</tr>
<tr>
<td><code>members[].type</code></td>
<td>string</td>
<td><code>agent</code> or <code>role</code></td>
</tr>
<tr>
<td><code>members[].id</code></td>
<td>string</td>
<td>Agent name or role name</td>
</tr>
<tr>
<td><code>expanded_agents</code></td>
<td>array</td>
<td>(Only if <code>expand=true</code>) List of agent IDs</td>
</tr>
<tr>
<td><code>expanded_agents_count</code></td>
<td>integer</td>
<td>(Only if <code>expand=true</code>) Count of agent IDs</td>
</tr>
</tbody></table>
<p><strong>Daemon RPC:</strong> <code>group.info</code> (without expand) or <code>group.members</code> (with expand)</p>
<h2>Identity Resolution</h2>
<p>The MCP server resolves agent identity once at startup. The client never passes
agent IDs in tool calls.</p>
<p><strong>Resolution order:</strong></p>
<ol>
<li><code>--agent-id</code> flag on <code>thrum mcp serve</code> (sets <code>THRUM_NAME</code> env var)</li>
<li><code>THRUM_NAME</code> environment variable</li>
<li>Auto-select single identity file in <code>.thrum/identities/</code></li>
<li>Error if no identity found or multiple identities exist without
disambiguation</li>
</ol>
<p><strong>Identity file:</strong> <code>.thrum/identities/{name}.json</code> contains name, role, module,
and repo ID. The server generates a composite agent ID (<code>agent:{role}:{hash}</code>)
using <code>identity.GenerateAgentID()</code>, consistent with daemon RPC handlers.</p>
<p><strong>Multi-agent worktrees:</strong> When multiple agents operate in the same worktree,
each must have a distinct identity file. Use <code>THRUM_NAME</code> env var or
<code>--agent-id</code> flag to select.</p>
<h2>WebSocket Waiter</h2>
<p>The <code>Waiter</code> struct (<code>internal/mcp/waiter.go</code>) manages the WebSocket connection
for real-time message notifications.</p>
<h3>Connection Setup</h3>
<p>On initialization, the waiter:</p>
<ol>
<li>Connects to the daemon WebSocket at <code>ws://localhost:{port}/ws</code></li>
<li>Sends <code>user.identify</code> to get the git username</li>
<li>Sends <code>user.register</code> with that username</li>
<li>Sends <code>subscribe</code> with <code>mention_role</code> set to the agent&#39;s role</li>
<li>Starts a background <code>readLoop</code> goroutine</li>
</ol>
<h3>Notification Flow</h3>
<pre><code>Daemon WebSocket -&gt; readLoop -&gt; queue ([]MessageNotification) -&gt; waiterCh -&gt; WaitForMessage</code></pre>
<p>The <code>readLoop</code> goroutine:</p>
<ul>
<li>Reads WebSocket messages continuously</li>
<li>Filters for <code>notification.message</code> method</li>
<li>Parses the notification into a <code>MessageNotification</code> (message_id, preview,
agent_id, timestamp)</li>
<li>Appends to the internal queue (max 1000 items; drops oldest on overflow)</li>
<li>Closes the <code>waiterCh</code> channel to wake any blocked <code>WaitForMessage</code> call</li>
</ul>
<p>On connection loss, <code>readLoop</code> closes <code>waiterCh</code> (if set) before exiting, which
unblocks any active waiter with a timeout-like response rather than hanging
forever.</p>
<h3>JSON-RPC over WebSocket</h3>
<p>The waiter uses JSON-RPC 2.0 for setup RPCs. Request IDs are atomically
incremented (<code>atomic.Int64</code>). During <code>wsRPC</code> calls, incoming notifications are
skipped (they have no <code>id</code> field and a non-empty <code>method</code> field).</p>
<h2>Integration</h2>
<h3>Message-Listener Sub-Agent</h3>
<p>The recommended pattern for receiving messages in Claude Code is a background
Haiku sub-agent that blocks on <code>wait_for_message</code>. This is defined in
<code>.claude/agents/message-listener.md</code>.</p>
<p><strong>How it works:</strong></p>
<ol>
<li>The main agent spawns the message-listener as a background <code>Task</code> sub-agent</li>
<li>The listener calls <code>check_messages</code> to drain any backlog</li>
<li>If messages are found, it returns them immediately</li>
<li>If none, it calls <code>wait_for_message(timeout=300)</code> and blocks</li>
<li>When a message arrives or timeout occurs, the listener returns to the main
agent</li>
<li>The main agent processes the result and re-arms the listener</li>
</ol>
<p><strong>Return format:</strong></p>
<p>When messages are received:</p>
<pre><code>MESSAGES_RECEIVED
FROM: [sender]
CONTENT: [message content]
TIMESTAMP: [timestamp]</code></pre>
<p>When timeout occurs:</p>
<pre><code>NO_MESSAGES_TIMEOUT</code></pre>
<p><strong>Cost:</strong> Approximately $0.00003 per cycle (Haiku-class model).</p>
<h3>Context Management</h3>
<ul>
<li>Compact after 10+ message cycles to prevent context overflow</li>
<li>After 5 consecutive timeouts with no pending work, send status to the
coordinator and stop the listener</li>
</ul>
<h3>CLAUDE.md Protocol</h3>
<p>The project <code>CLAUDE.md</code> includes instructions for agents to use MCP tools:</p>
<p><strong>Core messaging:</strong></p>
<pre><code>mcp__thrum__send_message(to=&quot;@reviewer&quot;, content=&quot;...&quot;)
mcp__thrum__check_messages()
mcp__thrum__list_agents()
mcp__thrum__send_message(to=&quot;@everyone&quot;, content=&quot;...&quot;)  # preferred over broadcast_message
mcp__thrum__wait_for_message(timeout=300)</code></pre>
<p><strong>Group management:</strong></p>
<pre><code>mcp__thrum__create_group(name=&quot;backend&quot;, description=&quot;Backend team&quot;)
mcp__thrum__add_group_member(group=&quot;backend&quot;, member_type=&quot;role&quot;, member_value=&quot;implementer&quot;)
mcp__thrum__list_groups()
mcp__thrum__get_group(name=&quot;backend&quot;, expand=true)
mcp__thrum__remove_group_member(group=&quot;backend&quot;, member_type=&quot;agent&quot;, member_value=&quot;alice&quot;)
mcp__thrum__delete_group(name=&quot;backend&quot;)</code></pre>
<h2>Development</h2>
<h3>Source Files</h3>
<table>
<thead>
<tr>
<th>File</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><code>internal/mcp/server.go</code></td>
<td>Server struct, NewServer(), Run(), InitWaiter(), tool registration</td>
</tr>
<tr>
<td><code>internal/mcp/tools.go</code></td>
<td>Tool handlers, address parsing, status derivation</td>
</tr>
<tr>
<td><code>internal/mcp/waiter.go</code></td>
<td>WebSocket connection, readLoop, WaitForMessage, notification queue</td>
</tr>
<tr>
<td><code>internal/mcp/types.go</code></td>
<td>Input/output structs for all 11 tools</td>
</tr>
<tr>
<td><code>cmd/thrum/mcp.go</code></td>
<td>Cobra command, daemon health check, waiter init, signal handling</td>
</tr>
<tr>
<td><code>.claude/agents/message-listener.md</code></td>
<td>Haiku sub-agent definition</td>
</tr>
</tbody></table>
<h3>Testing</h3>
<pre><code># Unit + sequential integration tests (no daemon needed)
go test ./internal/mcp/...

# With verbose output
go test -v ./internal/mcp/...</code></pre>
<p>Test coverage includes:</p>
<ul>
<li>Tool handler input validation</li>
<li>Message queue push/pop semantics</li>
<li>Waiter timeout and cancellation logic</li>
<li>Identity resolution</li>
<li>18 tests passing (unit + sequential integration)</li>
</ul>
<p>WebSocket integration tests (requiring a running daemon WebSocket) are currently
deferred.</p>
<h3>Debugging</h3>
<p>The MCP server logs warnings to stderr. Check for:</p>
<ul>
<li><code>Warning: WebSocket waiter not available</code> -- daemon WebSocket port not found
or connection failed; <code>wait_for_message</code> will not work but other tools
function normally</li>
<li><code>agent name not configured</code> / <code>agent role not configured</code> -- agent identity
not registered; run <code>thrum quickstart</code> first</li>
<li><code>Thrum daemon is not running</code> -- start the daemon with <code>thrum daemon start</code></li>
</ul>
<h3>Dependencies</h3>
<ul>
<li><strong>Runtime:</strong> Thrum daemon (<code>thrum daemon start</code>)</li>
<li><strong>Go SDK:</strong> <code>github.com/modelcontextprotocol/go-sdk/mcp</code> (official MCP Go SDK)</li>
<li><strong>WebSocket:</strong> <code>github.com/gorilla/websocket</code></li>
<li><strong>Identity:</strong> Agent registered with <code>.thrum/identities/{name}.json</code></li>
</ul>
<h2>References</h2>
<ul>
<li>Design document: <code>dev-docs/plans/2026-02-06-mcp-server-design.md</code></li>
<li>Daemon architecture: <code>docs/daemon.md</code></li>
<li>RPC API reference: <code>docs/rpc-api.md</code></li>
<li>Identity system: <code>docs/identity.md</code></li>
<li>Agent reference: <code>llms.txt</code></li>
</ul>
<pre><code></code></pre>

</main>
<script>if(location.search.indexOf('nospa')===-1){location.replace('../docs.html#mcp-server.html')}</script>
</body>
</html>