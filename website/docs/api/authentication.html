<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Authentication — Thrum</title>
<meta name="description" content="Authentication and authorization in the Thrum API — agent identity, session tokens, and security model">
<link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#api/authentication.html">
<style>
body{font-family:system-ui,sans-serif;max-width:48rem;margin:2rem auto;padding:0 1.5rem;line-height:1.6;color:#222}
pre{background:#f5f5f5;padding:1rem;overflow-x:auto;border-radius:4px}
code{font-family:ui-monospace,monospace;font-size:0.9em}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #ddd;padding:0.4rem 0.6rem;text-align:left}
th{background:#f5f5f5}
nav{margin-bottom:1.5rem;padding-bottom:1rem;border-bottom:1px solid #ddd;line-height:1.8}
h2{margin-top:2rem}
a{color:#0366d6}
</style>
</head>
<body>
<nav>
<strong><a href="../../docs.html">Thrum Docs</a></strong> &rsaquo; API Reference &rsaquo; Authentication
<hr>
<strong>Overview</strong>: <a href="../philosophy.html">Philosophy</a><br>
<strong>Getting Started</strong>: <a href="../quickstart.html">Quickstart Guide</a><br>
  <strong>Recommended Tools</strong>: <a href="../guides/recommended-tools.html">Recommended Tools</a> | <a href="../guides/beads-setup.html">Beads Setup Guide</a> | <a href="../guides/beads-ui-setup.html">Beads UI Setup Guide</a> | <a href="../guides/playwright-cli-setup.html">Playwright CLI Setup Guide</a><br>
<strong>Web UI</strong>: <a href="../web-ui.html">Web UI</a><br>
<strong>Messaging</strong>: <a href="../subscriptions.html">Subscriptions & Notifications</a><br>
<strong>Identity</strong>: <a href="../identity.html">Agent Identity & Registration</a><br>
<strong>Guides</strong>: <a href="../agent-coordination.html">Agent Coordination</a> | <a href="../agent-configs.html">Agent Configurations</a> | <a href="../multi-agent.html">Multi-Agent Support</a> | <a href="../claude-code-plugin.html">Claude Code Plugin</a> | <a href="../configuration.html">Configuration</a> | <a href="../workflow-templates.html">Workflow Templates</a> | <a href="../beads-and-thrum.html">Beads and Thrum</a> | <a href="../codex-plugin.html">Codex Plugin</a> | <a href="../claude-agent-integration.html">Claude Code Agent Integration</a> | <a href="../messaging.html">Messaging</a> | <a href="../tailscale-sync.html">Tailscale Sync</a> | <a href="../tailscale-security.html">Tailscale Sync Security</a> | <a href="../overview.html">Technical Overview</a><br>
<strong>API Reference</strong>: <a href="../event-streaming.html">Event Streaming</a> | <a href="../inbox-query-methods.html">Inbox Query Methods</a> | <strong>Authentication</strong> | <a href="../api/events.html">Event Reference</a> | <a href="../rpc-api.html">RPC API</a> | <a href="../api/websocket.html">WebSocket API</a><br>
<strong>Daemon</strong>: <a href="../daemon.html">Daemon Architecture</a><br>
<strong>Sync</strong>: <a href="../sync.html">Sync Protocol</a><br>
<strong>Development</strong>: <a href="../development.html">Development Guide</a> | <a href="../security-cicd.html">Security & CI/CD</a><br>
<strong>Architecture</strong>: <a href="../architecture.html">Architecture</a><br>
<strong>Context</strong>: <a href="../context.html">Agent Context Management</a><br>
<strong>Reference</strong>: <a href="../cli.html">CLI Reference</a> | <a href="../mcp-server.html">MCP Server</a><br>
<strong>uncategorized</strong>: <a href="../role-templates.html">Role-Based Preamble Templates</a><br>
</nav>
<main>
<h2>Authentication Guide</h2>
<p>This document explains authentication and authorization in the Thrum API.</p>
<h2>Overview</h2>
<p>Thrum supports two types of identity:</p>
<ol>
<li><strong>Agents</strong>: Autonomous processes (bots, AI agents, services) that send and
receive messages</li>
<li><strong>Users</strong>: Human users accessing the system via WebSocket (typically through
the embedded web UI)</li>
</ol>
<p>Both agents and users are registered with the daemon and stored in the same
<code>agents</code> table in SQLite (distinguished by the <code>kind</code> field: <code>&quot;agent&quot;</code> or
<code>&quot;user&quot;</code>).</p>
<h2>Agent Authentication</h2>
<h3>Registration</h3>
<p>Agents register using the <code>agent.register</code> RPC method, available over both Unix
socket and WebSocket.</p>
<p><strong>Identity Components</strong>:</p>
<ul>
<li><code>name</code>: Human-readable agent name (optional; e.g., <code>&quot;furiosa&quot;</code>, <code>&quot;nux&quot;</code>)</li>
<li><code>role</code>: The agent&#39;s function (e.g., <code>&quot;implementer&quot;</code>, <code>&quot;reviewer&quot;</code>,
<code>&quot;coordinator&quot;</code>)</li>
<li><code>module</code>: The area of responsibility (e.g., <code>&quot;auth&quot;</code>, <code>&quot;sync&quot;</code>, <code>&quot;ui&quot;</code>)</li>
<li><code>repo_id</code>: Automatically determined from the repository&#39;s git origin URL</li>
</ul>
<p><strong>Agent ID Format</strong>:</p>
<ul>
<li><strong>Named</strong>: <code>{name}</code> (e.g., <code>furiosa</code>)</li>
<li><strong>Unnamed</strong>: <code>{role}_{hash10}</code> (e.g., <code>implementer_35HV62T9B9</code>)</li>
<li><strong>Legacy</strong> (backward compatible): <code>agent:{role}:{hash}</code> -- no longer generated
but still recognized</li>
</ul>
<p>The hash is computed as
<code>crockford_base32(sha256(repo_id + &quot;|&quot; + role + &quot;|&quot; + module))[:10]</code>.</p>
<p><strong>Example</strong> (named agent):</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;agent.register&quot;,
  &quot;params&quot;: {
    &quot;name&quot;: &quot;furiosa&quot;,
    &quot;role&quot;: &quot;implementer&quot;,
    &quot;module&quot;: &quot;auth&quot;,
    &quot;display&quot;: &quot;Auth Implementer&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<p><strong>Response</strong>:</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;agent_id&quot;: &quot;furiosa&quot;,
    &quot;status&quot;: &quot;registered&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<p><strong>Example</strong> (unnamed agent):</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;agent.register&quot;,
  &quot;params&quot;: {
    &quot;role&quot;: &quot;implementer&quot;,
    &quot;module&quot;: &quot;auth&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<p><strong>Response</strong>:</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;agent_id&quot;: &quot;implementer_35HV62T9B9&quot;,
    &quot;status&quot;: &quot;registered&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<h3>Re-Registration</h3>
<p>Agents can re-register with the same role/module/name. The same agent ID is
returned without writing a new event (idempotent). To force an update event, use
the <code>re_register</code> flag.</p>
<p><strong>Use cases</strong>:</p>
<ul>
<li>Agent restart</li>
<li>Daemon restart</li>
<li>Network reconnection</li>
<li>Updating display name</li>
</ul>
<h3>Quickstart (CLI Shortcut)</h3>
<p>The <code>quickstart</code> command combines registration, session start, and optional
intent setting:</p>
<pre><code>thrum quickstart --name furiosa --role implementer --module auth --intent &quot;Working on auth&quot;</code></pre>
<h3>Session Management</h3>
<p>After registration, agents must start a session to send messages:</p>
<ol>
<li><strong>Register</strong>: <code>agent.register</code> -&gt; get <code>agent_id</code></li>
<li><strong>Start session</strong>: <code>session.start</code> with <code>agent_id</code> -&gt; get <code>session_id</code></li>
<li><strong>Heartbeat</strong>: <code>session.heartbeat</code> to update last-seen time and extract git
work context</li>
<li><strong>Send messages</strong>: Use <code>agent_id</code> in requests</li>
<li><strong>End session</strong>: <code>session.end</code> with <code>session_id</code></li>
</ol>
<p><strong>Why sessions?</strong></p>
<ul>
<li>Track agent activity periods</li>
<li>Detect crashes (orphaned sessions)</li>
<li>Attribute messages to specific runs</li>
<li>Track git work context (branch, changed files, uncommitted work)</li>
</ul>
<p><strong>Session IDs</strong> use ULID format: <code>ses_</code> + ULID (e.g.,
<code>ses_01HXE8Z7R9K3Q6M2W8F4VY</code>).</p>
<h3>Identity Resolution for CLI</h3>
<p>The CLI resolves agent identity using a priority chain (see <code>docs/identity.md</code>
for full details):</p>
<ol>
<li><code>THRUM_NAME</code> env var (selects identity file; highest priority)</li>
<li>CLI flags (<code>--name</code>, <code>--role</code>, <code>--module</code>)</li>
<li>Environment variables (<code>THRUM_ROLE</code>, <code>THRUM_MODULE</code>, <code>THRUM_DISPLAY</code>)</li>
<li>Identity file in <code>.thrum/identities/</code> directory</li>
<li>Error if required fields missing</li>
</ol>
<h3>MCP Server Identity</h3>
<p>The MCP server (<code>thrum mcp serve</code>) loads agent identity at startup from
<code>.thrum/identities/{name}.json</code>. It requires a named agent. Use <code>--agent-id</code>
flag or <code>THRUM_NAME</code> env var for multi-agent worktrees:</p>
<pre><code>THRUM_NAME=furiosa thrum mcp serve
thrum mcp serve --agent-id furiosa</code></pre>
<h2>User Authentication</h2>
<h3>WebSocket-Only</h3>
<p>Users can <strong>only</strong> register via WebSocket (not Unix socket). This is enforced by
the daemon:</p>
<ul>
<li>Unix socket is for local agents (same machine, no UI)</li>
<li>WebSocket is for browser connections (UI at <code>http://localhost:9999</code>)</li>
</ul>
<p>Attempting <code>user.register</code> over Unix socket returns error code <code>-32001</code>.</p>
<h3>Browser Auto-Registration</h3>
<p>When a user opens the web UI at <code>http://localhost:9999</code>, the browser
automatically registers:</p>
<ol>
<li><strong>Connect</strong>: WebSocket connects to <code>ws://localhost:9999/ws</code></li>
<li><strong>Identify</strong>: Call <code>user.identify</code> RPC to get git user info from the
repository&#39;s <code>git config</code></li>
<li><strong>Register</strong>: Call <code>user.register</code> with the sanitized username</li>
<li><strong>Persist</strong>: Store user info and token in <code>localStorage</code> for reconnection</li>
</ol>
<p>This flow is handled by the <code>AuthProvider</code> React component. No manual login is
required.</p>
<p><strong>Fallback</strong>: If <code>git config user.name</code> is not set, the UI checks <code>localStorage</code>
for a previously stored username. If neither source is available, an error is
displayed.</p>
<h3>user.identify RPC</h3>
<p>Returns git user info from the repository&#39;s git config. No authentication needed
-- this is a read-only query. Available over both Unix socket and WebSocket.</p>
<p><strong>Response</strong>:</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;username&quot;: &quot;leon-letto&quot;,
    &quot;email&quot;: &quot;leon@example.com&quot;,
    &quot;display&quot;: &quot;Leon Letto&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<p>The <code>username</code> field is sanitized from <code>git config user.name</code>: lowercased,
spaces/hyphens/underscores normalized to hyphens, non-alphanumeric characters
stripped, truncated to 32 characters.</p>
<h3>user.register RPC</h3>
<p>Registers a user with the daemon. <strong>Idempotent</strong>: if the user already exists,
returns existing info with a fresh session token.</p>
<p><strong>Username Rules</strong>:</p>
<ul>
<li>Alphanumeric characters, underscores, and hyphens</li>
<li>Length 1-32 characters</li>
<li>Must not start with <code>agent:</code> prefix</li>
<li>Regex: <code>^[a-zA-Z0-9_-]{1,32}$</code></li>
</ul>
<p><strong>User ID Format</strong>: <code>user:{username}</code> (e.g., <code>user:leon</code>)</p>
<p><strong>Example</strong>:</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;user.register&quot;,
  &quot;params&quot;: {
    &quot;username&quot;: &quot;leon&quot;,
    &quot;display&quot;: &quot;Leon Letto&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<p><strong>Response</strong>:</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: {
    &quot;user_id&quot;: &quot;user:leon&quot;,
    &quot;username&quot;: &quot;leon&quot;,
    &quot;display_name&quot;: &quot;Leon Letto&quot;,
    &quot;token&quot;: &quot;tok_01HXE8Z7R9K3Q6M2W8F4VY&quot;,
    &quot;status&quot;: &quot;registered&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<p>When re-registering an existing user, the response has <code>&quot;status&quot;: &quot;existing&quot;</code>
and a fresh token.</p>
<p><strong>Storage</strong>: Users are stored internally as <code>agent.register</code> events with
<code>kind: &quot;user&quot;</code>, <code>role: {username}</code>, and <code>module: &quot;ui&quot;</code>.</p>
<h3>localStorage Persistence</h3>
<p>The browser stores user identity in <code>localStorage</code> under the <code>thrum_user</code> key:</p>
<pre><code>{
  &quot;user_id&quot;: &quot;user:leon&quot;,
  &quot;token&quot;: &quot;tok_...&quot;,
  &quot;username&quot;: &quot;leon&quot;,
  &quot;display_name&quot;: &quot;Leon Letto&quot;
}</code></pre>
<p>On subsequent page loads, the stored username is used as a fallback if
<code>user.identify</code> fails.</p>
<h2>Authorization</h2>
<h3>Impersonation</h3>
<p>Users can impersonate agents to send messages &quot;as&quot; an agent.</p>
<p><strong>Use case</strong>: UI allowing users to send messages from an agent&#39;s perspective.</p>
<p><strong>Restrictions</strong>:</p>
<ol>
<li><strong>Only users can impersonate</strong>: Agents cannot impersonate other agents or
users</li>
<li><strong>Only agents can be impersonated</strong>: Users cannot impersonate other users</li>
<li><strong>Target must exist</strong>: The impersonated agent must be registered</li>
</ol>
<p><strong>Example</strong>:</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;message.send&quot;,
  &quot;params&quot;: {
    &quot;content&quot;: &quot;Hello from Claude!&quot;,
    &quot;acting_as&quot;: &quot;furiosa&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<p><strong>Audit Trail</strong>:</p>
<ul>
<li><code>authored_by</code>: Original user ID (e.g., <code>&quot;user:leon&quot;</code>)</li>
<li><code>disclosed</code>: Whether impersonation is revealed in UI (default: false)</li>
<li><code>agent_id</code>: Impersonated agent ID (appears as message author)</li>
</ul>
<p><strong>Validation</strong>:</p>
<ul>
<li>Caller must be <code>user:*</code></li>
<li><code>acting_as</code> must reference an existing agent</li>
<li><code>acting_as</code> cannot be a <code>user:*</code> ID</li>
</ul>
<p><strong>Errors</strong>:</p>
<ul>
<li>&quot;only users can impersonate agents&quot; - Non-user caller attempted impersonation</li>
<li>&quot;users can only impersonate agents, not other users&quot; - User tried to
impersonate another user</li>
<li>&quot;agent not found&quot; - Target agent does not exist</li>
</ul>
<h3>Message Ownership</h3>
<p><strong>Editing</strong>: Only the message author can edit their own messages.</p>
<p><strong>Deletion</strong>: Only the message author can delete their own messages.</p>
<p><strong>Author determination</strong>:</p>
<ul>
<li>If <code>authored_by</code> is set (impersonation): <code>authored_by</code> is the owner</li>
<li>Otherwise: <code>agent_id</code> is the owner</li>
</ul>
<p><strong>Example</strong>: User &quot;leon&quot; impersonates agent &quot;furiosa&quot; to send a message:</p>
<ul>
<li><code>agent_id</code>: <code>&quot;furiosa&quot;</code> (appears as author)</li>
<li><code>authored_by</code>: <code>&quot;user:leon&quot;</code> (actual owner)</li>
<li>Only <code>&quot;user:leon&quot;</code> can edit/delete this message</li>
</ul>
<h3>Session-Based Authorization</h3>
<p>All RPC requests include transport context with the caller&#39;s identity.</p>
<p><strong>Transport context</strong>:</p>
<ul>
<li>Unix socket: Agent identity (from environment or registration)</li>
<li>WebSocket: User/agent identity (from registration)</li>
</ul>
<p><strong>Implicit authorization</strong>: The daemon knows which connection is making the
request.</p>
<p><strong>Use cases</strong>:</p>
<ul>
<li>Prevent cross-session operations</li>
<li>Attribute actions to sessions</li>
<li>Audit trail</li>
</ul>
<h2>Security Considerations</h2>
<h3>Local Access (Unix Domain Socket)</h3>
<p>Unix domain sockets (<code>$REPO/.thrum/daemon.sock</code>) provide inherent security:</p>
<ol>
<li><strong>No network exposure</strong>: Socket files are not accessible over the network</li>
<li><strong>Filesystem permissions</strong>: Access controlled via file permissions
(mode 0600)</li>
<li><strong>Local-only</strong>: Only processes on the same machine with appropriate
permissions can connect</li>
</ol>
<p><strong>Use cases</strong>:</p>
<ul>
<li>CLI tools (<code>thrum</code> command)</li>
<li>MCP server (<code>thrum mcp serve</code>)</li>
<li>Local agents and automation scripts</li>
<li>Development workflows</li>
</ul>
<h3>Remote Access (Tailscale WireGuard)</h3>
<p>For remote or multi-machine deployments, Thrum uses Tailscale&#39;s WireGuard mesh
network:</p>
<ol>
<li><strong>End-to-end encryption</strong>: All WebSocket traffic encrypted via WireGuard
tunnel</li>
<li><strong>Zero-trust networking</strong>: Each peer authenticates via Tailscale identity</li>
<li><strong>Automatic key rotation</strong>: WireGuard keys managed by Tailscale</li>
<li><strong>Pairing codes</strong>: Initial connection uses time-limited pairing codes</li>
<li><strong>Per-peer tokens</strong>: Ongoing authentication via per-peer tokens after pairing</li>
</ol>
<p><strong>Security properties</strong>:</p>
<ul>
<li>WebSocket connections run over Tailscale&#39;s encrypted tunnel (<code>ws://</code> over
WireGuard)</li>
<li>No separate TLS/SSL layer needed</li>
<li>Network isolation via Tailscale ACLs</li>
<li>Authentication handled by Tailscale identity + Thrum pairing</li>
</ul>
<p><strong>Reference</strong>: See <code>docs/tailscale-security.md</code> for detailed security model and
threat analysis.</p>
<h3>Authentication Layers</h3>
<ol>
<li><strong>Transport layer</strong>: Tailscale WireGuard encryption and peer authentication</li>
<li><strong>Application layer</strong>: Thrum pairing codes and per-peer tokens</li>
<li><strong>Session layer</strong>: Session management and heartbeat tracking</li>
<li><strong>Message layer</strong>: Author attribution and ownership verification</li>
</ol>
<h2>Session Lifecycle</h2>
<h3>Agent Sessions</h3>
<pre><code>1. Agent starts
   |
2. Connect to daemon (Unix socket or WebSocket)
   |
3. Register: agent.register (with optional name)
   |
4. Start session: session.start
   |
5. Send/receive messages, heartbeat periodically
   |
6. End session: session.end (or crash)
   |
7. Disconnect</code></pre>
<p>Or use <code>quickstart</code> to combine steps 3-4 (and optionally set intent):</p>
<pre><code>1. Agent starts
   |
2. Connect to daemon
   |
3. Quickstart: agent.register + session.start + set-intent
   |
4. Send/receive messages, heartbeat periodically
   |
5. End session: session.end (or crash)
   |
6. Disconnect</code></pre>
<h3>User Sessions</h3>
<pre><code>1. User opens UI at http://localhost:9999
   |
2. WebSocket connects to ws://localhost:9999/ws
   |
3. Auto-identify: user.identify (reads git config)
   |
4. Auto-register: user.register (idempotent, returns token)
   |
5. Send/receive messages, subscribe to events
   |
6. Disconnect (session persists for reconnection)</code></pre>
<h3>Orphaned Sessions</h3>
<p><strong>Problem</strong>: Agent crashes without calling <code>session.end</code>.</p>
<p><strong>Detection</strong>: When agent re-registers and starts a new session, the daemon
detects existing open sessions for that agent.</p>
<p><strong>Recovery</strong>: Orphaned sessions are automatically ended with <code>reason: &quot;crash&quot;</code>
during the next <code>session.start</code> call.</p>
<h3>Daemon Lifecycle Hardening</h3>
<p>The daemon has several safety mechanisms for robust session management:</p>
<ul>
<li><strong>Defer cleanup</strong>: Safety net catches panics/early returns, cleans up PID
file, socket, and port files on any exit</li>
<li><strong>JSON PID file</strong>: Contains <code>{PID, RepoPath, StartedAt, SocketPath}</code> for
repo-affinity validation</li>
<li><strong>Socket flock</strong>: OS-level file lock (<code>flock</code>) on the socket file,
auto-released on process death (even SIGKILL)</li>
<li><strong>Pre-startup validation</strong>: Detects duplicate daemons serving the same
repository before starting</li>
</ul>
<h2>Connection Security</h2>
<h3>Unix Socket</h3>
<p><strong>Path</strong>: <code>$REPO/.thrum/daemon.sock</code> (follows <code>.thrum/redirect</code> in worktrees)</p>
<p><strong>Access control</strong>: File system permissions (0600)</p>
<p><strong>Security</strong>: Only processes with read/write access to the socket file can
connect.</p>
<p><strong>Use cases</strong>:</p>
<ul>
<li>Local agents (same machine as daemon)</li>
<li>CLI tools</li>
<li>MCP server (<code>thrum mcp serve</code>)</li>
<li>Trusted local services</li>
</ul>
<h3>WebSocket</h3>
<p><strong>Endpoint</strong>: <code>ws://localhost:9999/ws</code> (when UI is embedded)</p>
<p><strong>Fallback</strong>: <code>ws://localhost:9999/</code> (when no UI is embedded, backward
compatible)</p>
<p><strong>Bind address</strong>: <code>127.0.0.1</code> (localhost only)</p>
<p><strong>Security</strong>: Only processes on the same machine can connect.</p>
<p><strong>Use cases</strong>:</p>
<ul>
<li>Web UI (browser on same machine, served as embedded SPA)</li>
<li>Desktop applications</li>
<li>Remote tunneling (SSH port forwarding)</li>
</ul>
<p><strong>Warning</strong>: Do not expose WebSocket port to untrusted networks without TLS and
authentication.</p>
<h2>Best Practices</h2>
<h3>Agent Development</h3>
<ol>
<li><strong>Use quickstart</strong>: Prefer <code>thrum quickstart</code> over manual register + session
start</li>
<li><strong>Use named agents</strong>: Provide <code>--name</code> for human-readable identification</li>
<li><strong>Graceful shutdown</strong>: Always call <code>session.end</code> before exiting</li>
<li><strong>Error handling</strong>: Catch crashes, end session in cleanup</li>
<li><strong>Heartbeat regularly</strong>: Call <code>session.heartbeat</code> to update work context and
stay visible</li>
<li><strong>Idempotent registration</strong>: Safe to call <code>agent.register</code> multiple times</li>
</ol>
<h3>User Clients</h3>
<ol>
<li><strong>Auto-registration</strong>: Let the <code>AuthProvider</code> handle identity automatically</li>
<li><strong>Reconnection</strong>: Re-register with same username after disconnect
(idempotent)</li>
<li><strong>Session management</strong>: Let daemon manage session lifecycle</li>
<li><strong>Impersonation disclosure</strong>: Set <code>disclosed: true</code> for transparency</li>
<li><strong>Error handling</strong>: Handle authorization errors gracefully</li>
</ol>
<h3>Security</h3>
<ol>
<li><strong>Local only</strong>: Do not expose daemon to network without authentication</li>
<li><strong>Principle of least privilege</strong>: Subscribe only to necessary events</li>
<li><strong>Audit logging</strong>: Log all user actions for accountability</li>
<li><strong>Input validation</strong>: Validate all user input before sending to daemon</li>
</ol>
<h2>Examples</h2>
<h3>Agent Registration and Session (CLI)</h3>
<pre><code># One-step quickstart (recommended)
thrum quickstart --name furiosa --role implementer --module auth \
  --intent &quot;Implementing JWT authentication&quot;

# Or step-by-step
thrum agent register --name=furiosa --role=implementer --module=auth
thrum session start
thrum send &quot;Starting work on auth module&quot; --to @coordinator</code></pre>
<h3>Agent Registration and Session (WebSocket)</h3>
<pre><code>import WebSocket from &quot;ws&quot;;

const ws = new WebSocket(&quot;ws://localhost:9999/ws&quot;);

let agentId: string;
let sessionId: string;

ws.on(&quot;open&quot;, async () =&gt; {
  // Step 1: Register agent
  ws.send(
    JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      method: &quot;agent.register&quot;,
      params: {
        name: &quot;furiosa&quot;,
        role: &quot;implementer&quot;,
        module: &quot;auth&quot;,
      },
      id: 1,
    }),
  );
});

ws.on(&quot;message&quot;, (data: string) =&gt; {
  const msg = JSON.parse(data);

  if (msg.id === 1) {
    // Registration response
    agentId = msg.result.agent_id;

    // Step 2: Start session
    ws.send(
      JSON.stringify({
        jsonrpc: &quot;2.0&quot;,
        method: &quot;session.start&quot;,
        params: { agent_id: agentId },
        id: 2,
      }),
    );
  }

  if (msg.id === 2) {
    // Session start response
    sessionId = msg.result.session_id;
    console.log(`Agent registered: ${agentId}, Session: ${sessionId}`);

    // Now ready to send messages
  }
});</code></pre>
<h3>MCP Server (Native Agent Messaging)</h3>
<pre><code># Start MCP server for Claude Code integration
THRUM_NAME=furiosa thrum mcp serve

# Or with explicit agent-id override
thrum mcp serve --agent-id furiosa</code></pre>
<p>The MCP server provides 5 tools: <code>send_message</code>, <code>check_messages</code>,
<code>wait_for_message</code>, <code>list_agents</code>, <code>broadcast_message</code>. Identity is resolved
once at startup.</p>
<h3>User Registration (Browser Auto-Registration)</h3>
<p>The browser handles registration automatically via <code>AuthProvider</code>. No manual
code is needed. The flow is:</p>
<pre><code>Page loads -&gt; AuthProvider mounts -&gt; user.identify -&gt; user.register -&gt; UI shows identity</code></pre>
<p>For programmatic WebSocket user registration:</p>
<pre><code>const ws = new WebSocket(&quot;ws://localhost:9999/ws&quot;);

ws.on(&quot;open&quot;, () =&gt; {
  // User registration (idempotent)
  ws.send(
    JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      method: &quot;user.register&quot;,
      params: {
        username: &quot;leon&quot;,
        display: &quot;Leon Letto&quot;,
      },
      id: 1,
    }),
  );
});

ws.on(&quot;message&quot;, (data: string) =&gt; {
  const msg = JSON.parse(data);

  if (msg.id === 1) {
    // User registered
    console.log(`User: ${msg.result.user_id}, Token: ${msg.result.token}`);
  }
});</code></pre>
<h2>See Also</h2>
<ul>
<li><a href="../identity.html">Identity &amp; Registration</a> - Full agent identity system
documentation</li>
<li><a href="./websocket.html">WebSocket API</a> - Full API reference</li>
<li><a href="./events.html">Event Reference</a> - Event types and payloads</li>
</ul>
<pre><code></code></pre>

</main>
<script>if(location.search.indexOf('nospa')===-1){location.replace('../../docs.html#api/authentication.html')}</script>
</body>
</html>