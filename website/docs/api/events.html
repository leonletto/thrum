<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Event Reference — Thrum</title>
<meta name="description" content="All events emitted by the Thrum daemon over WebSocket — message, agent, session, sync, and subscription events">
<link rel="canonical" href="https://leonletto.github.io/thrum/docs.html#api/events.html">
<style>
body{font-family:system-ui,sans-serif;max-width:48rem;margin:2rem auto;padding:0 1.5rem;line-height:1.6;color:#222}
pre{background:#f5f5f5;padding:1rem;overflow-x:auto;border-radius:4px}
code{font-family:ui-monospace,monospace;font-size:0.9em}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #ddd;padding:0.4rem 0.6rem;text-align:left}
th{background:#f5f5f5}
nav{margin-bottom:1.5rem;padding-bottom:1rem;border-bottom:1px solid #ddd;line-height:1.8}
h2{margin-top:2rem}
a{color:#0366d6}
</style>
</head>
<body>
<nav>
<strong><a href="../../docs.html">Thrum Docs</a></strong> &rsaquo; API Reference &rsaquo; Event Reference
<hr>
<strong>Overview</strong>: <a href="../philosophy.html">Philosophy</a><br>
<strong>Getting Started</strong>: <a href="../quickstart.html">Quickstart Guide</a><br>
  <strong>Recommended Tools</strong>: <a href="../guides/recommended-tools.html">Recommended Tools</a> | <a href="../guides/beads-setup.html">Beads Setup Guide</a> | <a href="../guides/beads-ui-setup.html">Beads UI Setup Guide</a> | <a href="../guides/playwright-cli-setup.html">Playwright CLI Setup Guide</a><br>
<strong>Web UI</strong>: <a href="../web-ui.html">Web UI</a><br>
<strong>Messaging</strong>: <a href="../subscriptions.html">Subscriptions & Notifications</a><br>
<strong>Identity</strong>: <a href="../identity.html">Agent Identity & Registration</a><br>
<strong>Guides</strong>: <a href="../agent-coordination.html">Agent Coordination</a> | <a href="../agent-configs.html">Agent Configurations</a> | <a href="../multi-agent.html">Multi-Agent Support</a> | <a href="../claude-code-plugin.html">Claude Code Plugin</a> | <a href="../configuration.html">Configuration</a> | <a href="../workflow-templates.html">Workflow Templates</a> | <a href="../beads-and-thrum.html">Beads and Thrum</a> | <a href="../codex-plugin.html">Codex Plugin</a> | <a href="../claude-agent-integration.html">Claude Code Agent Integration</a> | <a href="../messaging.html">Messaging</a> | <a href="../tailscale-sync.html">Tailscale Sync</a> | <a href="../tailscale-security.html">Tailscale Sync Security</a> | <a href="../overview.html">Technical Overview</a><br>
<strong>API Reference</strong>: <a href="../event-streaming.html">Event Streaming</a> | <a href="../inbox-query-methods.html">Inbox Query Methods</a> | <a href="../api/authentication.html">Authentication</a> | <strong>Event Reference</strong> | <a href="../rpc-api.html">RPC API</a> | <a href="../api/websocket.html">WebSocket API</a><br>
<strong>Daemon</strong>: <a href="../daemon.html">Daemon Architecture</a><br>
<strong>Sync</strong>: <a href="../sync.html">Sync Protocol</a><br>
<strong>Development</strong>: <a href="../development.html">Development Guide</a> | <a href="../security-cicd.html">Security & CI/CD</a><br>
<strong>Architecture</strong>: <a href="../architecture.html">Architecture</a><br>
<strong>Context</strong>: <a href="../context.html">Agent Context Management</a><br>
<strong>Reference</strong>: <a href="../cli.html">CLI Reference</a> | <a href="../mcp-server.html">MCP Server</a><br>
<strong>uncategorized</strong>: <a href="../role-templates.html">Role-Based Preamble Templates</a><br>
</nav>
<main>
<h2>Event Reference</h2>
<p>This document provides detailed documentation for all events emitted by the
Thrum daemon over WebSocket connections.</p>
<h2>Event Format</h2>
<p>Events are sent as JSON-RPC 2.0 notifications (without an <code>id</code> field):</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;event.type&quot;,
  &quot;params&quot;: {
    // event-specific payload
  }
}</code></pre>
<p><strong>Key characteristics</strong>:</p>
<ul>
<li>No <code>id</code> field (notifications don&#39;t expect responses)</li>
<li><code>method</code> field contains the event type</li>
<li><code>params</code> contains the event payload</li>
<li>Events are one-way: server → client</li>
</ul>
<h2>Event Delivery</h2>
<h3>Subscription-Based</h3>
<p>Events are only delivered to clients that have active subscriptions matching the
event.</p>
<p><strong>Subscription types</strong>:</p>
<ol>
<li><strong>Scope-based</strong>: Receive events for messages with specific scopes</li>
<li><strong>Mention-based</strong>: Receive events for messages mentioning a specific role</li>
<li><strong>All</strong>: Receive all events (use sparingly)</li>
</ol>
<h3>Delivery Guarantees</h3>
<ul>
<li><strong>At-least-once</strong>: Events may be delivered multiple times</li>
<li><strong>Ordering</strong>: Events for the same message are ordered, but events across
messages may be out of order</li>
<li><strong>Buffer limit</strong>: Client buffers have a limit (default 100); slow clients may
miss events</li>
</ul>
<h2>Common Fields</h2>
<p>All persisted events share a common base structure:</p>
<pre><code>{
  &quot;type&quot;: &quot;event.type&quot;,
  &quot;timestamp&quot;: &quot;2024-01-01T12:00:00Z&quot;,
  &quot;event_id&quot;: &quot;01HQXYZ...&quot;,
  &quot;v&quot;: 1
}</code></pre>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>type</code></td>
<td>string</td>
<td>Event type identifier (e.g., <code>message.create</code>)</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>string</td>
<td>ISO 8601 timestamp</td>
</tr>
<tr>
<td><code>event_id</code></td>
<td>string</td>
<td>Globally unique ULID, used for deduplication</td>
</tr>
<tr>
<td><code>v</code></td>
<td>int</td>
<td>Event schema version (currently <code>1</code>)</td>
</tr>
</tbody></table>
<h2>JSONL Storage</h2>
<p>Events are persisted as sharded JSONL files in the sync worktree at
<code>.git/thrum-sync/a-sync/</code>:</p>
<pre><code>.git/thrum-sync/a-sync/
├── events.jsonl              Agent lifecycle events
└── messages/
    └── {agent_name}.jsonl    Per-agent message events</code></pre>
<p><strong>Storage assignment</strong>:</p>
<table>
<thead>
<tr>
<th>File</th>
<th>Event Types</th>
</tr>
</thead>
<tbody><tr>
<td><code>events.jsonl</code></td>
<td><code>agent.register</code>, <code>agent.session.start</code>, <code>agent.session.end</code>, <code>agent.cleanup</code></td>
</tr>
<tr>
<td><code>messages/{agent}.jsonl</code></td>
<td><code>message.create</code>, <code>message.edit</code>, <code>message.delete</code>, <code>thread.create</code>, <code>agent.update</code></td>
</tr>
</tbody></table>
<p>Events are append-only and immutable. The JSONL files are the source of truth;
the SQLite database (<code>.thrum/var/messages.db</code>) is a derived read projection that
can be rebuilt from the JSONL at any time.</p>
<h2>Event Types</h2>
<h3>Message Events</h3>
<h4>message.create</h4>
<p>Emitted when a new message is created in the system.</p>
<p><strong>When emitted</strong>:</p>
<ul>
<li>After <code>message.send</code> RPC call succeeds</li>
<li>When message is synced from remote</li>
<li>For both agent and user messages</li>
</ul>
<p><strong>Stored in</strong>: <code>messages/{agent_name}.jsonl</code></p>
<p><strong>Payload</strong> (MessageCreateEvent):</p>
<pre><code>{
  &quot;type&quot;: &quot;message.create&quot;,
  &quot;timestamp&quot;: &quot;2024-01-01T12:00:00Z&quot;,
  &quot;event_id&quot;: &quot;01HQXYZ...&quot;,
  &quot;v&quot;: 1,
  &quot;message_id&quot;: &quot;msg_xyz789&quot;,
  &quot;thread_id&quot;: &quot;thread_abc123&quot;,
  &quot;agent_id&quot;: &quot;furiosa&quot;,
  &quot;session_id&quot;: &quot;s_abc123&quot;,
  &quot;body&quot;: {
    &quot;format&quot;: &quot;markdown&quot;,
    &quot;content&quot;: &quot;Hello, world!&quot;,
    &quot;structured&quot;: &quot;{\&quot;key\&quot;:\&quot;value\&quot;}&quot;
  },
  &quot;scopes&quot;: [
    {
      &quot;type&quot;: &quot;task&quot;,
      &quot;value&quot;: &quot;PROJ-123&quot;
    }
  ],
  &quot;refs&quot;: [
    {
      &quot;type&quot;: &quot;mention&quot;,
      &quot;value&quot;: &quot;reviewer&quot;
    }
  ],
  &quot;authored_by&quot;: &quot;&quot;,
  &quot;disclosed&quot;: false
}</code></pre>
<p><strong>Fields</strong>:</p>
<ul>
<li><code>event_id</code>: Globally unique ULID for deduplication</li>
<li><code>v</code>: Event schema version</li>
<li><code>message_id</code>: Unique message identifier</li>
<li><code>thread_id</code>: Parent thread (empty if standalone message)</li>
<li><code>agent_id</code>: Message author&#39;s agent name or legacy ID</li>
<li><code>session_id</code>: Session that created the message</li>
<li><code>timestamp</code>: Message creation time (ISO 8601)</li>
<li><code>body.format</code>: Content format (<code>markdown</code>, <code>plain</code>, <code>json</code>)</li>
<li><code>body.content</code>: Message text content</li>
<li><code>body.structured</code>: Optional structured data (JSON string)</li>
<li><code>scopes</code>: List of scope tags (context)</li>
<li><code>refs</code>: List of references (mentions, links, etc.)</li>
<li><code>authored_by</code>: Original author if impersonated (empty otherwise)</li>
<li><code>disclosed</code>: Whether impersonation is disclosed</li>
</ul>
<p><strong>Related methods</strong>: <code>message.send</code>, <code>message.list</code></p>
<p><strong>Example usage</strong>:</p>
<pre><code>ws.onmessage = (event) =&gt; {
  const msg = JSON.parse(event.data);
  if (msg.method === &quot;message.create&quot;) {
    const message = msg.params;
    console.log(
      `New message from ${message.agent_id}: ${message.body.content}`,
    );
  }
};</code></pre>
<h4>message.edit</h4>
<p>Emitted when a message is edited.</p>
<p><strong>When emitted</strong>:</p>
<ul>
<li>After <code>message.edit</code> RPC call succeeds</li>
<li>When message edit is synced from remote</li>
<li>Only the message author can edit messages</li>
</ul>
<p><strong>Stored in</strong>: <code>messages/{agent_name}.jsonl</code></p>
<p><strong>Payload</strong> (MessageEditEvent):</p>
<pre><code>{
  &quot;type&quot;: &quot;message.edit&quot;,
  &quot;timestamp&quot;: &quot;2024-01-01T13:00:00Z&quot;,
  &quot;event_id&quot;: &quot;01HQXYZ...&quot;,
  &quot;v&quot;: 1,
  &quot;message_id&quot;: &quot;msg_xyz789&quot;,
  &quot;body&quot;: {
    &quot;format&quot;: &quot;markdown&quot;,
    &quot;content&quot;: &quot;Updated content&quot;,
    &quot;structured&quot;: &quot;{\&quot;updated\&quot;:true}&quot;
  }
}</code></pre>
<p><strong>Fields</strong>:</p>
<ul>
<li><code>event_id</code>: Globally unique ULID for deduplication</li>
<li><code>message_id</code>: ID of edited message</li>
<li><code>timestamp</code>: Edit time (ISO 8601)</li>
<li><code>body</code>: Updated message body</li>
</ul>
<p><strong>Edit history</strong>: Full edit history is stored in the database (<code>message_edits</code>
table) and includes:</p>
<ul>
<li>Old content</li>
<li>New content</li>
<li>Timestamp</li>
<li>Editor session ID</li>
</ul>
<p><strong>Related methods</strong>: <code>message.edit</code>, <code>message.get</code></p>
<p><strong>Example usage</strong>:</p>
<pre><code>ws.onmessage = (event) =&gt; {
  const msg = JSON.parse(event.data);
  if (msg.method === &quot;message.edit&quot;) {
    const edit = msg.params;
    updateMessageInUI(edit.message_id, edit.body.content);
  }
};</code></pre>
<h4>message.delete</h4>
<p>Emitted when a message is soft-deleted.</p>
<p><strong>When emitted</strong>:</p>
<ul>
<li>After <code>message.delete</code> RPC call succeeds</li>
<li>When message deletion is synced from remote</li>
<li>Only the message author can delete messages</li>
</ul>
<p><strong>Stored in</strong>: <code>messages/{agent_name}.jsonl</code></p>
<p><strong>Payload</strong> (MessageDeleteEvent):</p>
<pre><code>{
  &quot;type&quot;: &quot;message.delete&quot;,
  &quot;timestamp&quot;: &quot;2024-01-01T14:00:00Z&quot;,
  &quot;event_id&quot;: &quot;01HQXYZ...&quot;,
  &quot;v&quot;: 1,
  &quot;message_id&quot;: &quot;msg_xyz789&quot;,
  &quot;reason&quot;: &quot;spam&quot;
}</code></pre>
<p><strong>Fields</strong>:</p>
<ul>
<li><code>event_id</code>: Globally unique ULID for deduplication</li>
<li><code>message_id</code>: ID of deleted message</li>
<li><code>timestamp</code>: Deletion time (ISO 8601)</li>
<li><code>reason</code>: Optional deletion reason</li>
</ul>
<p><strong>Soft deletion</strong>: Messages are marked as deleted but not removed from the
database. The message content is preserved for audit purposes.</p>
<p><strong>Related methods</strong>: <code>message.delete</code>, <code>message.list</code> (with <code>include_deleted</code>
param)</p>
<p><strong>Example usage</strong>:</p>
<pre><code>ws.onmessage = (event) =&gt; {
  const msg = JSON.parse(event.data);
  if (msg.method === &quot;message.delete&quot;) {
    const deletion = msg.params;
    removeMessageFromUI(deletion.message_id);
  }
};</code></pre>
<h3>Thread Events</h3>
<h4>thread.create</h4>
<p>Emitted when a new thread is created.</p>
<p><strong>When emitted</strong>:</p>
<ul>
<li>After <code>thread.create</code> RPC call succeeds</li>
<li>When thread is synced from remote</li>
</ul>
<p><strong>Stored in</strong>: <code>messages/{agent_name}.jsonl</code></p>
<p><strong>Payload</strong> (ThreadCreateEvent):</p>
<pre><code>{
  &quot;type&quot;: &quot;thread.create&quot;,
  &quot;timestamp&quot;: &quot;2024-01-01T12:00:00Z&quot;,
  &quot;event_id&quot;: &quot;01HQXYZ...&quot;,
  &quot;v&quot;: 1,
  &quot;thread_id&quot;: &quot;thread_abc123&quot;,
  &quot;title&quot;: &quot;Discussion about feature X&quot;,
  &quot;created_by&quot;: &quot;furiosa&quot;
}</code></pre>
<p><strong>Fields</strong>:</p>
<ul>
<li><code>event_id</code>: Globally unique ULID for deduplication</li>
<li><code>thread_id</code>: Unique thread identifier</li>
<li><code>title</code>: Thread title</li>
<li><code>timestamp</code>: Creation time (ISO 8601)</li>
<li><code>created_by</code>: Agent/user that created the thread</li>
</ul>
<p><strong>Related methods</strong>: <code>thread.create</code>, <code>thread.list</code>, <code>thread.get</code></p>
<h4>thread.updated</h4>
<p>Real-time notification emitted when a thread is updated with new messages. This
event is a WebSocket notification only and is <strong>not persisted</strong> to JSONL.</p>
<p><strong>When emitted</strong>:</p>
<ul>
<li>After a new message is added to a thread</li>
<li>Sent to clients with matching subscriptions</li>
</ul>
<p><strong>Payload</strong> (ThreadUpdatedEvent):</p>
<pre><code>{
  &quot;type&quot;: &quot;thread.updated&quot;,
  &quot;timestamp&quot;: &quot;2024-01-01T13:00:00Z&quot;,
  &quot;event_id&quot;: &quot;01HQXYZ...&quot;,
  &quot;v&quot;: 1,
  &quot;thread_id&quot;: &quot;thread_abc123&quot;,
  &quot;message_count&quot;: 5,
  &quot;unread_count&quot;: 2,
  &quot;last_activity&quot;: &quot;2024-01-01T13:00:00Z&quot;,
  &quot;last_sender&quot;: &quot;furiosa&quot;,
  &quot;preview&quot;: &quot;Latest message text...&quot;
}</code></pre>
<p><strong>Fields</strong>:</p>
<ul>
<li><code>thread_id</code>: Thread that was updated</li>
<li><code>message_count</code>: Total messages in thread</li>
<li><code>unread_count</code>: Unread messages for the subscribing agent</li>
<li><code>last_activity</code>: Timestamp of latest activity</li>
<li><code>last_sender</code>: Agent who sent the latest message</li>
<li><code>preview</code>: Optional preview of latest message content</li>
</ul>
<h3>Agent Events</h3>
<h4>agent.register</h4>
<p>Emitted when an agent registers with the daemon.</p>
<p><strong>When emitted</strong>:</p>
<ul>
<li>After <code>agent.register</code> RPC call succeeds (first registration)</li>
<li>Not emitted for re-registrations of existing agents</li>
</ul>
<p><strong>Stored in</strong>: <code>events.jsonl</code></p>
<p><strong>Payload</strong> (AgentRegisterEvent):</p>
<pre><code>{
  &quot;type&quot;: &quot;agent.register&quot;,
  &quot;timestamp&quot;: &quot;2024-01-01T12:00:00Z&quot;,
  &quot;event_id&quot;: &quot;01HQXYZ...&quot;,
  &quot;v&quot;: 1,
  &quot;agent_id&quot;: &quot;furiosa&quot;,
  &quot;kind&quot;: &quot;agent&quot;,
  &quot;name&quot;: &quot;furiosa&quot;,
  &quot;role&quot;: &quot;implementer&quot;,
  &quot;module&quot;: &quot;auth&quot;,
  &quot;worktree&quot;: &quot;main&quot;,
  &quot;display&quot;: &quot;Auth Implementer&quot;
}</code></pre>
<p><strong>Fields</strong>:</p>
<ul>
<li><code>event_id</code>: Globally unique ULID for deduplication</li>
<li><code>agent_id</code>: Agent identifier (name-based for named agents, legacy hash for
unnamed)</li>
<li><code>kind</code>: Agent kind (<code>&quot;agent&quot;</code> or <code>&quot;user&quot;</code>)</li>
<li><code>name</code>: Human-readable agent name (lowercase alphanumeric + underscores, e.g.,
<code>furiosa</code>). Empty for legacy unnamed agents.</li>
<li><code>role</code>: Agent role (e.g., <code>implementer</code>, <code>reviewer</code>, <code>coordinator</code>)</li>
<li><code>module</code>: Agent module (area of work)</li>
<li><code>worktree</code>: Git worktree name the agent is operating in</li>
<li><code>display</code>: Optional display name</li>
<li><code>timestamp</code>: Registration time (ISO 8601)</li>
</ul>
<p><strong>Agent naming</strong>: Agents support human-readable names set via <code>--name</code> flag,
<code>THRUM_NAME</code> env var, or identity files at <code>.thrum/identities/{name}.json</code>.
Names must match <code>[a-z0-9_]+</code> and cannot use reserved words (<code>daemon</code>, <code>system</code>,
<code>thrum</code>, <code>all</code>, <code>broadcast</code>).</p>
<p><strong>Related methods</strong>: <code>agent.register</code>, <code>agent.list</code></p>
<h4>agent.cleanup</h4>
<p>Emitted when an agent is deleted or cleaned up.</p>
<p><strong>When emitted</strong>:</p>
<ul>
<li>After <code>thrum agent delete NAME</code> CLI command</li>
<li>After <code>thrum agent cleanup --force</code> removes orphaned agents</li>
<li>When cleanup is triggered from the UI</li>
</ul>
<p><strong>Stored in</strong>: <code>events.jsonl</code></p>
<p><strong>Payload</strong> (AgentCleanupEvent):</p>
<pre><code>{
  &quot;type&quot;: &quot;agent.cleanup&quot;,
  &quot;timestamp&quot;: &quot;2024-01-01T15:00:00Z&quot;,
  &quot;event_id&quot;: &quot;01HQXYZ...&quot;,
  &quot;v&quot;: 1,
  &quot;agent_id&quot;: &quot;furiosa&quot;,
  &quot;reason&quot;: &quot;manual deletion&quot;,
  &quot;method&quot;: &quot;manual&quot;
}</code></pre>
<p><strong>Fields</strong>:</p>
<ul>
<li><code>event_id</code>: Globally unique ULID for deduplication</li>
<li><code>agent_id</code>: Name of the deleted agent</li>
<li><code>timestamp</code>: Cleanup time (ISO 8601)</li>
<li><code>reason</code>: Optional reason for cleanup</li>
<li><code>method</code>: How cleanup was triggered (<code>&quot;manual&quot;</code>, <code>&quot;automated&quot;</code>, <code>&quot;ui&quot;</code>)</li>
</ul>
<p><strong>Related methods</strong>: <code>agent.delete</code>, <code>agent.cleanup</code></p>
<h4>agent.update</h4>
<p>Emitted when an agent&#39;s work context changes (git state, intent, task).</p>
<p><strong>When emitted</strong>:</p>
<ul>
<li>After a heartbeat detects git state changes</li>
<li>After <code>set-intent</code> or <code>set-task</code> RPC calls</li>
</ul>
<p><strong>Stored in</strong>: <code>messages/{agent_name}.jsonl</code></p>
<p><strong>Payload</strong> (AgentUpdateEvent):</p>
<pre><code>{
  &quot;type&quot;: &quot;agent.update&quot;,
  &quot;timestamp&quot;: &quot;2024-01-01T12:30:00Z&quot;,
  &quot;event_id&quot;: &quot;01HQXYZ...&quot;,
  &quot;v&quot;: 1,
  &quot;agent_id&quot;: &quot;furiosa&quot;,
  &quot;work_contexts&quot;: [
    {
      &quot;session_id&quot;: &quot;s_abc123&quot;,
      &quot;branch&quot;: &quot;feature/auth&quot;,
      &quot;worktree_path&quot;: &quot;/path/to/repo&quot;,
      &quot;unmerged_commits&quot;: [{ &quot;sha&quot;: &quot;abc1234&quot;, &quot;message&quot;: &quot;Add login form&quot; }],
      &quot;uncommitted_files&quot;: [&quot;auth.go&quot;],
      &quot;changed_files&quot;: [&quot;auth.go&quot;, &quot;auth_test.go&quot;],
      &quot;git_updated_at&quot;: &quot;2024-01-01T12:30:00Z&quot;,
      &quot;current_task&quot;: &quot;Implement login flow&quot;,
      &quot;task_updated_at&quot;: &quot;2024-01-01T12:00:00Z&quot;,
      &quot;intent&quot;: &quot;Building auth module&quot;,
      &quot;intent_updated_at&quot;: &quot;2024-01-01T12:00:00Z&quot;
    }
  ]
}</code></pre>
<p><strong>Fields</strong>:</p>
<ul>
<li><code>event_id</code>: Globally unique ULID for deduplication</li>
<li><code>agent_id</code>: Agent whose context changed</li>
<li><code>work_contexts</code>: Array of per-session work context snapshots</li>
<li><code>work_contexts[].session_id</code>: Session this context belongs to</li>
<li><code>work_contexts[].branch</code>: Current git branch</li>
<li><code>work_contexts[].worktree_path</code>: Filesystem path to worktree</li>
<li><code>work_contexts[].unmerged_commits</code>: Commits not yet on the base branch</li>
<li><code>work_contexts[].uncommitted_files</code>: Files with uncommitted changes</li>
<li><code>work_contexts[].changed_files</code>: All modified files</li>
<li><code>work_contexts[].git_updated_at</code>: When git state was last checked</li>
<li><code>work_contexts[].current_task</code>: Current task description</li>
<li><code>work_contexts[].intent</code>: Agent&#39;s stated intent</li>
</ul>
<p><strong>Projection</strong>: Work contexts are merged by <code>session_id</code> -- for contexts with
the same session, the one with the newer <code>git_updated_at</code> wins.</p>
<h3>Session Events</h3>
<h4>agent.session.start</h4>
<p>Emitted when a session starts.</p>
<p><strong>When emitted</strong>:</p>
<ul>
<li>After <code>session.start</code> RPC call succeeds</li>
<li>When session start event is synced from remote</li>
</ul>
<p><strong>Stored in</strong>: <code>events.jsonl</code></p>
<p><strong>Payload</strong> (AgentSessionStartEvent):</p>
<pre><code>{
  &quot;type&quot;: &quot;agent.session.start&quot;,
  &quot;timestamp&quot;: &quot;2024-01-01T12:00:00Z&quot;,
  &quot;event_id&quot;: &quot;01HQXYZ...&quot;,
  &quot;v&quot;: 1,
  &quot;session_id&quot;: &quot;s_abc123&quot;,
  &quot;agent_id&quot;: &quot;furiosa&quot;
}</code></pre>
<p><strong>Fields</strong>:</p>
<ul>
<li><code>event_id</code>: Globally unique ULID for deduplication</li>
<li><code>session_id</code>: Unique session identifier</li>
<li><code>agent_id</code>: Agent that owns this session</li>
<li><code>timestamp</code>: Session start time (ISO 8601)</li>
</ul>
<p><strong>Session lifecycle</strong>:</p>
<ol>
<li>Agent registers</li>
<li>Session starts</li>
<li>Agent sends/receives messages</li>
<li>Session ends (gracefully or crash)</li>
<li>Orphan recovery on next session start</li>
</ol>
<p><strong>Related methods</strong>: <code>session.start</code>, <code>session.end</code></p>
<h4>agent.session.end</h4>
<p>Emitted when a session ends.</p>
<p><strong>When emitted</strong>:</p>
<ul>
<li>After <code>session.end</code> RPC call succeeds</li>
<li>When session end event is synced from remote</li>
<li>When daemon detects a crashed session</li>
</ul>
<p><strong>Stored in</strong>: <code>events.jsonl</code></p>
<p><strong>Payload</strong> (AgentSessionEndEvent):</p>
<pre><code>{
  &quot;type&quot;: &quot;agent.session.end&quot;,
  &quot;timestamp&quot;: &quot;2024-01-01T13:00:00Z&quot;,
  &quot;event_id&quot;: &quot;01HQXYZ...&quot;,
  &quot;v&quot;: 1,
  &quot;session_id&quot;: &quot;s_abc123&quot;,
  &quot;reason&quot;: &quot;normal&quot;
}</code></pre>
<p><strong>Fields</strong>:</p>
<ul>
<li><code>event_id</code>: Globally unique ULID for deduplication</li>
<li><code>session_id</code>: Session that ended</li>
<li><code>timestamp</code>: Session end time (ISO 8601)</li>
<li><code>reason</code>: End reason (<code>normal</code>, <code>crash</code>)</li>
</ul>
<p><strong>End reasons</strong>:</p>
<ul>
<li><code>normal</code>: Graceful shutdown</li>
<li><code>crash</code>: Unexpected termination or timeout</li>
</ul>
<p><strong>Related methods</strong>: <code>session.end</code>, <code>session.start</code></p>
<h2>Subscription Filtering</h2>
<p>Events are filtered based on active subscriptions:</p>
<h3>Scope-Based Subscriptions</h3>
<p>Only receive events for messages that match the subscribed scope.</p>
<p><strong>Example</strong>: Subscribe to all messages in task &quot;PROJ-123&quot;</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;subscribe.create&quot;,
  &quot;params&quot;: {
    &quot;filter_type&quot;: &quot;scope&quot;,
    &quot;scope&quot;: {
      &quot;type&quot;: &quot;task&quot;,
      &quot;value&quot;: &quot;PROJ-123&quot;
    }
  },
  &quot;id&quot;: 1
}</code></pre>
<p><strong>Matching logic</strong>:</p>
<ul>
<li>Event&#39;s <code>scopes</code> array contains an exact match for the subscribed scope</li>
<li>Scope type and value must both match</li>
</ul>
<h3>Mention-Based Subscriptions</h3>
<p>Only receive events for messages that mention a specific role.</p>
<p><strong>Example</strong>: Subscribe to messages mentioning &quot;@reviewer&quot;</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;subscribe.create&quot;,
  &quot;params&quot;: {
    &quot;filter_type&quot;: &quot;mention&quot;,
    &quot;mention&quot;: &quot;reviewer&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<p><strong>Matching logic</strong>:</p>
<ul>
<li>Event&#39;s <code>refs</code> array contains a reference with <code>type: &quot;mention&quot;</code> and
<code>value: &quot;reviewer&quot;</code></li>
</ul>
<h3>All-Events Subscriptions</h3>
<p>Receive all events (use with caution, high volume).</p>
<p><strong>Example</strong>: Subscribe to all events</p>
<pre><code>{
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;method&quot;: &quot;subscribe.create&quot;,
  &quot;params&quot;: {
    &quot;filter_type&quot;: &quot;all&quot;
  },
  &quot;id&quot;: 1
}</code></pre>
<p><strong>Use cases</strong>:</p>
<ul>
<li>Admin dashboards</li>
<li>Audit logging</li>
<li>System monitoring</li>
</ul>
<p><strong>Warning</strong>: High traffic, may overwhelm slow clients</p>
<h2>Event Ordering</h2>
<h3>Guarantees</h3>
<ul>
<li><strong>Per-message ordering</strong>: Events for the same message (create → edit → delete)
are always in order</li>
<li><strong>Cross-message ordering</strong>: No guarantee; events may arrive out of order</li>
</ul>
<h3>Timestamps</h3>
<p>All events include ISO 8601 timestamps. Use these for:</p>
<ul>
<li>Sorting events client-side</li>
<li>Detecting out-of-order delivery</li>
<li>Time-based filtering</li>
</ul>
<h3>Sequence Numbers</h3>
<p>Future enhancement: Add sequence numbers for detecting gaps.</p>
<h2>Client Buffer Management</h2>
<h3>Buffer Limits</h3>
<ul>
<li>Default buffer size: <strong>100 events</strong></li>
<li>Buffer is per-client (per WebSocket connection)</li>
<li>When buffer is full, oldest events are dropped</li>
</ul>
<h3>Buffer Full Behavior</h3>
<ol>
<li>Client&#39;s buffer fills up (slow consumer)</li>
<li>New events are dropped (not queued)</li>
<li>Client connection may be closed if buffer remains full</li>
</ol>
<h3>Best Practices</h3>
<ol>
<li><strong>Process events quickly</strong>: Don&#39;t block the event handler</li>
<li><strong>Use background workers</strong>: Offload heavy processing</li>
<li><strong>Monitor buffer</strong>: Watch for dropped events</li>
<li><strong>Adjust subscriptions</strong>: Subscribe only to necessary events</li>
</ol>
<h2>Error Scenarios</h2>
<h3>Missed Events</h3>
<p><strong>Causes</strong>:</p>
<ul>
<li>Client buffer full (slow consumer)</li>
<li>WebSocket connection interruption</li>
<li>Client disconnected during event delivery</li>
</ul>
<p><strong>Detection</strong>:</p>
<ul>
<li>Monitor timestamp gaps</li>
<li>Track expected vs actual event counts</li>
</ul>
<p><strong>Recovery</strong>:</p>
<ul>
<li>Poll with <code>message.list</code> to catch up</li>
<li>Re-subscribe after reconnection</li>
<li>Use pagination to fetch missed messages</li>
</ul>
<h3>Duplicate Events</h3>
<p><strong>Causes</strong>:</p>
<ul>
<li>Retry logic on server</li>
<li>Network-level retransmission</li>
<li>Multiple subscriptions matching same event</li>
</ul>
<p><strong>Handling</strong>:</p>
<ul>
<li>Use <code>event_id</code> (ULID) for deduplication -- this is the universal dedup key
across all event types</li>
<li>Maintain a set of processed event IDs</li>
<li>Clear processed IDs periodically (TTL)</li>
</ul>
<p>Note: Do not use <code>message_id</code> for deduplication, as multiple events can share
the same <code>message_id</code> (e.g., a <code>message.create</code> and subsequent <code>message.edit</code>
for the same message).</p>
<h2>Best Practices</h2>
<h3>Subscription Management</h3>
<ol>
<li><strong>Specific filters</strong>: Use scope/mention filters instead of &quot;all&quot;</li>
<li><strong>Cleanup</strong>: Unsubscribe when no longer needed</li>
<li><strong>Session-bound</strong>: Subscriptions auto-expire when session ends</li>
</ol>
<h3>Event Processing</h3>
<ol>
<li><strong>Idempotent handlers</strong>: Handle duplicate events gracefully</li>
<li><strong>Error handling</strong>: Don&#39;t crash on malformed events</li>
<li><strong>Async processing</strong>: Don&#39;t block WebSocket thread</li>
</ol>
<h3>Performance</h3>
<ol>
<li><strong>Batch updates</strong>: Buffer UI updates, render in batches</li>
<li><strong>Debounce</strong>: Delay rapid successive events</li>
<li><strong>Throttle</strong>: Limit event processing rate</li>
</ol>
<h3>Debugging</h3>
<ol>
<li><strong>Log all events</strong>: For development/debugging</li>
<li><strong>Event counters</strong>: Track received vs processed</li>
<li><strong>Timestamp monitoring</strong>: Detect delivery delays</li>
</ol>
<h2>Example Event Handlers</h2>
<h3>JavaScript/TypeScript</h3>
<pre><code>const eventHandlers = {
  &quot;message.create&quot;: (params: MessageCreateEvent) =&gt; {
    console.log(`New message: ${params.message_id}`);
    addMessageToUI(params);
  },

  &quot;message.edit&quot;: (params: MessageEditEvent) =&gt; {
    console.log(`Message edited: ${params.message_id}`);
    updateMessageInUI(params);
  },

  &quot;message.delete&quot;: (params: MessageDeleteEvent) =&gt; {
    console.log(`Message deleted: ${params.message_id}`);
    removeMessageFromUI(params);
  },
};

ws.onmessage = (event) =&gt; {
  const msg = JSON.parse(event.data);

  // Handle events (no id field)
  if (!msg.id &amp;&amp; msg.method) {
    const handler = eventHandlers[msg.method];
    if (handler) {
      handler(msg.params);
    } else {
      console.warn(`Unknown event type: ${msg.method}`);
    }
  }

  // Handle RPC responses (has id field)
  else if (msg.id) {
    handleRPCResponse(msg);
  }
};</code></pre>
<h3>Go</h3>
<pre><code>type EventHandler func(json.RawMessage) error

handlers := map[string]EventHandler{
    &quot;message.create&quot;: func(params json.RawMessage) error {
        var event types.MessageCreateEvent
        if err := json.Unmarshal(params, &amp;event); err != nil {
            return err
        }
        log.Printf(&quot;New message: %s&quot;, event.MessageID)
        return addMessageToUI(event)
    },

    &quot;message.edit&quot;: func(params json.RawMessage) error {
        var event types.MessageEditEvent
        if err := json.Unmarshal(params, &amp;event); err != nil {
            return err
        }
        log.Printf(&quot;Message edited: %s&quot;, event.MessageID)
        return updateMessageInUI(event)
    },
}

func handleMessage(data []byte) error {
    var msg struct {
        JSONRPC string          `json:&quot;jsonrpc&quot;`
        Method  string          `json:&quot;method,omitempty&quot;`
        Params  json.RawMessage `json:&quot;params,omitempty&quot;`
        ID      *int            `json:&quot;id,omitempty&quot;`
    }

    if err := json.Unmarshal(data, &amp;msg); err != nil {
        return err
    }

    // Event (no ID field)
    if msg.ID == nil &amp;&amp; msg.Method != &quot;&quot; {
        handler, ok := handlers[msg.Method]
        if !ok {
            log.Printf(&quot;Unknown event: %s&quot;, msg.Method)
            return nil
        }
        return handler(msg.Params)
    }

    // RPC response (has ID)
    return handleRPCResponse(&amp;msg)
}</code></pre>
<h2>See Also</h2>
<ul>
<li><a href="./websocket.html">WebSocket API</a> - Main API documentation</li>
<li><a href="./authentication.html">Authentication Guide</a> - User and agent authentication</li>
</ul>
<pre><code></code></pre>

</main>
<script>if(location.search.indexOf('nospa')===-1){location.replace('../../docs.html#api/events.html')}</script>
</body>
</html>